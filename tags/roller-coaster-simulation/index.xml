<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Roller Coaster Simulation on Ercan Akyürek</title><link>https://ercanakyuerek.de/tags/roller-coaster-simulation/</link><description>Recent content in Roller Coaster Simulation on Ercan Akyürek</description><generator>Hugo</generator><language>en</language><lastBuildDate>Tue, 07 Mar 2023 00:30:20 +0100</lastBuildDate><atom:link href="https://ercanakyuerek.de/tags/roller-coaster-simulation/index.xml" rel="self" type="application/rss+xml"/><item><title>First results and improved spline interpolation</title><link>https://ercanakyuerek.de/posts/rollercoaster-simulation/improved-spline-interpolation/</link><pubDate>Tue, 07 Mar 2023 00:30:20 +0100</pubDate><guid>https://ercanakyuerek.de/posts/rollercoaster-simulation/improved-spline-interpolation/</guid><description>&lt;p&gt;In the latest update I tracked down a couple of bugs that caused all those tiny jitters I
mentioned earlier. At first I thought they were just floating-point problems coming from
the WebAssembly module in the browser, but the real issue turned out to be the
&lt;strong&gt;roll interpolation&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Let me give you a quick overview of what’s going on. When we interpolate a NURBS track,
we first estimate the total track length using a pretty rough step size. Based on that
estimation, we generate a dense enough set of nodes. After that, we compute normals for
e very node and apply the normal angles on the &lt;strong&gt;x&lt;/strong&gt; and &lt;strong&gt;y&lt;/strong&gt; axes, the &lt;strong&gt;z&lt;/strong&gt; axis (the roll)
comes later. These normals get applied to the previous matrix, so the whole orientation
flows along the track. Once that’s done, we generate a &lt;strong&gt;C2-continuous cubic spline&lt;/strong&gt;, and
the z-rotation that results from applying the x/y normals is added to the roll value at
each roll point.&lt;/p&gt;</description></item></channel></rss>