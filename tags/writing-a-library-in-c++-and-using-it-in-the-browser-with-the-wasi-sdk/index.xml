<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Writing a Library in C++ and Using It in the Browser With the WASI SDK on Ercan Akyürek</title><link>https://ercanakyuerek.de/tags/writing-a-library-in-c++-and-using-it-in-the-browser-with-the-wasi-sdk/</link><description>Recent content in Writing a Library in C++ and Using It in the Browser With the WASI SDK on Ercan Akyürek</description><generator>Hugo</generator><language>en</language><lastBuildDate>Mon, 27 Feb 2023 17:45:00 +0100</lastBuildDate><atom:link href="https://ercanakyuerek.de/tags/writing-a-library-in-c++-and-using-it-in-the-browser-with-the-wasi-sdk/index.xml" rel="self" type="application/rss+xml"/><item><title>JavaScript module</title><link>https://ercanakyuerek.de/posts/wasi/javascript-module/</link><pubDate>Mon, 27 Feb 2023 17:45:00 +0100</pubDate><guid>https://ercanakyuerek.de/posts/wasi/javascript-module/</guid><description>&lt;p&gt;This is the point where we start writing the &lt;strong&gt;JavaScript&lt;/strong&gt; side of
the library that talks to our &lt;strong&gt;WebAssembly&lt;/strong&gt; module.&lt;/p&gt;
&lt;p&gt;At this stage, the WebAssembly part already exists and exposes a
couple of useful functions. What we need now is a small JavaScript
wrapper that loads the module, wires things together, and gives us a
nicer API to work with.&lt;/p&gt;
&lt;p&gt;I have created a very basic template for this. You may notice that we
define a number of imports for &lt;strong&gt;WASI&lt;/strong&gt;, but all of them are empty.
This looks suspicious at first, so let us talk about that.&lt;/p&gt;</description></item><item><title>Implementing library functions</title><link>https://ercanakyuerek.de/posts/wasi/implementing-library-functions/</link><pubDate>Fri, 24 Feb 2023 00:19:00 +0100</pubDate><guid>https://ercanakyuerek.de/posts/wasi/implementing-library-functions/</guid><description>&lt;div class="embedded float-right"&gt;
 &lt;iframe
 id="react-root-371c84926a10fbac345fff59fd54f1a3"
 width="225px"
 height="285px"
 class="frame"
 &gt;&lt;/iframe&gt;

 
 &lt;div class="description" style="width: 225px"&gt;
 Transition from parameter-based non-uniform to uniform node spacing. The control points are draggable.
 &lt;/div&gt;
 

 &lt;script&gt;
 document.getElementById('react-root-371c84926a10fbac345fff59fd54f1a3').srcdoc = `
 &lt;!DOCTYPE html&gt;
 &lt;html lang="en" data-theme="dark"&gt;
 &lt;head&gt;
 &lt;base href="${location.origin}/"&gt;
 &lt;/head&gt;
 &lt;body class="content-component"&gt;
 &lt;div id="root" class="full-screen"&gt;&lt;/div&gt;
 \x3Cscript type="module"&gt;
 import { renderContentComponentByPath } from '/scripts/render-content-component.js';
 renderContentComponentByPath('root', '.\/posts\/wasi\/implementing-library-functions\/BezierNodesExampleScene.tsx');
 &lt;\/script&gt;
 &lt;/body&gt;
 &lt;/html&gt;
 `;
 &lt;/script&gt;
&lt;/div&gt;

&lt;p&gt;In this article, we&amp;rsquo;ll be exploring a more interesting example where
we&amp;rsquo;ll construct a Bézier curve, evaluate nodes on it, and write a
function that gives any position on the curve by a length parameter.
To explain briefly, a Bézier curve is represented by a parameter &lt;code&gt;t&lt;/code&gt;,
which varies between 0 and 1 and determines the position of nodes on
the curve. However, this &lt;code&gt;t&lt;/code&gt; value doesn&amp;rsquo;t produce uniform spacing,
which is problematic when we want to evaluate a point on the curve
based on its distance. To solve this, we can evaluate some nodes along
the curve with known distances and then linearly interpolate new nodes
between them to find the point we&amp;rsquo;re looking for.&lt;/p&gt;</description></item><item><title>CMake and build scripts</title><link>https://ercanakyuerek.de/posts/wasi/cmake-and-build-scripts/</link><pubDate>Thu, 23 Feb 2023 23:15:00 +0100</pubDate><guid>https://ercanakyuerek.de/posts/wasi/cmake-and-build-scripts/</guid><description>&lt;p&gt;To simplify the building process, we can create a build script. We
have already defined some scripts in our &lt;code&gt;package.json&lt;/code&gt; file. At this
point, the &lt;code&gt;build-wasm.js&lt;/code&gt; file is still empty, so we can create a
basic script that first deletes an existing &lt;code&gt;build&lt;/code&gt; folder, creates a
new one, and runs &lt;code&gt;cmake ..&lt;/code&gt; inside it. We will be using a WASI-SDK
docker image from &lt;code&gt;ghcr.io/webassembly/wasi-sdk&lt;/code&gt; to run cmake and
eventually compile the project via &lt;code&gt;make&lt;/code&gt;.&lt;/p&gt;</description></item><item><title>Folder structure</title><link>https://ercanakyuerek.de/posts/wasi/folder-structure/</link><pubDate>Thu, 23 Feb 2023 22:00:00 +0100</pubDate><guid>https://ercanakyuerek.de/posts/wasi/folder-structure/</guid><description>&lt;p&gt;You may have already heard that it&amp;rsquo;s possible to write certain parts
of your web application using languages like C++ or Rust and compile
them into WebAssembly. WebAssembly is a binary format that allows code
to be executed on the web and is designed to be efficient, secure, and
portable. There are use cases where WebAssembly can be particularly
beneficial, such as performing complex and resource-intensive
computations for real-time applications or mathematical operations.&lt;/p&gt;</description></item></channel></rss>