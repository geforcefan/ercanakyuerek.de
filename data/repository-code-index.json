{
  "src/helper/physics.ts": {
    "source": "import { Matrix4, Vector3 } from 'three';\n\nimport { toFrontDirection } from '../maths/matrix4';\n\nexport type SimulationState = {\n  velocity: number;\n  distanceTraveled: number;\n  acceleration: number;\n};\n\nexport const evaluateMotion = (\n  state: SimulationState,\n  transformation: Matrix4,\n  friction: number,\n  airResistance: number,\n  gravity: number,\n  deltaTime: number,\n): SimulationState => {\n  const forwardDirection = toFrontDirection(transformation);\n  const velocityDirection = state.velocity < 0 ? -1 : 1;\n\n  let energyLoss = airResistance * state.velocity * state.velocity;\n  energyLoss += friction * gravity;\n  energyLoss *= velocityDirection;\n\n  let acceleration = forwardDirection.dot(\n    new Vector3(0, -gravity, 0),\n  );\n  acceleration -= energyLoss;\n\n  const velocity = state.velocity + acceleration * deltaTime;\n  const distanceTraveled =\n    state.distanceTraveled + velocity * deltaTime;\n\n  return { velocity, distanceTraveled, acceleration };\n};\n",
    "functions": {},
    "types": {
      "SimulationState": "type SimulationState = {\n  velocity: number;\n  distanceTraveled: number;\n  acceleration: number;\n};"
    },
    "variables": {
      "evaluateMotion": "const evaluateMotion = (\n  state: SimulationState,\n  transformation: Matrix4,\n  friction: number,\n  airResistance: number,\n  gravity: number,\n  deltaTime: number,\n): SimulationState => {\n  const forwardDirection = toFrontDirection(transformation);\n  const velocityDirection = state.velocity < 0 ? -1 : 1;\n\n  let energyLoss = airResistance * state.velocity * state.velocity;\n  energyLoss += friction * gravity;\n  energyLoss *= velocityDirection;\n\n  let acceleration = forwardDirection.dot(\n    new Vector3(0, -gravity, 0),\n  );\n  acceleration -= energyLoss;\n\n  const velocity = state.velocity + acceleration * deltaTime;\n  const distanceTraveled =\n    state.distanceTraveled + velocity * deltaTime;\n\n  return { velocity, distanceTraveled, acceleration };\n};"
    }
  },
  "src/maths/curve.ts": {
    "source": "import last from 'lodash/last';\nimport { MathUtils, Matrix4, Vector3 } from 'three';\n\nimport { findBoundingIndices } from '../helper/binary-search';\nimport { uniformSample } from '../helper/uniform-sample';\n\nimport {\n  applyLookRelativeAt,\n  applyRoll,\n  distance,\n  lerp,\n  rollDirection,\n  toFrontDirection,\n  toPosition,\n} from './matrix4';\n\nexport type CurveNode = {\n  transformation: Matrix4;\n  arcLength: number;\n  segmentIndex: number;\n};\n\nexport type Curve = {\n  nodes: CurveNode[];\n  segmentOffsets: number[];\n};\n\nexport const totalArcLength = (curve: Curve) => {\n  return last(curve.nodes)?.arcLength ?? 0;\n};\n\nexport const transformationAtArcLength = (\n  curve: Curve,\n  at: number,\n) => {\n  const nodes = findBoundingIndices(\n    curve.nodes,\n    at,\n    (node) => node.arcLength,\n  );\n  if (!nodes) return new Matrix4();\n\n  const left = curve.nodes[nodes[0]];\n  const right = curve.nodes[nodes[1]];\n\n  const length = right.arcLength - left.arcLength;\n\n  if (length > Number.EPSILON) {\n    const t = MathUtils.clamp(\n      (at - left.arcLength) / length,\n      0.0,\n      1.0,\n    );\n    return lerp(left.transformation, right.transformation, t);\n  }\n\n  return left.transformation.clone();\n};\n\nexport const positionAtX = (curve: Curve, at: number) => {\n  const nodes = findBoundingIndices(\n    curve.nodes,\n    at,\n    (node) => toPosition(node.transformation).x,\n  );\n  if (!nodes) return new Vector3();\n\n  const left = toPosition(curve.nodes[nodes[0]].transformation);\n  const right = toPosition(curve.nodes[nodes[1]].transformation);\n\n  const length = right.x - left.x;\n\n  if (length > Number.EPSILON) {\n    return left.lerp(\n      right,\n      MathUtils.clamp((at - left.x) / length, 0.0, 1.0),\n    );\n  }\n\n  return left;\n};\n\nexport const arcLengthAtOffset = (\n  at: number,\n  segmentOffsets: number[],\n) => {\n  const i = Math.floor(at);\n  const t = at - i;\n\n  const left = segmentOffsets[i] ?? 0;\n  const right = segmentOffsets[i + 1] ?? left;\n\n  return MathUtils.lerp(left, right, t);\n};\n\nexport const insertTransformationMatrix = (\n  curve: Curve,\n  transformation: Matrix4,\n  segmentIndex: number = 0,\n) => {\n  const lastNode = last(curve.nodes);\n  const lastSegmentIndex = lastNode?.segmentIndex ?? 0;\n\n  let arcLength = 0;\n\n  if (lastNode) {\n    const distanceToLastNode = distance(\n      lastNode.transformation,\n      transformation,\n    );\n    if (distanceToLastNode < Number.EPSILON) return;\n\n    arcLength = lastNode.arcLength + distanceToLastNode;\n  }\n\n  const nodeTransformation = transformation.clone();\n\n  if (lastSegmentIndex !== segmentIndex)\n    curve.segmentOffsets[segmentIndex] = arcLength;\n  else curve.segmentOffsets[segmentIndex + 1] = arcLength;\n\n  curve.nodes.push({\n    arcLength,\n    transformation: nodeTransformation,\n    segmentIndex,\n  });\n};\n\nexport const insertPosition = (\n  curve: Curve,\n  position: Vector3,\n  segmentIndex: number = 0,\n) => {\n  const lastNode = last(curve.nodes);\n\n  if (lastNode) {\n    if (\n      position.distanceTo(toPosition(lastNode.transformation)) <\n      Number.EPSILON\n    )\n      return;\n\n    if (curve.nodes.length === 1) {\n      applyLookRelativeAt(lastNode.transformation, position);\n    }\n    applyLookRelativeAt(lastNode.transformation, position);\n\n    return insertTransformationMatrix(\n      curve,\n      lastNode.transformation.clone().setPosition(position),\n      segmentIndex,\n    );\n  }\n\n  return insertTransformationMatrix(\n    curve,\n    new Matrix4().setPosition(position),\n  );\n};\n\nexport const applyRollCurve = (curve: Curve, rollCurve: Curve) => {\n  curve.nodes.forEach(({ transformation, arcLength }) => {\n    applyRoll(transformation, -positionAtX(rollCurve, arcLength).y);\n  });\n\n  return curve;\n};\n\nexport const emptyCurve = (\n  nodes: CurveNode[] = [],\n  segmentOffsets: number[] = [0],\n): Curve => {\n  return {\n    nodes,\n    segmentOffsets,\n  };\n};\n\nexport const fromPoints = (points: Vector3[]) => {\n  const curve = emptyCurve();\n\n  points.forEach((point) => {\n    insertPosition(curve, point);\n  });\n\n  return curve;\n};\n\nexport const fromUniformSampledPositions = (\n  from: number = 0,\n  to: number = 0,\n  resolution: number = 20,\n  positionFn: (at: number, t: number) => Vector3,\n) => {\n  const curve = emptyCurve();\n\n  uniformSample(from, to, resolution, (at, t) => {\n    insertPosition(curve, positionFn(at, t));\n  });\n\n  return curve;\n};\n\nexport const toPoints = (curve: Curve) => {\n  return curve.nodes.map((node) => toPosition(node.transformation));\n};\n\nexport const toLocalTransformed = (\n  curve: Curve,\n  translation: Vector3,\n): Curve => {\n  const transformedCurve = emptyCurve();\n\n  curve.nodes.forEach((node) => {\n    insertPosition(\n      transformedCurve,\n      toPosition(\n        node.transformation\n          .clone()\n          .multiply(new Matrix4().makeTranslation(translation)),\n      ),\n      node.segmentIndex,\n    );\n  });\n\n  transformedCurve.nodes.forEach((node, index) => {\n    const position = toPosition(node.transformation);\n    const originalRollDirection = rollDirection(\n      curve.nodes[index].transformation,\n    );\n\n    const front = toFrontDirection(node.transformation);\n    const left = originalRollDirection\n      .sub(\n        front\n          .clone()\n          .multiplyScalar(originalRollDirection.dot(front)),\n      )\n      .normalize();\n\n    const up = new Vector3().crossVectors(front, left).normalize();\n\n    node.transformation = new Matrix4()\n      .makeBasis(left, up, front)\n      .setPosition(position);\n  });\n\n  return transformedCurve;\n};\n",
    "functions": {},
    "types": {
      "CurveNode": "type CurveNode = {\n  transformation: Matrix4;\n  arcLength: number;\n  segmentIndex: number;\n};",
      "Curve": "type Curve = {\n  nodes: CurveNode[];\n  segmentOffsets: number[];\n};"
    },
    "variables": {
      "totalArcLength": "const totalArcLength = (curve: Curve) => {\n  return last(curve.nodes)?.arcLength ?? 0;\n};",
      "transformationAtArcLength": "const transformationAtArcLength = (\n  curve: Curve,\n  at: number,\n) => {\n  const nodes = findBoundingIndices(\n    curve.nodes,\n    at,\n    (node) => node.arcLength,\n  );\n  if (!nodes) return new Matrix4();\n\n  const left = curve.nodes[nodes[0]];\n  const right = curve.nodes[nodes[1]];\n\n  const length = right.arcLength - left.arcLength;\n\n  if (length > Number.EPSILON) {\n    const t = MathUtils.clamp(\n      (at - left.arcLength) / length,\n      0.0,\n      1.0,\n    );\n    return lerp(left.transformation, right.transformation, t);\n  }\n\n  return left.transformation.clone();\n};",
      "positionAtX": "const positionAtX = (curve: Curve, at: number) => {\n  const nodes = findBoundingIndices(\n    curve.nodes,\n    at,\n    (node) => toPosition(node.transformation).x,\n  );\n  if (!nodes) return new Vector3();\n\n  const left = toPosition(curve.nodes[nodes[0]].transformation);\n  const right = toPosition(curve.nodes[nodes[1]].transformation);\n\n  const length = right.x - left.x;\n\n  if (length > Number.EPSILON) {\n    return left.lerp(\n      right,\n      MathUtils.clamp((at - left.x) / length, 0.0, 1.0),\n    );\n  }\n\n  return left;\n};",
      "arcLengthAtOffset": "const arcLengthAtOffset = (\n  at: number,\n  segmentOffsets: number[],\n) => {\n  const i = Math.floor(at);\n  const t = at - i;\n\n  const left = segmentOffsets[i] ?? 0;\n  const right = segmentOffsets[i + 1] ?? left;\n\n  return MathUtils.lerp(left, right, t);\n};",
      "insertTransformationMatrix": "const insertTransformationMatrix = (\n  curve: Curve,\n  transformation: Matrix4,\n  segmentIndex: number = 0,\n) => {\n  const lastNode = last(curve.nodes);\n  const lastSegmentIndex = lastNode?.segmentIndex ?? 0;\n\n  let arcLength = 0;\n\n  if (lastNode) {\n    const distanceToLastNode = distance(\n      lastNode.transformation,\n      transformation,\n    );\n    if (distanceToLastNode < Number.EPSILON) return;\n\n    arcLength = lastNode.arcLength + distanceToLastNode;\n  }\n\n  const nodeTransformation = transformation.clone();\n\n  if (lastSegmentIndex !== segmentIndex)\n    curve.segmentOffsets[segmentIndex] = arcLength;\n  else curve.segmentOffsets[segmentIndex + 1] = arcLength;\n\n  curve.nodes.push({\n    arcLength,\n    transformation: nodeTransformation,\n    segmentIndex,\n  });\n};",
      "insertPosition": "const insertPosition = (\n  curve: Curve,\n  position: Vector3,\n  segmentIndex: number = 0,\n) => {\n  const lastNode = last(curve.nodes);\n\n  if (lastNode) {\n    if (\n      position.distanceTo(toPosition(lastNode.transformation)) <\n      Number.EPSILON\n    )\n      return;\n\n    if (curve.nodes.length === 1) {\n      applyLookRelativeAt(lastNode.transformation, position);\n    }\n    applyLookRelativeAt(lastNode.transformation, position);\n\n    return insertTransformationMatrix(\n      curve,\n      lastNode.transformation.clone().setPosition(position),\n      segmentIndex,\n    );\n  }\n\n  return insertTransformationMatrix(\n    curve,\n    new Matrix4().setPosition(position),\n  );\n};",
      "applyRollCurve": "const applyRollCurve = (curve: Curve, rollCurve: Curve) => {\n  curve.nodes.forEach(({ transformation, arcLength }) => {\n    applyRoll(transformation, -positionAtX(rollCurve, arcLength).y);\n  });\n\n  return curve;\n};",
      "emptyCurve": "const emptyCurve = (\n  nodes: CurveNode[] = [],\n  segmentOffsets: number[] = [0],\n): Curve => {\n  return {\n    nodes,\n    segmentOffsets,\n  };\n};",
      "fromPoints": "const fromPoints = (points: Vector3[]) => {\n  const curve = emptyCurve();\n\n  points.forEach((point) => {\n    insertPosition(curve, point);\n  });\n\n  return curve;\n};",
      "fromUniformSampledPositions": "const fromUniformSampledPositions = (\n  from: number = 0,\n  to: number = 0,\n  resolution: number = 20,\n  positionFn: (at: number, t: number) => Vector3,\n) => {\n  const curve = emptyCurve();\n\n  uniformSample(from, to, resolution, (at, t) => {\n    insertPosition(curve, positionFn(at, t));\n  });\n\n  return curve;\n};",
      "toPoints": "const toPoints = (curve: Curve) => {\n  return curve.nodes.map((node) => toPosition(node.transformation));\n};",
      "toLocalTransformed": "const toLocalTransformed = (\n  curve: Curve,\n  translation: Vector3,\n): Curve => {\n  const transformedCurve = emptyCurve();\n\n  curve.nodes.forEach((node) => {\n    insertPosition(\n      transformedCurve,\n      toPosition(\n        node.transformation\n          .clone()\n          .multiply(new Matrix4().makeTranslation(translation)),\n      ),\n      node.segmentIndex,\n    );\n  });\n\n  transformedCurve.nodes.forEach((node, index) => {\n    const position = toPosition(node.transformation);\n    const originalRollDirection = rollDirection(\n      curve.nodes[index].transformation,\n    );\n\n    const front = toFrontDirection(node.transformation);\n    const left = originalRollDirection\n      .sub(\n        front\n          .clone()\n          .multiplyScalar(originalRollDirection.dot(front)),\n      )\n      .normalize();\n\n    const up = new Vector3().crossVectors(front, left).normalize();\n\n    node.transformation = new Matrix4()\n      .makeBasis(left, up, front)\n      .setPosition(position);\n  });\n\n  return transformedCurve;\n};"
    }
  },
  "src/components/curve/ControlPoint.tsx": {
    "source": "import React from 'react';\nimport { ThreeElements } from '@react-three/fiber';\n\nimport { useColors } from '../../hooks/useColors';\n\ntype Size = 'sm' | 'md';\n\nconst sizes: Record<Size, number> = {\n  sm: 0.1,\n  md: 0.2,\n};\n\nexport const ControlPoint = (\n  props: { size?: Size; color?: number } & ThreeElements['mesh'],\n) => {\n  const { size = 'md', color = undefined, ...restProps } = props;\n\n  const colors = useColors();\n\n  return (\n    <mesh {...restProps}>\n      <sphereGeometry args={[sizes[size], 6, 6]} />\n      <meshBasicMaterial color={color || colors.secondary} />\n    </mesh>\n  );\n};\n",
    "functions": {},
    "types": {
      "Size": "type Size = 'sm' | 'md';"
    },
    "variables": {
      "sizes": "const sizes: Record<Size, number> = {\n  sm: 0.1,\n  md: 0.2,\n};",
      "ControlPoint": "const ControlPoint = (\n  props: { size?: Size; color?: number } & ThreeElements['mesh'],\n) => {\n  const { size = 'md', color = undefined, ...restProps } = props;\n\n  const colors = useColors();\n\n  return (\n    <mesh {...restProps}>\n      <sphereGeometry args={[sizes[size], 6, 6]} />\n      <meshBasicMaterial color={color || colors.secondary} />\n    </mesh>\n  );\n};"
    }
  },
  "src/helper/nl2park/info.ts": {
    "source": "import {\n  NoLimitsStream,\n  readBoolean,\n  readFloat,\n  readFloatVector2,\n  readFloatVector3,\n  readIntegerVector2,\n  readNull,\n  readString,\n  readUnsigned8,\n  writeBoolean,\n  writeFloat,\n  writeFloatVector2,\n  writeFloatVector3,\n  writeIntegerVector2,\n  writeNull,\n  writeString,\n  writeUnsigned8,\n} from './nolimits-stream';\n\nexport enum RideView {\n  ClosestCoasterFirstTrain = 0,\n  ClosestCoasterClosestTrain = 1,\n  FlyView = 2,\n  WalkView = 3,\n}\n\nexport type Info = ReturnType<typeof readInfo>;\n\nexport const readInfo = (stream: NoLimitsStream) => {\n  const version = {\n    major: readUnsigned8(stream),\n    minor: readUnsigned8(stream),\n    revision: readUnsigned8(stream),\n    build: readUnsigned8(stream),\n  };\n\n  readNull(stream, 27);\n\n  const weather = {\n    overwriteDefaultWeather: readBoolean(stream),\n    rainIntensity: readFloat(stream),\n    snowIntensity: readFloat(stream),\n    windIntensity: readFloat(stream),\n    fogIntensity: readFloat(stream),\n    cloudsIntensity: readFloat(stream),\n    overcastIntensity: readFloat(stream),\n    thunderIntensity: readFloat(stream),\n  };\n\n  readNull(stream, 6);\n\n  const author = readString(stream);\n  const description = readString(stream);\n  const preview = readString(stream);\n  const environment = readString(stream);\n\n  readNull(stream, 10);\n\n  const sky = {\n    overrideDefaultDateTime: readBoolean(stream),\n    currentDate: readIntegerVector2(stream),\n    currentTime: readIntegerVector2(stream),\n  };\n\n  const initial = {\n    initialPositionAndRotationEnabled: readBoolean(stream),\n    initialPosition: readFloatVector3(stream),\n    initialRotation: readFloatVector2(stream),\n    initialView: readUnsigned8(stream) as RideView,\n  };\n\n  readNull(stream, 21);\n\n  return {\n    version,\n    weather,\n    sky,\n    initial,\n\n    author,\n    description,\n    preview,\n    environment,\n  };\n};\n\nexport const writeInfo = (\n  stream: NoLimitsStream,\n  info: Info,\n): void => {\n  writeUnsigned8(stream, info.version.major);\n  writeUnsigned8(stream, info.version.minor);\n  writeUnsigned8(stream, info.version.revision);\n  writeUnsigned8(stream, info.version.build);\n\n  writeNull(stream, 27);\n\n  writeBoolean(stream, info.weather.overwriteDefaultWeather);\n  writeFloat(stream, info.weather.rainIntensity);\n  writeFloat(stream, info.weather.snowIntensity);\n  writeFloat(stream, info.weather.windIntensity);\n  writeFloat(stream, info.weather.fogIntensity);\n  writeFloat(stream, info.weather.cloudsIntensity);\n  writeFloat(stream, info.weather.overcastIntensity);\n  writeFloat(stream, info.weather.thunderIntensity);\n\n  writeNull(stream, 6);\n\n  writeString(stream, info.author);\n  writeString(stream, info.description);\n  writeString(stream, info.preview);\n  writeString(stream, info.environment);\n\n  writeNull(stream, 10);\n\n  writeBoolean(stream, info.sky.overrideDefaultDateTime);\n  writeIntegerVector2(stream, info.sky.currentDate);\n  writeIntegerVector2(stream, info.sky.currentTime);\n\n  writeBoolean(\n    stream,\n    info.initial.initialPositionAndRotationEnabled,\n  );\n  writeFloatVector3(stream, info.initial.initialPosition);\n  writeFloatVector2(stream, info.initial.initialRotation);\n  writeUnsigned8(stream, info.initial.initialView);\n\n  writeNull(stream, 21);\n};\n",
    "functions": {},
    "types": {
      "Info": "type Info = ReturnType<typeof readInfo>;"
    },
    "variables": {
      "readInfo": "const readInfo = (stream: NoLimitsStream) => {\n  const version = {\n    major: readUnsigned8(stream),\n    minor: readUnsigned8(stream),\n    revision: readUnsigned8(stream),\n    build: readUnsigned8(stream),\n  };\n\n  readNull(stream, 27);\n\n  const weather = {\n    overwriteDefaultWeather: readBoolean(stream),\n    rainIntensity: readFloat(stream),\n    snowIntensity: readFloat(stream),\n    windIntensity: readFloat(stream),\n    fogIntensity: readFloat(stream),\n    cloudsIntensity: readFloat(stream),\n    overcastIntensity: readFloat(stream),\n    thunderIntensity: readFloat(stream),\n  };\n\n  readNull(stream, 6);\n\n  const author = readString(stream);\n  const description = readString(stream);\n  const preview = readString(stream);\n  const environment = readString(stream);\n\n  readNull(stream, 10);\n\n  const sky = {\n    overrideDefaultDateTime: readBoolean(stream),\n    currentDate: readIntegerVector2(stream),\n    currentTime: readIntegerVector2(stream),\n  };\n\n  const initial = {\n    initialPositionAndRotationEnabled: readBoolean(stream),\n    initialPosition: readFloatVector3(stream),\n    initialRotation: readFloatVector2(stream),\n    initialView: readUnsigned8(stream) as RideView,\n  };\n\n  readNull(stream, 21);\n\n  return {\n    version,\n    weather,\n    sky,\n    initial,\n\n    author,\n    description,\n    preview,\n    environment,\n  };\n};",
      "writeInfo": "const writeInfo = (\n  stream: NoLimitsStream,\n  info: Info,\n): void => {\n  writeUnsigned8(stream, info.version.major);\n  writeUnsigned8(stream, info.version.minor);\n  writeUnsigned8(stream, info.version.revision);\n  writeUnsigned8(stream, info.version.build);\n\n  writeNull(stream, 27);\n\n  writeBoolean(stream, info.weather.overwriteDefaultWeather);\n  writeFloat(stream, info.weather.rainIntensity);\n  writeFloat(stream, info.weather.snowIntensity);\n  writeFloat(stream, info.weather.windIntensity);\n  writeFloat(stream, info.weather.fogIntensity);\n  writeFloat(stream, info.weather.cloudsIntensity);\n  writeFloat(stream, info.weather.overcastIntensity);\n  writeFloat(stream, info.weather.thunderIntensity);\n\n  writeNull(stream, 6);\n\n  writeString(stream, info.author);\n  writeString(stream, info.description);\n  writeString(stream, info.preview);\n  writeString(stream, info.environment);\n\n  writeNull(stream, 10);\n\n  writeBoolean(stream, info.sky.overrideDefaultDateTime);\n  writeIntegerVector2(stream, info.sky.currentDate);\n  writeIntegerVector2(stream, info.sky.currentTime);\n\n  writeBoolean(\n    stream,\n    info.initial.initialPositionAndRotationEnabled,\n  );\n  writeFloatVector3(stream, info.initial.initialPosition);\n  writeFloatVector2(stream, info.initial.initialRotation);\n  writeUnsigned8(stream, info.initial.initialView);\n\n  writeNull(stream, 21);\n};"
    }
  },
  "src/helper/nl2park/nl2park.ts": {
    "source": "import {\n  Coaster,\n  readCoaster,\n  writeCoaster,\n} from './coaster/coaster';\nimport { Info, readInfo, writeInfo } from './info';\nimport {\n  makeChunkReader,\n  NoLimitsStream,\n  fromArrayBuffer as noLimitsStreamFromArrayBuffer,\n  toArrayBuffer as noLimitsStreamToArrayBuffer,\n  readChunks,\n  writeChunk,\n} from './nolimits-stream';\n\nexport type NoLimitsPark = ReturnType<typeof readPark>;\n\nexport const fromURL = async (url: string) => {\n  const content = await fetch(url);\n  return fromArrayBuffer(await content.arrayBuffer());\n};\n\nexport const fromArrayBuffer = (content: ArrayBuffer) => {\n  return readPark(noLimitsStreamFromArrayBuffer(content));\n};\n\nexport const toArrayBuffer = (park: NoLimitsPark) => {\n  const stream = noLimitsStreamFromArrayBuffer(new ArrayBuffer(0));\n  writePark(stream, park);\n  return noLimitsStreamToArrayBuffer(stream);\n};\n\nexport const readPark = (stream: NoLimitsStream) => {\n  const coaster: Coaster[] = [];\n  let info: Info | undefined;\n\n  readChunks(\n    [\n      makeChunkReader(readInfo, 'INFO', (i) => {\n        info = i;\n      }),\n      makeChunkReader(readCoaster, 'COAS', (c) => {\n        coaster.push(c);\n      }),\n    ],\n    stream,\n  );\n\n  return {\n    info,\n    coaster,\n  };\n};\n\nexport const writePark = (\n  stream: NoLimitsStream,\n  park: NoLimitsPark,\n) => {\n  writeChunk(stream, 'INFO', (s) => {\n    if (!park.info) return;\n    writeInfo(s, park.info);\n  });\n\n  for (const c of park.coaster) {\n    writeChunk(stream, 'COAS', (s) => writeCoaster(s, c));\n  }\n};\n",
    "functions": {},
    "types": {
      "NoLimitsPark": "type NoLimitsPark = ReturnType<typeof readPark>;"
    },
    "variables": {
      "fromURL": "const fromURL = async (url: string) => {\n  const content = await fetch(url);\n  return fromArrayBuffer(await content.arrayBuffer());\n};",
      "fromArrayBuffer": "const fromArrayBuffer = (content: ArrayBuffer) => {\n  return readPark(noLimitsStreamFromArrayBuffer(content));\n};",
      "toArrayBuffer": "const toArrayBuffer = (park: NoLimitsPark) => {\n  const stream = noLimitsStreamFromArrayBuffer(new ArrayBuffer(0));\n  writePark(stream, park);\n  return noLimitsStreamToArrayBuffer(stream);\n};",
      "readPark": "const readPark = (stream: NoLimitsStream) => {\n  const coaster: Coaster[] = [];\n  let info: Info | undefined;\n\n  readChunks(\n    [\n      makeChunkReader(readInfo, 'INFO', (i) => {\n        info = i;\n      }),\n      makeChunkReader(readCoaster, 'COAS', (c) => {\n        coaster.push(c);\n      }),\n    ],\n    stream,\n  );\n\n  return {\n    info,\n    coaster,\n  };\n};",
      "writePark": "const writePark = (\n  stream: NoLimitsStream,\n  park: NoLimitsPark,\n) => {\n  writeChunk(stream, 'INFO', (s) => {\n    if (!park.info) return;\n    writeInfo(s, park.info);\n  });\n\n  for (const c of park.coaster) {\n    writeChunk(stream, 'COAS', (s) => writeCoaster(s, c));\n  }\n};"
    }
  },
  "src/helper/nl2park/nolimits-stream.ts": {
    "source": "export type NoLimitsStream = {\n  content: Uint8Array;\n  position: number;\n};\n\nexport const fromArrayBuffer = (\n  content: ArrayBuffer,\n  position: number = 0,\n) => fromUint8Array(new Uint8Array(content), position);\n\nexport const fromUint8Array = (\n  content: Uint8Array,\n  position: number = 0,\n) => ({\n  content,\n  position,\n});\n\nexport const toArrayBuffer = (stream: NoLimitsStream) =>\n  stream.content.buffer.slice(\n    stream.content.byteOffset,\n    stream.content.byteOffset + stream.content.byteLength,\n  );\n\nexport const fromChunk = (stream: NoLimitsStream) => {\n  const size = readInteger(stream);\n  const start = stream.position;\n  const end = start + size;\n  const chunk = fromUint8Array(stream.content.slice(start, end));\n\n  stream.position = end;\n  return chunk;\n};\n\nexport const readChunkName = (stream: NoLimitsStream) => {\n  const start = stream.position;\n  const slice = stream.content.slice(start, start + 4);\n\n  stream.position += 4;\n  return String.fromCharCode(...slice);\n};\n\nexport const makeChunkReader = <Name extends string, T>(\n  reader: (stream: NoLimitsStream) => T,\n  chunkName: Name,\n  handler: (result: T) => void,\n) => ({\n  reader: Object.assign(reader, { chunkName }),\n  handler,\n});\n\nexport const readChunks = (\n  readers: readonly {\n    reader: ((stream: NoLimitsStream) => any) & { chunkName: string };\n    handler: (result: any) => void;\n  }[],\n  baseStream: NoLimitsStream,\n) => {\n  for (let i = 0; i <= baseStream.content.length; i++) {\n    baseStream.position = i;\n\n    const name = readChunkName(baseStream).trim();\n    const reader = readers.find((e) => e.reader.chunkName === name);\n\n    if (reader) {\n      reader.handler(reader.reader(fromChunk(baseStream)));\n      i = baseStream.position - 1;\n    }\n  }\n};\n\nexport const readInteger = (stream: NoLimitsStream) => {\n  const dv = new DataView(\n    stream.content.buffer,\n    stream.content.byteOffset + stream.position,\n    4,\n  );\n\n  const value = dv.getInt32(0);\n  stream.position += 4;\n  return value;\n};\n\nexport const readUnsignedInteger = (stream: NoLimitsStream) => {\n  const dv = new DataView(\n    stream.content.buffer,\n    stream.content.byteOffset + stream.position,\n    4,\n  );\n\n  const value = dv.getUint32(0);\n  stream.position += 4;\n  return value;\n};\n\nexport const readFloat = (stream: NoLimitsStream) => {\n  const dv = new DataView(\n    stream.content.buffer,\n    stream.content.byteOffset + stream.position,\n    4,\n  );\n\n  const value = dv.getFloat32(0);\n  stream.position += 4;\n  return value;\n};\n\nexport const readDouble = (stream: NoLimitsStream) => {\n  const dv = new DataView(\n    stream.content.buffer,\n    stream.content.byteOffset + stream.position,\n    8,\n  );\n\n  const value = dv.getFloat64(0);\n  stream.position += 8;\n  return value;\n};\n\nexport const readUnsigned8 = (stream: NoLimitsStream) => {\n  const value = stream.content[stream.position];\n  stream.position += 1;\n  return value;\n};\n\nexport const readBoolean = (stream: NoLimitsStream) =>\n  !!readUnsigned8(stream);\n\nexport const readIntegerVector2 = (\n  stream: NoLimitsStream,\n): [number, number] => [readInteger(stream), readInteger(stream)];\n\nexport const readUnsigned8Vector2 = (\n  stream: NoLimitsStream,\n): [number, number] => [readUnsigned8(stream), readUnsigned8(stream)];\n\nexport const readUnsigned8Vector3 = (\n  stream: NoLimitsStream,\n): [number, number, number] => [\n  readUnsigned8(stream),\n  readUnsigned8(stream),\n  readUnsigned8(stream),\n];\n\nexport const readFloatVector2 = (\n  stream: NoLimitsStream,\n): [number, number] => [readFloat(stream), readFloat(stream)];\n\nexport const readFloatVector3 = (\n  stream: NoLimitsStream,\n): [number, number, number] => [\n  readFloat(stream),\n  readFloat(stream),\n  readFloat(stream),\n];\n\nexport const readDoubleVector2 = (\n  stream: NoLimitsStream,\n): [number, number] => [readDouble(stream), readDouble(stream)];\n\nexport const readDoubleVector3 = (\n  stream: NoLimitsStream,\n): [number, number, number] => [\n  readDouble(stream),\n  readDouble(stream),\n  readDouble(stream),\n];\n\nexport const readDoubleVector4 = (\n  stream: NoLimitsStream,\n): [number, number, number, number] => [\n  readDouble(stream),\n  readDouble(stream),\n  readDouble(stream),\n  readDouble(stream),\n];\n\nexport const readColor = (stream: NoLimitsStream) =>\n  readUnsigned8Vector3(stream);\n\nexport const readNull = (\n  stream: NoLimitsStream,\n  byteCount: number,\n) => {\n  stream.position += byteCount;\n};\n\nexport const readString = (stream: NoLimitsStream) => {\n  let result = '';\n\n  while (true) {\n    const charCode = stream.content[stream.position + 1];\n    stream.position += 2;\n\n    if (charCode === 0) break;\n    result += String.fromCharCode(charCode);\n  }\n\n  return result;\n};\n\nexport const writeDouble = (\n  stream: NoLimitsStream,\n  value: number,\n) => {\n  const buffer = new ArrayBuffer(8);\n  new DataView(buffer).setFloat64(0, value);\n  write(stream, buffer);\n};\n\nexport const writeFloat = (stream: NoLimitsStream, value: number) => {\n  const buffer = new ArrayBuffer(8);\n  new DataView(buffer).setFloat32(0, value);\n  write(stream, buffer);\n};\n\nexport const writeUnsignedInteger = (\n  stream: NoLimitsStream,\n  value: number,\n) => {\n  const buffer = new ArrayBuffer(4);\n  new DataView(buffer).setUint32(0, value);\n  write(stream, buffer);\n};\n\nexport const writeInteger = (\n  stream: NoLimitsStream,\n  value: number,\n) => {\n  const buffer = new ArrayBuffer(4);\n  new DataView(buffer).setInt32(0, value);\n  write(stream, buffer);\n};\n\nexport const writeBoolean = (\n  stream: NoLimitsStream,\n  value: boolean,\n) => {\n  const buffer = new ArrayBuffer(1);\n  new Uint8Array(buffer)[0] = value ? 1 : 0;\n  write(stream, buffer);\n};\n\nexport const write = (\n  stream: NoLimitsStream,\n  buffer: ArrayBuffer,\n) => {\n  const bytes = new Uint8Array(buffer);\n  const next = new Uint8Array(stream.content.length + bytes.length);\n\n  next.set(stream.content, 0);\n  next.set(bytes, stream.content.length);\n\n  stream.content = next;\n  stream.position += bytes.length;\n};\n\nexport const writeDoubleVector4 = (\n  stream: NoLimitsStream,\n  value: [number, number, number, number],\n) => {\n  writeDouble(stream, value[0]);\n  writeDouble(stream, value[1]);\n  writeDouble(stream, value[2]);\n  writeDouble(stream, value[3]);\n};\n\nexport const writeIntegerVector2 = (\n  stream: NoLimitsStream,\n  value: [number, number],\n) => {\n  writeInteger(stream, value[0]);\n  writeInteger(stream, value[1]);\n};\n\nexport const writeFloatVector2 = (\n  stream: NoLimitsStream,\n  value: [number, number],\n) => {\n  writeFloat(stream, value[0]);\n  writeFloat(stream, value[1]);\n};\n\nexport const writeFloatVector3 = (\n  stream: NoLimitsStream,\n  value: [number, number, number],\n) => {\n  writeFloat(stream, value[0]);\n  writeFloat(stream, value[1]);\n  writeFloat(stream, value[2]);\n};\n\nexport const writeDoubleVector3 = (\n  stream: NoLimitsStream,\n  value: [number, number, number],\n) => {\n  writeDouble(stream, value[0]);\n  writeDouble(stream, value[1]);\n  writeDouble(stream, value[2]);\n};\n\nexport const writeDoubleVector2 = (\n  stream: NoLimitsStream,\n  value: [number, number],\n) => {\n  writeDouble(stream, value[0]);\n  writeDouble(stream, value[1]);\n};\n\nexport const writeNull = (\n  stream: NoLimitsStream,\n  byteCount: number,\n) => {\n  write(stream, new ArrayBuffer(byteCount));\n};\n\nexport const writeUnsigned8 = (\n  stream: NoLimitsStream,\n  value: number,\n) => {\n  const buffer = new ArrayBuffer(1);\n  new Uint8Array(buffer)[0] = value & 0xff;\n  write(stream, buffer);\n};\n\nexport const writeString = (\n  stream: NoLimitsStream,\n  value: string,\n) => {\n  for (let i = 0; i < value.length; i++) {\n    writeNull(stream, 1);\n    writeUnsigned8(stream, value.charCodeAt(i));\n  }\n\n  writeNull(stream, 2);\n};\n\nexport const writeUnsigned8Vector3 = (\n  stream: NoLimitsStream,\n  value: [number, number, number],\n) => {\n  writeUnsigned8(stream, value[0]);\n  writeUnsigned8(stream, value[1]);\n  writeUnsigned8(stream, value[2]);\n};\n\nexport const writeColor = (\n  stream: NoLimitsStream,\n  color: [number, number, number],\n) => {\n  writeUnsigned8Vector3(stream, color);\n};\n\nexport const writeChunkName = (\n  stream: NoLimitsStream,\n  name: string,\n) => {\n  for (let i = 0; i < 4; i++) {\n    writeUnsigned8(stream, name.charCodeAt(i) ?? 0);\n  }\n};\n\nexport const writeChunk = (\n  stream: NoLimitsStream,\n  chunkName: string,\n  handler: (stream: NoLimitsStream) => void,\n) => {\n  const chunkStream = fromArrayBuffer(new ArrayBuffer(0));\n  handler(chunkStream);\n\n  if (!chunkStream.content.length) return;\n\n  writeUnsignedInteger(stream, chunkStream.content.length);\n  writeChunkName(stream, chunkName);\n  write(stream, chunkStream.content);\n};\n",
    "functions": {},
    "types": {
      "NoLimitsStream": "type NoLimitsStream = {\n  content: Uint8Array;\n  position: number;\n};"
    },
    "variables": {
      "fromArrayBuffer": "const fromArrayBuffer = (\n  content: ArrayBuffer,\n  position: number = 0,\n) => fromUint8Array(new Uint8Array(content), position);",
      "fromUint8Array": "const fromUint8Array = (\n  content: Uint8Array,\n  position: number = 0,\n) => ({\n  content,\n  position,\n});",
      "toArrayBuffer": "const toArrayBuffer = (stream: NoLimitsStream) =>\n  stream.content.buffer.slice(\n    stream.content.byteOffset,\n    stream.content.byteOffset + stream.content.byteLength,\n  );",
      "fromChunk": "const fromChunk = (stream: NoLimitsStream) => {\n  const size = readInteger(stream);\n  const start = stream.position;\n  const end = start + size;\n  const chunk = fromUint8Array(stream.content.slice(start, end));\n\n  stream.position = end;\n  return chunk;\n};",
      "readChunkName": "const readChunkName = (stream: NoLimitsStream) => {\n  const start = stream.position;\n  const slice = stream.content.slice(start, start + 4);\n\n  stream.position += 4;\n  return String.fromCharCode(...slice);\n};",
      "makeChunkReader": "const makeChunkReader = <Name extends string, T>(\n  reader: (stream: NoLimitsStream) => T,\n  chunkName: Name,\n  handler: (result: T) => void,\n) => ({\n  reader: Object.assign(reader, { chunkName }),\n  handler,\n});",
      "readChunks": "const readChunks = (\n  readers: readonly {\n    reader: ((stream: NoLimitsStream) => any) & { chunkName: string };\n    handler: (result: any) => void;\n  }[],\n  baseStream: NoLimitsStream,\n) => {\n  for (let i = 0; i <= baseStream.content.length; i++) {\n    baseStream.position = i;\n\n    const name = readChunkName(baseStream).trim();\n    const reader = readers.find((e) => e.reader.chunkName === name);\n\n    if (reader) {\n      reader.handler(reader.reader(fromChunk(baseStream)));\n      i = baseStream.position - 1;\n    }\n  }\n};",
      "readInteger": "const readInteger = (stream: NoLimitsStream) => {\n  const dv = new DataView(\n    stream.content.buffer,\n    stream.content.byteOffset + stream.position,\n    4,\n  );\n\n  const value = dv.getInt32(0);\n  stream.position += 4;\n  return value;\n};",
      "readUnsignedInteger": "const readUnsignedInteger = (stream: NoLimitsStream) => {\n  const dv = new DataView(\n    stream.content.buffer,\n    stream.content.byteOffset + stream.position,\n    4,\n  );\n\n  const value = dv.getUint32(0);\n  stream.position += 4;\n  return value;\n};",
      "readFloat": "const readFloat = (stream: NoLimitsStream) => {\n  const dv = new DataView(\n    stream.content.buffer,\n    stream.content.byteOffset + stream.position,\n    4,\n  );\n\n  const value = dv.getFloat32(0);\n  stream.position += 4;\n  return value;\n};",
      "readDouble": "const readDouble = (stream: NoLimitsStream) => {\n  const dv = new DataView(\n    stream.content.buffer,\n    stream.content.byteOffset + stream.position,\n    8,\n  );\n\n  const value = dv.getFloat64(0);\n  stream.position += 8;\n  return value;\n};",
      "readUnsigned8": "const readUnsigned8 = (stream: NoLimitsStream) => {\n  const value = stream.content[stream.position];\n  stream.position += 1;\n  return value;\n};",
      "readBoolean": "const readBoolean = (stream: NoLimitsStream) =>\n  !!readUnsigned8(stream);",
      "readIntegerVector2": "const readIntegerVector2 = (\n  stream: NoLimitsStream,\n): [number, number] => [readInteger(stream), readInteger(stream)];",
      "readUnsigned8Vector2": "const readUnsigned8Vector2 = (\n  stream: NoLimitsStream,\n): [number, number] => [readUnsigned8(stream), readUnsigned8(stream)];",
      "readUnsigned8Vector3": "const readUnsigned8Vector3 = (\n  stream: NoLimitsStream,\n): [number, number, number] => [\n  readUnsigned8(stream),\n  readUnsigned8(stream),\n  readUnsigned8(stream),\n];",
      "readFloatVector2": "const readFloatVector2 = (\n  stream: NoLimitsStream,\n): [number, number] => [readFloat(stream), readFloat(stream)];",
      "readFloatVector3": "const readFloatVector3 = (\n  stream: NoLimitsStream,\n): [number, number, number] => [\n  readFloat(stream),\n  readFloat(stream),\n  readFloat(stream),\n];",
      "readDoubleVector2": "const readDoubleVector2 = (\n  stream: NoLimitsStream,\n): [number, number] => [readDouble(stream), readDouble(stream)];",
      "readDoubleVector3": "const readDoubleVector3 = (\n  stream: NoLimitsStream,\n): [number, number, number] => [\n  readDouble(stream),\n  readDouble(stream),\n  readDouble(stream),\n];",
      "readDoubleVector4": "const readDoubleVector4 = (\n  stream: NoLimitsStream,\n): [number, number, number, number] => [\n  readDouble(stream),\n  readDouble(stream),\n  readDouble(stream),\n  readDouble(stream),\n];",
      "readColor": "const readColor = (stream: NoLimitsStream) =>\n  readUnsigned8Vector3(stream);",
      "readNull": "const readNull = (\n  stream: NoLimitsStream,\n  byteCount: number,\n) => {\n  stream.position += byteCount;\n};",
      "readString": "const readString = (stream: NoLimitsStream) => {\n  let result = '';\n\n  while (true) {\n    const charCode = stream.content[stream.position + 1];\n    stream.position += 2;\n\n    if (charCode === 0) break;\n    result += String.fromCharCode(charCode);\n  }\n\n  return result;\n};",
      "writeDouble": "const writeDouble = (\n  stream: NoLimitsStream,\n  value: number,\n) => {\n  const buffer = new ArrayBuffer(8);\n  new DataView(buffer).setFloat64(0, value);\n  write(stream, buffer);\n};",
      "writeFloat": "const writeFloat = (stream: NoLimitsStream, value: number) => {\n  const buffer = new ArrayBuffer(8);\n  new DataView(buffer).setFloat32(0, value);\n  write(stream, buffer);\n};",
      "writeUnsignedInteger": "const writeUnsignedInteger = (\n  stream: NoLimitsStream,\n  value: number,\n) => {\n  const buffer = new ArrayBuffer(4);\n  new DataView(buffer).setUint32(0, value);\n  write(stream, buffer);\n};",
      "writeInteger": "const writeInteger = (\n  stream: NoLimitsStream,\n  value: number,\n) => {\n  const buffer = new ArrayBuffer(4);\n  new DataView(buffer).setInt32(0, value);\n  write(stream, buffer);\n};",
      "writeBoolean": "const writeBoolean = (\n  stream: NoLimitsStream,\n  value: boolean,\n) => {\n  const buffer = new ArrayBuffer(1);\n  new Uint8Array(buffer)[0] = value ? 1 : 0;\n  write(stream, buffer);\n};",
      "write": "const write = (\n  stream: NoLimitsStream,\n  buffer: ArrayBuffer,\n) => {\n  const bytes = new Uint8Array(buffer);\n  const next = new Uint8Array(stream.content.length + bytes.length);\n\n  next.set(stream.content, 0);\n  next.set(bytes, stream.content.length);\n\n  stream.content = next;\n  stream.position += bytes.length;\n};",
      "writeDoubleVector4": "const writeDoubleVector4 = (\n  stream: NoLimitsStream,\n  value: [number, number, number, number],\n) => {\n  writeDouble(stream, value[0]);\n  writeDouble(stream, value[1]);\n  writeDouble(stream, value[2]);\n  writeDouble(stream, value[3]);\n};",
      "writeIntegerVector2": "const writeIntegerVector2 = (\n  stream: NoLimitsStream,\n  value: [number, number],\n) => {\n  writeInteger(stream, value[0]);\n  writeInteger(stream, value[1]);\n};",
      "writeFloatVector2": "const writeFloatVector2 = (\n  stream: NoLimitsStream,\n  value: [number, number],\n) => {\n  writeFloat(stream, value[0]);\n  writeFloat(stream, value[1]);\n};",
      "writeFloatVector3": "const writeFloatVector3 = (\n  stream: NoLimitsStream,\n  value: [number, number, number],\n) => {\n  writeFloat(stream, value[0]);\n  writeFloat(stream, value[1]);\n  writeFloat(stream, value[2]);\n};",
      "writeDoubleVector3": "const writeDoubleVector3 = (\n  stream: NoLimitsStream,\n  value: [number, number, number],\n) => {\n  writeDouble(stream, value[0]);\n  writeDouble(stream, value[1]);\n  writeDouble(stream, value[2]);\n};",
      "writeDoubleVector2": "const writeDoubleVector2 = (\n  stream: NoLimitsStream,\n  value: [number, number],\n) => {\n  writeDouble(stream, value[0]);\n  writeDouble(stream, value[1]);\n};",
      "writeNull": "const writeNull = (\n  stream: NoLimitsStream,\n  byteCount: number,\n) => {\n  write(stream, new ArrayBuffer(byteCount));\n};",
      "writeUnsigned8": "const writeUnsigned8 = (\n  stream: NoLimitsStream,\n  value: number,\n) => {\n  const buffer = new ArrayBuffer(1);\n  new Uint8Array(buffer)[0] = value & 0xff;\n  write(stream, buffer);\n};",
      "writeString": "const writeString = (\n  stream: NoLimitsStream,\n  value: string,\n) => {\n  for (let i = 0; i < value.length; i++) {\n    writeNull(stream, 1);\n    writeUnsigned8(stream, value.charCodeAt(i));\n  }\n\n  writeNull(stream, 2);\n};",
      "writeUnsigned8Vector3": "const writeUnsigned8Vector3 = (\n  stream: NoLimitsStream,\n  value: [number, number, number],\n) => {\n  writeUnsigned8(stream, value[0]);\n  writeUnsigned8(stream, value[1]);\n  writeUnsigned8(stream, value[2]);\n};",
      "writeColor": "const writeColor = (\n  stream: NoLimitsStream,\n  color: [number, number, number],\n) => {\n  writeUnsigned8Vector3(stream, color);\n};",
      "writeChunkName": "const writeChunkName = (\n  stream: NoLimitsStream,\n  name: string,\n) => {\n  for (let i = 0; i < 4; i++) {\n    writeUnsigned8(stream, name.charCodeAt(i) ?? 0);\n  }\n};",
      "writeChunk": "const writeChunk = (\n  stream: NoLimitsStream,\n  chunkName: string,\n  handler: (stream: NoLimitsStream) => void,\n) => {\n  const chunkStream = fromArrayBuffer(new ArrayBuffer(0));\n  handler(chunkStream);\n\n  if (!chunkStream.content.length) return;\n\n  writeUnsignedInteger(stream, chunkStream.content.length);\n  writeChunkName(stream, chunkName);\n  write(stream, chunkStream.content);\n};"
    }
  },
  "src/helper/nl2park/coaster/car.ts": {
    "source": "import {\n  makeChunkReader,\n  NoLimitsStream,\n  readChunks,\n  readUnsignedInteger,\n  writeChunk,\n  writeUnsignedInteger,\n} from '../nolimits-stream';\nimport {\n  IndividualColor,\n  readIndividualColor,\n  writeIndividualColor,\n} from './individual-color';\n\nexport type Car = ReturnType<typeof readCar>;\n\nexport const readCar = (stream: NoLimitsStream) => {\n  let individualColor: IndividualColor | undefined;\n\n  const internalCarIndex = readUnsignedInteger(stream);\n\n  readChunks(\n    [\n      makeChunkReader(\n        readIndividualColor,\n        'INDC',\n        (color) => (individualColor = color),\n      ),\n    ],\n    stream,\n  );\n\n  return {\n    internalCarIndex,\n    individualColor,\n  };\n};\n\nexport const writeCar = (stream: NoLimitsStream, car: Car): void => {\n  writeUnsignedInteger(stream, car.internalCarIndex);\n  writeChunk(stream, 'INDC', (s) => {\n    if (!car.individualColor) return;\n    writeIndividualColor(s, car.individualColor);\n  });\n};\n",
    "functions": {},
    "types": {
      "Car": "type Car = ReturnType<typeof readCar>;"
    },
    "variables": {
      "readCar": "const readCar = (stream: NoLimitsStream) => {\n  let individualColor: IndividualColor | undefined;\n\n  const internalCarIndex = readUnsignedInteger(stream);\n\n  readChunks(\n    [\n      makeChunkReader(\n        readIndividualColor,\n        'INDC',\n        (color) => (individualColor = color),\n      ),\n    ],\n    stream,\n  );\n\n  return {\n    internalCarIndex,\n    individualColor,\n  };\n};",
      "writeCar": "const writeCar = (stream: NoLimitsStream, car: Car): void => {\n  writeUnsignedInteger(stream, car.internalCarIndex);\n  writeChunk(stream, 'INDC', (s) => {\n    if (!car.individualColor) return;\n    writeIndividualColor(s, car.individualColor);\n  });\n};"
    }
  },
  "src/helper/nl2park/coaster/coaster.ts": {
    "source": "import { compact } from 'lodash';\n\nimport {\n  makeChunkReader,\n  NoLimitsStream,\n  readBoolean,\n  readChunks,\n  readColor,\n  readDoubleVector2,\n  readNull,\n  readString,\n  readUnsigned8,\n  writeBoolean,\n  writeChunk,\n  writeColor,\n  writeDoubleVector2,\n  writeNull,\n  writeString,\n  writeUnsigned8,\n} from '../nolimits-stream';\nimport {\n  CustomTrack,\n  readCustomTrack,\n  writeCustomTrack,\n} from '../track/custom-track';\nimport {\n  CustomFriction,\n  readCustomFriction,\n  writeCustomFriction,\n} from './custom-friction';\nimport { readFileScript, writeFileScript } from './file-script';\nimport { readScript, Script, writeScript } from './script';\nimport { readTrain, Train, writeTrain } from './train';\n\nexport type Coaster = ReturnType<typeof readCoaster>;\n\nexport const readCoaster = (stream: NoLimitsStream) => {\n  const name = readString(stream);\n\n  const colorsWireframeTrack = readColor(stream);\n\n  const modeSplinePosition = readUnsigned8(stream);\n  const modeSplinePositionOffset = readDoubleVector2(stream);\n\n  const description = readString(stream);\n\n  readNull(stream, 3);\n\n  const styleStyleType = readUnsigned8(stream);\n\n  const colorsRails = readColor(stream);\n  const colorsCrossTies = readColor(stream);\n  const colorsMainSpine = readColor(stream);\n  const colorsCar = readColor(stream);\n  const colorsSeat = readColor(stream);\n  const colorsHarness = readColor(stream);\n  const colorsBogie = readColor(stream);\n\n  const frozen = readBoolean(stream);\n\n  const colorsSpineColorScheme = readUnsigned8(stream);\n  const colorsSupports = readColor(stream);\n  const colorsTunnel = readColor(stream);\n\n  const styleWornType = readUnsigned8(stream);\n  const colorsChassis = readColor(stream);\n\n  const modeOperationMode = readUnsigned8(stream);\n  const styleRailType = readUnsigned8(stream);\n\n  const colorsHandrails = readColor(stream);\n  const colorsCatwalks = readColor(stream);\n\n  const modePhysicsModel = readUnsigned8(stream);\n  const hideWireframe = readBoolean(stream);\n\n  readNull(stream, 1);\n\n  const tracks: CustomTrack[] = [];\n  const trains: Train[] = [];\n  const scripts: Array<\n    | ({\n        scriptType: 'script';\n      } & Script)\n    | {\n        scriptType: 'file-script';\n        path: string;\n      }\n  > = [];\n  let customFriction: CustomFriction | undefined;\n\n  readChunks(\n    [\n      makeChunkReader(readCustomTrack, 'CUTK', (customTrack) =>\n        tracks.push(customTrack),\n      ),\n      makeChunkReader(readTrain, 'TRAI', (train) =>\n        trains.push(train),\n      ),\n      makeChunkReader(\n        readCustomFriction,\n        'CUFR',\n        (chunkCustomFriction) =>\n          (customFriction = chunkCustomFriction),\n      ),\n      makeChunkReader(readScript, 'SCRT', (script) =>\n        scripts.push({\n          scriptType: 'script',\n          ...script,\n        }),\n      ),\n      makeChunkReader(readFileScript, 'FSCR', (fileScripts) =>\n        fileScripts.paths.forEach((path) =>\n          scripts.push({\n            scriptType: 'file-script',\n            path,\n          }),\n        ),\n      ),\n    ],\n    stream,\n  );\n\n  return {\n    name,\n    description,\n    hideWireframe,\n    frozen,\n    tracks,\n    trains,\n    scripts,\n    customFriction,\n    mode: {\n      splinePosition: modeSplinePosition,\n      splinePositionOffset: modeSplinePositionOffset,\n      operationMode: modeOperationMode,\n      physicsModel: modePhysicsModel,\n    },\n    style: {\n      styleType: styleStyleType,\n      wornType: styleWornType,\n      railType: styleRailType,\n    },\n    colors: {\n      wireframeTrack: colorsWireframeTrack,\n      rails: colorsRails,\n      crossTies: colorsCrossTies,\n      mainSpine: colorsMainSpine,\n      car: colorsCar,\n      seat: colorsSeat,\n      harness: colorsHarness,\n      bogie: colorsBogie,\n      spineColorScheme: colorsSpineColorScheme,\n      supports: colorsSupports,\n      tunnel: colorsTunnel,\n      chassis: colorsChassis,\n      handrails: colorsHandrails,\n      catwalks: colorsCatwalks,\n    },\n  };\n};\n\nexport const writeCoaster = (\n  stream: NoLimitsStream,\n  coaster: Coaster,\n): void => {\n  writeString(stream, coaster.name);\n\n  writeColor(stream, coaster.colors.wireframeTrack);\n\n  writeUnsigned8(stream, coaster.mode.splinePosition);\n  writeDoubleVector2(stream, coaster.mode.splinePositionOffset);\n\n  writeString(stream, coaster.description);\n\n  writeNull(stream, 3);\n\n  writeUnsigned8(stream, coaster.style.styleType);\n\n  writeColor(stream, coaster.colors.rails);\n  writeColor(stream, coaster.colors.crossTies);\n  writeColor(stream, coaster.colors.mainSpine);\n  writeColor(stream, coaster.colors.car);\n  writeColor(stream, coaster.colors.seat);\n  writeColor(stream, coaster.colors.harness);\n  writeColor(stream, coaster.colors.bogie);\n\n  writeBoolean(stream, coaster.frozen);\n\n  writeUnsigned8(stream, coaster.colors.spineColorScheme);\n  writeColor(stream, coaster.colors.supports);\n  writeColor(stream, coaster.colors.tunnel);\n\n  writeUnsigned8(stream, coaster.style.wornType);\n  writeColor(stream, coaster.colors.chassis);\n\n  writeUnsigned8(stream, coaster.mode.operationMode);\n  writeUnsigned8(stream, coaster.style.railType);\n\n  writeColor(stream, coaster.colors.handrails);\n  writeColor(stream, coaster.colors.catwalks);\n\n  writeUnsigned8(stream, coaster.mode.physicsModel);\n  writeBoolean(stream, coaster.hideWireframe);\n\n  writeNull(stream, 1);\n\n  // chunks\n  for (const track of coaster.tracks) {\n    writeChunk(stream, 'CUTK', (s) => writeCustomTrack(s, track));\n  }\n\n  for (const train of coaster.trains) {\n    writeChunk(stream, 'TRAI', (s) => writeTrain(s, train));\n  }\n\n  writeChunk(stream, 'CUFR', (s) => {\n    if (!coaster.customFriction) return;\n    writeCustomFriction(s, coaster.customFriction);\n  });\n\n  coaster.scripts\n    .filter((s) => s.scriptType === 'script')\n    .forEach((script) =>\n      writeChunk(stream, 'SCRT', (s) =>\n        writeScript(s, script as Script),\n      ),\n    );\n\n  const fileScripts = compact(\n    coaster.scripts.map((s) =>\n      s.scriptType === 'file-script' ? s.path : undefined,\n    ),\n  );\n\n  if (fileScripts.length)\n    writeChunk(stream, 'FSCR', (s) => {\n      writeFileScript(s, {\n        paths: fileScripts,\n      });\n    });\n};\n",
    "functions": {},
    "types": {
      "Coaster": "type Coaster = ReturnType<typeof readCoaster>;"
    },
    "variables": {
      "readCoaster": "const readCoaster = (stream: NoLimitsStream) => {\n  const name = readString(stream);\n\n  const colorsWireframeTrack = readColor(stream);\n\n  const modeSplinePosition = readUnsigned8(stream);\n  const modeSplinePositionOffset = readDoubleVector2(stream);\n\n  const description = readString(stream);\n\n  readNull(stream, 3);\n\n  const styleStyleType = readUnsigned8(stream);\n\n  const colorsRails = readColor(stream);\n  const colorsCrossTies = readColor(stream);\n  const colorsMainSpine = readColor(stream);\n  const colorsCar = readColor(stream);\n  const colorsSeat = readColor(stream);\n  const colorsHarness = readColor(stream);\n  const colorsBogie = readColor(stream);\n\n  const frozen = readBoolean(stream);\n\n  const colorsSpineColorScheme = readUnsigned8(stream);\n  const colorsSupports = readColor(stream);\n  const colorsTunnel = readColor(stream);\n\n  const styleWornType = readUnsigned8(stream);\n  const colorsChassis = readColor(stream);\n\n  const modeOperationMode = readUnsigned8(stream);\n  const styleRailType = readUnsigned8(stream);\n\n  const colorsHandrails = readColor(stream);\n  const colorsCatwalks = readColor(stream);\n\n  const modePhysicsModel = readUnsigned8(stream);\n  const hideWireframe = readBoolean(stream);\n\n  readNull(stream, 1);\n\n  const tracks: CustomTrack[] = [];\n  const trains: Train[] = [];\n  const scripts: Array<\n    | ({\n        scriptType: 'script';\n      } & Script)\n    | {\n        scriptType: 'file-script';\n        path: string;\n      }\n  > = [];\n  let customFriction: CustomFriction | undefined;\n\n  readChunks(\n    [\n      makeChunkReader(readCustomTrack, 'CUTK', (customTrack) =>\n        tracks.push(customTrack),\n      ),\n      makeChunkReader(readTrain, 'TRAI', (train) =>\n        trains.push(train),\n      ),\n      makeChunkReader(\n        readCustomFriction,\n        'CUFR',\n        (chunkCustomFriction) =>\n          (customFriction = chunkCustomFriction),\n      ),\n      makeChunkReader(readScript, 'SCRT', (script) =>\n        scripts.push({\n          scriptType: 'script',\n          ...script,\n        }),\n      ),\n      makeChunkReader(readFileScript, 'FSCR', (fileScripts) =>\n        fileScripts.paths.forEach((path) =>\n          scripts.push({\n            scriptType: 'file-script',\n            path,\n          }),\n        ),\n      ),\n    ],\n    stream,\n  );\n\n  return {\n    name,\n    description,\n    hideWireframe,\n    frozen,\n    tracks,\n    trains,\n    scripts,\n    customFriction,\n    mode: {\n      splinePosition: modeSplinePosition,\n      splinePositionOffset: modeSplinePositionOffset,\n      operationMode: modeOperationMode,\n      physicsModel: modePhysicsModel,\n    },\n    style: {\n      styleType: styleStyleType,\n      wornType: styleWornType,\n      railType: styleRailType,\n    },\n    colors: {\n      wireframeTrack: colorsWireframeTrack,\n      rails: colorsRails,\n      crossTies: colorsCrossTies,\n      mainSpine: colorsMainSpine,\n      car: colorsCar,\n      seat: colorsSeat,\n      harness: colorsHarness,\n      bogie: colorsBogie,\n      spineColorScheme: colorsSpineColorScheme,\n      supports: colorsSupports,\n      tunnel: colorsTunnel,\n      chassis: colorsChassis,\n      handrails: colorsHandrails,\n      catwalks: colorsCatwalks,\n    },\n  };\n};",
      "writeCoaster": "const writeCoaster = (\n  stream: NoLimitsStream,\n  coaster: Coaster,\n): void => {\n  writeString(stream, coaster.name);\n\n  writeColor(stream, coaster.colors.wireframeTrack);\n\n  writeUnsigned8(stream, coaster.mode.splinePosition);\n  writeDoubleVector2(stream, coaster.mode.splinePositionOffset);\n\n  writeString(stream, coaster.description);\n\n  writeNull(stream, 3);\n\n  writeUnsigned8(stream, coaster.style.styleType);\n\n  writeColor(stream, coaster.colors.rails);\n  writeColor(stream, coaster.colors.crossTies);\n  writeColor(stream, coaster.colors.mainSpine);\n  writeColor(stream, coaster.colors.car);\n  writeColor(stream, coaster.colors.seat);\n  writeColor(stream, coaster.colors.harness);\n  writeColor(stream, coaster.colors.bogie);\n\n  writeBoolean(stream, coaster.frozen);\n\n  writeUnsigned8(stream, coaster.colors.spineColorScheme);\n  writeColor(stream, coaster.colors.supports);\n  writeColor(stream, coaster.colors.tunnel);\n\n  writeUnsigned8(stream, coaster.style.wornType);\n  writeColor(stream, coaster.colors.chassis);\n\n  writeUnsigned8(stream, coaster.mode.operationMode);\n  writeUnsigned8(stream, coaster.style.railType);\n\n  writeColor(stream, coaster.colors.handrails);\n  writeColor(stream, coaster.colors.catwalks);\n\n  writeUnsigned8(stream, coaster.mode.physicsModel);\n  writeBoolean(stream, coaster.hideWireframe);\n\n  writeNull(stream, 1);\n\n  // chunks\n  for (const track of coaster.tracks) {\n    writeChunk(stream, 'CUTK', (s) => writeCustomTrack(s, track));\n  }\n\n  for (const train of coaster.trains) {\n    writeChunk(stream, 'TRAI', (s) => writeTrain(s, train));\n  }\n\n  writeChunk(stream, 'CUFR', (s) => {\n    if (!coaster.customFriction) return;\n    writeCustomFriction(s, coaster.customFriction);\n  });\n\n  coaster.scripts\n    .filter((s) => s.scriptType === 'script')\n    .forEach((script) =>\n      writeChunk(stream, 'SCRT', (s) =>\n        writeScript(s, script as Script),\n      ),\n    );\n\n  const fileScripts = compact(\n    coaster.scripts.map((s) =>\n      s.scriptType === 'file-script' ? s.path : undefined,\n    ),\n  );\n\n  if (fileScripts.length)\n    writeChunk(stream, 'FSCR', (s) => {\n      writeFileScript(s, {\n        paths: fileScripts,\n      });\n    });\n};"
    }
  },
  "src/helper/nl2park/coaster/custom-friction.ts": {
    "source": "import {\n  NoLimitsStream,\n  readDouble,\n  readNull,\n  writeDouble,\n  writeNull,\n} from '../nolimits-stream';\n\nexport type CustomFriction = ReturnType<typeof readCustomFriction>;\n\nexport const readCustomFriction = (stream: NoLimitsStream) => {\n  const constFrictionParameter = readDouble(stream);\n  const airResistanceParameter = readDouble(stream);\n\n  readNull(stream, 32);\n\n  return {\n    constFrictionParameter,\n    airResistanceParameter,\n  };\n};\n\nexport const writeCustomFriction = (\n  stream: NoLimitsStream,\n  friction: CustomFriction,\n): void => {\n  writeDouble(stream, friction.constFrictionParameter);\n  writeDouble(stream, friction.airResistanceParameter);\n\n  writeNull(stream, 32);\n};\n",
    "functions": {},
    "types": {
      "CustomFriction": "type CustomFriction = ReturnType<typeof readCustomFriction>;"
    },
    "variables": {
      "readCustomFriction": "const readCustomFriction = (stream: NoLimitsStream) => {\n  const constFrictionParameter = readDouble(stream);\n  const airResistanceParameter = readDouble(stream);\n\n  readNull(stream, 32);\n\n  return {\n    constFrictionParameter,\n    airResistanceParameter,\n  };\n};",
      "writeCustomFriction": "const writeCustomFriction = (\n  stream: NoLimitsStream,\n  friction: CustomFriction,\n): void => {\n  writeDouble(stream, friction.constFrictionParameter);\n  writeDouble(stream, friction.airResistanceParameter);\n\n  writeNull(stream, 32);\n};"
    }
  },
  "src/helper/nl2park/coaster/file-script.ts": {
    "source": "import {\n  NoLimitsStream,\n  readNull,\n  readString,\n  readUnsignedInteger,\n  writeNull,\n  writeString,\n  writeUnsignedInteger,\n} from '../nolimits-stream';\n\nexport type FileScript = ReturnType<typeof readFileScript>;\n\nexport const readFileScript = (stream: NoLimitsStream) => {\n  const paths: string[] = [];\n\n  const numberOfFileScripts = readUnsignedInteger(stream);\n  for (let i = 0; i < numberOfFileScripts; i++) {\n    paths.push(readString(stream));\n    readNull(stream, 8);\n  }\n\n  readNull(stream, 8);\n\n  return {\n    paths,\n  };\n};\n\nexport const writeFileScript = (\n  stream: NoLimitsStream,\n  fileScript: FileScript,\n): void => {\n  writeUnsignedInteger(stream, fileScript.paths.length);\n  for (const path of fileScript.paths) {\n    writeString(stream, path);\n    writeNull(stream, 8);\n  }\n\n  writeNull(stream, 8);\n};\n",
    "functions": {},
    "types": {
      "FileScript": "type FileScript = ReturnType<typeof readFileScript>;"
    },
    "variables": {
      "readFileScript": "const readFileScript = (stream: NoLimitsStream) => {\n  const paths: string[] = [];\n\n  const numberOfFileScripts = readUnsignedInteger(stream);\n  for (let i = 0; i < numberOfFileScripts; i++) {\n    paths.push(readString(stream));\n    readNull(stream, 8);\n  }\n\n  readNull(stream, 8);\n\n  return {\n    paths,\n  };\n};",
      "writeFileScript": "const writeFileScript = (\n  stream: NoLimitsStream,\n  fileScript: FileScript,\n): void => {\n  writeUnsignedInteger(stream, fileScript.paths.length);\n  for (const path of fileScript.paths) {\n    writeString(stream, path);\n    writeNull(stream, 8);\n  }\n\n  writeNull(stream, 8);\n};"
    }
  },
  "src/helper/nl2park/coaster/individual-color.ts": {
    "source": "import {\n  NoLimitsStream,\n  readBoolean,\n  readColor,\n  readNull,\n  readString,\n  readUnsignedInteger,\n  writeBoolean,\n  writeColor,\n  writeNull,\n  writeString,\n  writeUnsignedInteger,\n} from '../nolimits-stream';\n\nexport type IndividualColor = ReturnType<typeof readIndividualColor>;\n\nexport const readIndividualColor = (stream: NoLimitsStream) => {\n  const hasIndividualColor = readBoolean(stream);\n\n  const carColor = readColor(stream);\n  const seatColor = readColor(stream);\n  const harnessColor = readColor(stream);\n  const bogieColor = readColor(stream);\n  const chassisColor = readColor(stream);\n\n  readNull(stream, 16);\n\n  const carTextures: string[] = [];\n\n  const numberOfTextures = readUnsignedInteger(stream);\n  for (let i = 0; i < numberOfTextures; i++) {\n    readNull(stream, 4);\n    carTextures.push(readString(stream));\n    readNull(stream, 8);\n  }\n\n  return {\n    hasIndividualColor,\n    carColor,\n    seatColor,\n    harnessColor,\n    bogieColor,\n    chassisColor,\n    carTextures,\n  };\n};\n\nexport const writeIndividualColor = (\n  stream: NoLimitsStream,\n  color: IndividualColor,\n): void => {\n  writeBoolean(stream, color.hasIndividualColor);\n\n  writeColor(stream, color.carColor);\n  writeColor(stream, color.seatColor);\n  writeColor(stream, color.harnessColor);\n  writeColor(stream, color.bogieColor);\n  writeColor(stream, color.chassisColor);\n\n  writeNull(stream, 16);\n\n  writeUnsignedInteger(stream, color.carTextures.length);\n  for (const texture of color.carTextures) {\n    writeNull(stream, 4);\n    writeString(stream, texture);\n    writeNull(stream, 8);\n  }\n};\n",
    "functions": {},
    "types": {
      "IndividualColor": "type IndividualColor = ReturnType<typeof readIndividualColor>;"
    },
    "variables": {
      "readIndividualColor": "const readIndividualColor = (stream: NoLimitsStream) => {\n  const hasIndividualColor = readBoolean(stream);\n\n  const carColor = readColor(stream);\n  const seatColor = readColor(stream);\n  const harnessColor = readColor(stream);\n  const bogieColor = readColor(stream);\n  const chassisColor = readColor(stream);\n\n  readNull(stream, 16);\n\n  const carTextures: string[] = [];\n\n  const numberOfTextures = readUnsignedInteger(stream);\n  for (let i = 0; i < numberOfTextures; i++) {\n    readNull(stream, 4);\n    carTextures.push(readString(stream));\n    readNull(stream, 8);\n  }\n\n  return {\n    hasIndividualColor,\n    carColor,\n    seatColor,\n    harnessColor,\n    bogieColor,\n    chassisColor,\n    carTextures,\n  };\n};",
      "writeIndividualColor": "const writeIndividualColor = (\n  stream: NoLimitsStream,\n  color: IndividualColor,\n): void => {\n  writeBoolean(stream, color.hasIndividualColor);\n\n  writeColor(stream, color.carColor);\n  writeColor(stream, color.seatColor);\n  writeColor(stream, color.harnessColor);\n  writeColor(stream, color.bogieColor);\n  writeColor(stream, color.chassisColor);\n\n  writeNull(stream, 16);\n\n  writeUnsignedInteger(stream, color.carTextures.length);\n  for (const texture of color.carTextures) {\n    writeNull(stream, 4);\n    writeString(stream, texture);\n    writeNull(stream, 8);\n  }\n};"
    }
  },
  "src/helper/nl2park/coaster/script.ts": {
    "source": "import {\n  NoLimitsStream,\n  readBoolean,\n  readNull,\n  readString,\n  readUnsignedInteger,\n  writeBoolean,\n  writeNull,\n  writeString,\n  writeUnsignedInteger,\n} from '../nolimits-stream';\n\nexport type Script = ReturnType<typeof readScript>;\n\nexport const readScript = (stream: NoLimitsStream) => {\n  const resourceFiles: Array<{\n    id: string;\n    path: string;\n  }> = [];\n\n  readNull(stream, 4);\n\n  const classPath = readString(stream);\n  const scriptClass = readString(stream);\n\n  const numberOfResourceFiles = readUnsignedInteger(stream);\n  for (let i = 0; i < numberOfResourceFiles; i++) {\n    resourceFiles.push({\n      id: readString(stream),\n      path: readString(stream),\n    });\n  }\n\n  const privateVirtualMachine = !readBoolean(stream);\n\n  readNull(stream, 7);\n\n  return {\n    classPath,\n    scriptClass,\n    resourceFiles,\n    privateVirtualMachine,\n  };\n};\n\nexport const writeScript = (\n  stream: NoLimitsStream,\n  script: Script,\n): void => {\n  writeNull(stream, 4);\n\n  writeString(stream, script.classPath);\n  writeString(stream, script.scriptClass);\n\n  writeUnsignedInteger(stream, script.resourceFiles.length);\n  for (const res of script.resourceFiles) {\n    writeString(stream, res.id);\n    writeString(stream, res.path);\n  }\n\n  writeBoolean(stream, !script.privateVirtualMachine);\n\n  writeNull(stream, 7);\n};\n",
    "functions": {},
    "types": {
      "Script": "type Script = ReturnType<typeof readScript>;"
    },
    "variables": {
      "readScript": "const readScript = (stream: NoLimitsStream) => {\n  const resourceFiles: Array<{\n    id: string;\n    path: string;\n  }> = [];\n\n  readNull(stream, 4);\n\n  const classPath = readString(stream);\n  const scriptClass = readString(stream);\n\n  const numberOfResourceFiles = readUnsignedInteger(stream);\n  for (let i = 0; i < numberOfResourceFiles; i++) {\n    resourceFiles.push({\n      id: readString(stream),\n      path: readString(stream),\n    });\n  }\n\n  const privateVirtualMachine = !readBoolean(stream);\n\n  readNull(stream, 7);\n\n  return {\n    classPath,\n    scriptClass,\n    resourceFiles,\n    privateVirtualMachine,\n  };\n};",
      "writeScript": "const writeScript = (\n  stream: NoLimitsStream,\n  script: Script,\n): void => {\n  writeNull(stream, 4);\n\n  writeString(stream, script.classPath);\n  writeString(stream, script.scriptClass);\n\n  writeUnsignedInteger(stream, script.resourceFiles.length);\n  for (const res of script.resourceFiles) {\n    writeString(stream, res.id);\n    writeString(stream, res.path);\n  }\n\n  writeBoolean(stream, !script.privateVirtualMachine);\n\n  writeNull(stream, 7);\n};"
    }
  },
  "src/helper/nl2park/coaster/train.ts": {
    "source": "import {\n  makeChunkReader,\n  NoLimitsStream,\n  readBoolean,\n  readChunks,\n  readNull,\n  readString,\n  readUnsignedInteger,\n  writeBoolean,\n  writeChunk,\n  writeNull,\n  writeString,\n  writeUnsignedInteger,\n} from '../nolimits-stream';\nimport { readCar, writeCar } from './car';\nimport {\n  IndividualColor,\n  readIndividualColor,\n  writeIndividualColor,\n} from './individual-color';\n\nexport type Train = ReturnType<typeof readTrain>;\n\nexport const readTrain = (stream: NoLimitsStream) => {\n  const cars: ReturnType<typeof readCar>[] = [];\n\n  let individualColor: IndividualColor | undefined;\n  const startBlock = readString(stream);\n\n  readUnsignedInteger(stream); // number of cars (ignored, cars are read via CAR chunks)\n  readNull(stream, 4);\n\n  const runBackward = readBoolean(stream);\n  const removedFromTrack = readBoolean(stream);\n\n  readNull(stream, 31);\n\n  readChunks(\n    [\n      makeChunkReader(readCar, 'CAR', (car) => cars.push(car)),\n      makeChunkReader(\n        readIndividualColor,\n        'INDC',\n        (color) => (individualColor = color),\n      ),\n    ],\n    stream,\n  );\n\n  return {\n    startBlock,\n    runBackward,\n    removedFromTrack,\n    cars,\n    individualColor,\n  };\n};\n\nexport const writeTrain = (\n  stream: NoLimitsStream,\n  train: Train,\n): void => {\n  writeString(stream, train.startBlock);\n\n  writeUnsignedInteger(stream, train.cars.length);\n\n  writeNull(stream, 4);\n\n  writeBoolean(stream, train.runBackward);\n  writeBoolean(stream, train.removedFromTrack);\n\n  writeNull(stream, 31);\n\n  for (const car of train.cars) {\n    writeChunk(stream, 'CAR', (s) => writeCar(s, car));\n  }\n\n  writeChunk(stream, 'INDC', (s) => {\n    if (!train.individualColor) return;\n    writeIndividualColor(s, train.individualColor);\n  });\n};\n",
    "functions": {},
    "types": {
      "Train": "type Train = ReturnType<typeof readTrain>;"
    },
    "variables": {
      "readTrain": "const readTrain = (stream: NoLimitsStream) => {\n  const cars: ReturnType<typeof readCar>[] = [];\n\n  let individualColor: IndividualColor | undefined;\n  const startBlock = readString(stream);\n\n  readUnsignedInteger(stream); // number of cars (ignored, cars are read via CAR chunks)\n  readNull(stream, 4);\n\n  const runBackward = readBoolean(stream);\n  const removedFromTrack = readBoolean(stream);\n\n  readNull(stream, 31);\n\n  readChunks(\n    [\n      makeChunkReader(readCar, 'CAR', (car) => cars.push(car)),\n      makeChunkReader(\n        readIndividualColor,\n        'INDC',\n        (color) => (individualColor = color),\n      ),\n    ],\n    stream,\n  );\n\n  return {\n    startBlock,\n    runBackward,\n    removedFromTrack,\n    cars,\n    individualColor,\n  };\n};",
      "writeTrain": "const writeTrain = (\n  stream: NoLimitsStream,\n  train: Train,\n): void => {\n  writeString(stream, train.startBlock);\n\n  writeUnsignedInteger(stream, train.cars.length);\n\n  writeNull(stream, 4);\n\n  writeBoolean(stream, train.runBackward);\n  writeBoolean(stream, train.removedFromTrack);\n\n  writeNull(stream, 31);\n\n  for (const car of train.cars) {\n    writeChunk(stream, 'CAR', (s) => writeCar(s, car));\n  }\n\n  writeChunk(stream, 'INDC', (s) => {\n    if (!train.individualColor) return;\n    writeIndividualColor(s, train.individualColor);\n  });\n};"
    }
  },
  "src/helper/nl2park/section/brake-section.ts": {
    "source": "import {\n  NoLimitsStream,\n  readBoolean,\n  readDouble,\n  readNull,\n  readUnsigned8,\n  writeBoolean,\n  writeDouble,\n  writeNull,\n  writeUnsigned8,\n} from '../nolimits-stream';\n\nexport type BrakeSection = ReturnType<typeof readBrakeSection>;\n\nexport const readBrakeSection = (stream: NoLimitsStream) => {\n  const mode = readUnsigned8(stream); // Brake::BrakeMode\n  const brakeType = readUnsigned8(stream); // Brake::BrakeType\n  const deceleration = readDouble(stream);\n  const speedLimit = readDouble(stream);\n  const hysteresis = readDouble(stream);\n\n  const positionOnTrain = readUnsigned8(stream); // Brake::Position\n  const positionOnSection = readDouble(stream);\n\n  const completeStop = readBoolean(stream);\n  const waitTime = readDouble(stream);\n\n  readNull(stream, 23);\n\n  const enableTransport = readBoolean(stream);\n\n  const transportType = readUnsigned8(stream); // Transport::TransportType\n  const transportSpeed = readDouble(stream);\n  const transportAcceleration = readDouble(stream);\n  const transportDeceleration = readDouble(stream);\n  const transportLaunch = readBoolean(stream);\n  const transportLaunchAcceleration = readDouble(stream);\n  const transportLaunchMaxSpeed = readDouble(stream);\n\n  const extraBlockLength = readDouble(stream);\n\n  readNull(stream, 75);\n\n  const transportDevice = {\n    transportType,\n    speed: transportSpeed,\n    acceleration: transportAcceleration,\n    deceleration: transportDeceleration,\n    launch: transportLaunch,\n    launchAcceleration: transportLaunchAcceleration,\n    launchMaxSpeed: transportLaunchMaxSpeed,\n  };\n\n  return {\n    mode,\n    brakeType,\n    deceleration,\n    speedLimit,\n    hysteresis,\n    positionOnTrain,\n    positionOnSection,\n    completeStop,\n    waitTime,\n    enableTransport,\n    transportDevice,\n    extraBlockLength,\n  };\n};\n\nexport const writeBrakeSection = (\n  stream: NoLimitsStream,\n  brake: BrakeSection,\n): void => {\n  writeUnsigned8(stream, brake.mode);\n  writeUnsigned8(stream, brake.brakeType);\n  writeDouble(stream, brake.deceleration);\n  writeDouble(stream, brake.speedLimit);\n  writeDouble(stream, brake.hysteresis);\n\n  writeUnsigned8(stream, brake.positionOnTrain);\n  writeDouble(stream, brake.positionOnSection);\n\n  writeBoolean(stream, brake.completeStop);\n  writeDouble(stream, brake.waitTime);\n\n  writeNull(stream, 23);\n\n  writeBoolean(stream, brake.enableTransport);\n\n  writeUnsigned8(stream, brake.transportDevice.transportType);\n  writeDouble(stream, brake.transportDevice.speed);\n  writeDouble(stream, brake.transportDevice.acceleration);\n  writeDouble(stream, brake.transportDevice.deceleration);\n  writeBoolean(stream, brake.transportDevice.launch);\n  writeDouble(stream, brake.transportDevice.launchAcceleration);\n  writeDouble(stream, brake.transportDevice.launchMaxSpeed);\n\n  writeDouble(stream, brake.extraBlockLength);\n\n  writeNull(stream, 75);\n};\n",
    "functions": {},
    "types": {
      "BrakeSection": "type BrakeSection = ReturnType<typeof readBrakeSection>;"
    },
    "variables": {
      "readBrakeSection": "const readBrakeSection = (stream: NoLimitsStream) => {\n  const mode = readUnsigned8(stream); // Brake::BrakeMode\n  const brakeType = readUnsigned8(stream); // Brake::BrakeType\n  const deceleration = readDouble(stream);\n  const speedLimit = readDouble(stream);\n  const hysteresis = readDouble(stream);\n\n  const positionOnTrain = readUnsigned8(stream); // Brake::Position\n  const positionOnSection = readDouble(stream);\n\n  const completeStop = readBoolean(stream);\n  const waitTime = readDouble(stream);\n\n  readNull(stream, 23);\n\n  const enableTransport = readBoolean(stream);\n\n  const transportType = readUnsigned8(stream); // Transport::TransportType\n  const transportSpeed = readDouble(stream);\n  const transportAcceleration = readDouble(stream);\n  const transportDeceleration = readDouble(stream);\n  const transportLaunch = readBoolean(stream);\n  const transportLaunchAcceleration = readDouble(stream);\n  const transportLaunchMaxSpeed = readDouble(stream);\n\n  const extraBlockLength = readDouble(stream);\n\n  readNull(stream, 75);\n\n  const transportDevice = {\n    transportType,\n    speed: transportSpeed,\n    acceleration: transportAcceleration,\n    deceleration: transportDeceleration,\n    launch: transportLaunch,\n    launchAcceleration: transportLaunchAcceleration,\n    launchMaxSpeed: transportLaunchMaxSpeed,\n  };\n\n  return {\n    mode,\n    brakeType,\n    deceleration,\n    speedLimit,\n    hysteresis,\n    positionOnTrain,\n    positionOnSection,\n    completeStop,\n    waitTime,\n    enableTransport,\n    transportDevice,\n    extraBlockLength,\n  };\n};",
      "writeBrakeSection": "const writeBrakeSection = (\n  stream: NoLimitsStream,\n  brake: BrakeSection,\n): void => {\n  writeUnsigned8(stream, brake.mode);\n  writeUnsigned8(stream, brake.brakeType);\n  writeDouble(stream, brake.deceleration);\n  writeDouble(stream, brake.speedLimit);\n  writeDouble(stream, brake.hysteresis);\n\n  writeUnsigned8(stream, brake.positionOnTrain);\n  writeDouble(stream, brake.positionOnSection);\n\n  writeBoolean(stream, brake.completeStop);\n  writeDouble(stream, brake.waitTime);\n\n  writeNull(stream, 23);\n\n  writeBoolean(stream, brake.enableTransport);\n\n  writeUnsigned8(stream, brake.transportDevice.transportType);\n  writeDouble(stream, brake.transportDevice.speed);\n  writeDouble(stream, brake.transportDevice.acceleration);\n  writeDouble(stream, brake.transportDevice.deceleration);\n  writeBoolean(stream, brake.transportDevice.launch);\n  writeDouble(stream, brake.transportDevice.launchAcceleration);\n  writeDouble(stream, brake.transportDevice.launchMaxSpeed);\n\n  writeDouble(stream, brake.extraBlockLength);\n\n  writeNull(stream, 75);\n};"
    }
  },
  "src/helper/nl2park/section/lift-section.ts": {
    "source": "import {\n  NoLimitsStream,\n  readBoolean,\n  readDouble,\n  readNull,\n  readUnsigned8,\n  writeBoolean,\n  writeDouble,\n  writeNull,\n  writeUnsigned8,\n} from '../nolimits-stream';\n\nexport type LiftSection = ReturnType<typeof readLiftSection>;\n\nexport const readLiftSection = (stream: NoLimitsStream) => {\n  readNull(stream, 3);\n  const liftType = readUnsigned8(stream);\n  readNull(stream, 3);\n\n  const motorLocation = readUnsigned8(stream);\n  const speed = readDouble(stream);\n  const acceleration = readDouble(stream);\n  const deceleration = readDouble(stream);\n\n  const hasAntiRollbackDevice = readBoolean(stream);\n  const shuttleModeGentle2ndPassRelease = readBoolean(stream);\n  const extraBlockLength = readDouble(stream);\n\n  const diveCoasterDropReleaseMode = readBoolean(stream);\n\n  readNull(stream, 29);\n\n  return {\n    liftType,\n    motorLocation,\n    speed,\n    acceleration,\n    deceleration,\n    hasAntiRollbackDevice,\n    shuttleModeGentle2ndPassRelease,\n    extraBlockLength,\n    diveCoasterDropReleaseMode,\n  };\n};\n\nexport const writeLiftSection = (\n  stream: NoLimitsStream,\n  lift: LiftSection,\n): void => {\n  writeNull(stream, 3);\n  writeUnsigned8(stream, lift.liftType);\n  writeNull(stream, 3);\n\n  writeUnsigned8(stream, lift.motorLocation);\n  writeDouble(stream, lift.speed);\n  writeDouble(stream, lift.acceleration);\n  writeDouble(stream, lift.deceleration);\n\n  writeBoolean(stream, lift.hasAntiRollbackDevice);\n  writeBoolean(stream, lift.shuttleModeGentle2ndPassRelease);\n  writeDouble(stream, lift.extraBlockLength);\n\n  writeBoolean(stream, lift.diveCoasterDropReleaseMode);\n\n  writeNull(stream, 29);\n};\n",
    "functions": {},
    "types": {
      "LiftSection": "type LiftSection = ReturnType<typeof readLiftSection>;"
    },
    "variables": {
      "readLiftSection": "const readLiftSection = (stream: NoLimitsStream) => {\n  readNull(stream, 3);\n  const liftType = readUnsigned8(stream);\n  readNull(stream, 3);\n\n  const motorLocation = readUnsigned8(stream);\n  const speed = readDouble(stream);\n  const acceleration = readDouble(stream);\n  const deceleration = readDouble(stream);\n\n  const hasAntiRollbackDevice = readBoolean(stream);\n  const shuttleModeGentle2ndPassRelease = readBoolean(stream);\n  const extraBlockLength = readDouble(stream);\n\n  const diveCoasterDropReleaseMode = readBoolean(stream);\n\n  readNull(stream, 29);\n\n  return {\n    liftType,\n    motorLocation,\n    speed,\n    acceleration,\n    deceleration,\n    hasAntiRollbackDevice,\n    shuttleModeGentle2ndPassRelease,\n    extraBlockLength,\n    diveCoasterDropReleaseMode,\n  };\n};",
      "writeLiftSection": "const writeLiftSection = (\n  stream: NoLimitsStream,\n  lift: LiftSection,\n): void => {\n  writeNull(stream, 3);\n  writeUnsigned8(stream, lift.liftType);\n  writeNull(stream, 3);\n\n  writeUnsigned8(stream, lift.motorLocation);\n  writeDouble(stream, lift.speed);\n  writeDouble(stream, lift.acceleration);\n  writeDouble(stream, lift.deceleration);\n\n  writeBoolean(stream, lift.hasAntiRollbackDevice);\n  writeBoolean(stream, lift.shuttleModeGentle2ndPassRelease);\n  writeDouble(stream, lift.extraBlockLength);\n\n  writeBoolean(stream, lift.diveCoasterDropReleaseMode);\n\n  writeNull(stream, 29);\n};"
    }
  },
  "src/helper/nl2park/section/section.ts": {
    "source": "import {\n  makeChunkReader,\n  NoLimitsStream,\n  readChunks,\n  readNull,\n  readString,\n  readUnsignedInteger,\n  writeChunk,\n  writeNull,\n  writeString,\n  writeUnsignedInteger,\n} from '../nolimits-stream';\nimport {\n  BrakeSection,\n  readBrakeSection,\n  writeBrakeSection,\n} from './brake-section';\nimport {\n  LiftSection,\n  readLiftSection,\n  writeLiftSection,\n} from './lift-section';\nimport {\n  readStationSection,\n  StationSection,\n  writeStationSection,\n} from './station-section';\nimport {\n  readStorageSection,\n  StorageSection,\n  writeStorageSection,\n} from './storage-section';\nimport {\n  readTransportSection,\n  TransportSection,\n  writeTransportSection,\n} from './transport-section';\n\nexport type Section = {\n  name: string;\n} & (\n  | ({\n      sectionType: SectionType.Lift;\n    } & LiftSection)\n  | ({\n      sectionType: SectionType.Transport;\n    } & TransportSection)\n  | ({\n      sectionType: SectionType.Brake;\n    } & BrakeSection)\n  | ({\n      sectionType: SectionType.Station;\n    } & StationSection)\n  | ({\n      sectionType: SectionType.Storage;\n    } & StorageSection)\n  | {\n      sectionType: SectionType.Track;\n    }\n);\n\nexport enum SectionType {\n  Track = 0,\n  Station = 1,\n  Lift = 2,\n  Transport = 3,\n  Brake = 4,\n  Storage = 5,\n}\n\nexport const readSection = (stream: NoLimitsStream) => {\n  readUnsignedInteger(stream); // section type\n  const name = readString(stream);\n  readNull(stream, 26);\n\n  let section:\n    | ({\n        sectionType: SectionType.Lift;\n      } & LiftSection)\n    | ({\n        sectionType: SectionType.Transport;\n      } & TransportSection)\n    | ({\n        sectionType: SectionType.Brake;\n      } & BrakeSection)\n    | ({\n        sectionType: SectionType.Station;\n      } & StationSection)\n    | ({\n        sectionType: SectionType.Storage;\n      } & StorageSection)\n    | {\n        sectionType: SectionType.Track;\n      } = { sectionType: SectionType.Track };\n\n  readChunks(\n    [\n      makeChunkReader(readLiftSection, 'LIFT', (lift) => {\n        section = {\n          sectionType: SectionType.Lift,\n          ...lift,\n        };\n      }),\n      makeChunkReader(readTransportSection, 'TRNS', (transport) => {\n        section = {\n          sectionType: SectionType.Transport,\n          ...transport,\n        };\n      }),\n      makeChunkReader(readBrakeSection, 'BRKE', (brake) => {\n        section = {\n          sectionType: SectionType.Brake,\n          ...brake,\n        };\n      }),\n      makeChunkReader(readStationSection, 'STTN', (station) => {\n        section = {\n          sectionType: SectionType.Station,\n          ...station,\n        };\n      }),\n      makeChunkReader(readStorageSection, 'STOR', (storage) => {\n        section = {\n          sectionType: SectionType.Storage,\n          ...storage,\n        };\n      }),\n    ],\n    stream,\n  );\n\n  return {\n    name,\n    ...section,\n  };\n};\n\nexport const writeSection = (\n  stream: NoLimitsStream,\n  section: Section,\n): void => {\n  writeUnsignedInteger(stream, section.sectionType);\n  writeString(stream, section.name);\n  writeNull(stream, 26);\n\n  switch (section.sectionType) {\n    case SectionType.Lift:\n      writeChunk(stream, 'LIFT', (s) => writeLiftSection(s, section));\n      break;\n\n    case SectionType.Transport:\n      writeChunk(stream, 'TRNS', (s) =>\n        writeTransportSection(s, section),\n      );\n      break;\n\n    case SectionType.Brake:\n      writeChunk(stream, 'BRKE', (s) =>\n        writeBrakeSection(s, section),\n      );\n      break;\n\n    case SectionType.Station:\n      writeChunk(stream, 'STTN', (s) =>\n        writeStationSection(s, section),\n      );\n      break;\n\n    case SectionType.Storage:\n      writeChunk(stream, 'STOR', (s) =>\n        writeStorageSection(s, section),\n      );\n      break;\n  }\n};\n",
    "functions": {},
    "types": {
      "Section": "type Section = {\n  name: string;\n} & (\n  | ({\n      sectionType: SectionType.Lift;\n    } & LiftSection)\n  | ({\n      sectionType: SectionType.Transport;\n    } & TransportSection)\n  | ({\n      sectionType: SectionType.Brake;\n    } & BrakeSection)\n  | ({\n      sectionType: SectionType.Station;\n    } & StationSection)\n  | ({\n      sectionType: SectionType.Storage;\n    } & StorageSection)\n  | {\n      sectionType: SectionType.Track;\n    }\n);"
    },
    "variables": {
      "readSection": "const readSection = (stream: NoLimitsStream) => {\n  readUnsignedInteger(stream); // section type\n  const name = readString(stream);\n  readNull(stream, 26);\n\n  let section:\n    | ({\n        sectionType: SectionType.Lift;\n      } & LiftSection)\n    | ({\n        sectionType: SectionType.Transport;\n      } & TransportSection)\n    | ({\n        sectionType: SectionType.Brake;\n      } & BrakeSection)\n    | ({\n        sectionType: SectionType.Station;\n      } & StationSection)\n    | ({\n        sectionType: SectionType.Storage;\n      } & StorageSection)\n    | {\n        sectionType: SectionType.Track;\n      } = { sectionType: SectionType.Track };\n\n  readChunks(\n    [\n      makeChunkReader(readLiftSection, 'LIFT', (lift) => {\n        section = {\n          sectionType: SectionType.Lift,\n          ...lift,\n        };\n      }),\n      makeChunkReader(readTransportSection, 'TRNS', (transport) => {\n        section = {\n          sectionType: SectionType.Transport,\n          ...transport,\n        };\n      }),\n      makeChunkReader(readBrakeSection, 'BRKE', (brake) => {\n        section = {\n          sectionType: SectionType.Brake,\n          ...brake,\n        };\n      }),\n      makeChunkReader(readStationSection, 'STTN', (station) => {\n        section = {\n          sectionType: SectionType.Station,\n          ...station,\n        };\n      }),\n      makeChunkReader(readStorageSection, 'STOR', (storage) => {\n        section = {\n          sectionType: SectionType.Storage,\n          ...storage,\n        };\n      }),\n    ],\n    stream,\n  );\n\n  return {\n    name,\n    ...section,\n  };\n};",
      "writeSection": "const writeSection = (\n  stream: NoLimitsStream,\n  section: Section,\n): void => {\n  writeUnsignedInteger(stream, section.sectionType);\n  writeString(stream, section.name);\n  writeNull(stream, 26);\n\n  switch (section.sectionType) {\n    case SectionType.Lift:\n      writeChunk(stream, 'LIFT', (s) => writeLiftSection(s, section));\n      break;\n\n    case SectionType.Transport:\n      writeChunk(stream, 'TRNS', (s) =>\n        writeTransportSection(s, section),\n      );\n      break;\n\n    case SectionType.Brake:\n      writeChunk(stream, 'BRKE', (s) =>\n        writeBrakeSection(s, section),\n      );\n      break;\n\n    case SectionType.Station:\n      writeChunk(stream, 'STTN', (s) =>\n        writeStationSection(s, section),\n      );\n      break;\n\n    case SectionType.Storage:\n      writeChunk(stream, 'STOR', (s) =>\n        writeStorageSection(s, section),\n      );\n      break;\n  }\n};"
    }
  },
  "src/helper/nl2park/section/station-section.ts": {
    "source": "import {\n  NoLimitsStream,\n  readBoolean,\n  readColor,\n  readDouble,\n  readNull,\n  readUnsigned8,\n  readUnsignedInteger,\n  writeBoolean,\n  writeColor,\n  writeDouble,\n  writeNull,\n  writeUnsigned8,\n  writeUnsignedInteger,\n} from '../nolimits-stream';\n\nexport type StationSection = ReturnType<typeof readStationSection>;\n\nexport const readStationSection = (stream: NoLimitsStream) => {\n  const useTransportDevice = readBoolean(stream);\n\n  const transportTransportType = readUnsigned8(stream); // Transport::TransportType\n  const transportSpeed = readDouble(stream);\n  const transportAcceleration = readDouble(stream);\n  const transportDeceleration = readDouble(stream);\n\n  const brakeDeceleration = readDouble(stream);\n\n  const waitTimeAverage = readDouble(stream);\n  const waitTimeMinimum = readDouble(stream);\n  const waitTimeMaximum = readDouble(stream);\n  const waitTimeDeviation = readDouble(stream);\n\n  const transportLaunch = readBoolean(stream);\n  const transportLaunchAcceleration = readDouble(stream);\n  const transportLaunchMaxSpeed = readDouble(stream);\n\n  const unloadingOnly = readBoolean(stream);\n\n  readNull(stream, 3);\n\n  const passes = readUnsigned8(stream);\n  const shuttleBackwardsStart = readBoolean(stream);\n  const stationNumber = readUnsignedInteger(stream);\n\n  readNull(stream, 3);\n\n  const numSynchronizeDispatchWith = readUnsigned8(stream);\n  const synchronizeDispatchWith: number[] = [];\n\n  for (let i = 0; i < numSynchronizeDispatchWith; i++) {\n    synchronizeDispatchWith.push(readUnsignedInteger(stream));\n  }\n\n  const extraBlockLength = readDouble(stream);\n\n  const brakeType = readUnsigned8(stream); // Brake::BrakeType\n  const gateDirection = readUnsigned8(stream); // Station::GateDirection\n  const display = readUnsigned8(stream); // Station::Display\n  const entranceStairs = readUnsigned8(stream); // Station::Stairs\n  const exitStairs = readUnsigned8(stream); // Station::Stairs\n\n  readNull(stream, 1);\n\n  const gatesColor = readColor(stream);\n  const railingsColor = readColor(stream);\n  const structureColor = readColor(stream);\n\n  readNull(stream, 142);\n\n  return {\n    useTransportDevice,\n    transportDevice: {\n      transportType: transportTransportType,\n      speed: transportSpeed,\n      acceleration: transportAcceleration,\n      deceleration: transportDeceleration,\n      launch: transportLaunch,\n      launchAcceleration: transportLaunchAcceleration,\n      launchMaxSpeed: transportLaunchMaxSpeed,\n    },\n    brakeDevice: {\n      deceleration: brakeDeceleration,\n      brakeType,\n    },\n    waitTime: {\n      average: waitTimeAverage,\n      minimum: waitTimeMinimum,\n      maximum: waitTimeMaximum,\n      deviation: waitTimeDeviation,\n      synchronizeDispatchWith,\n    },\n    unloadingOnly,\n    passes,\n    shuttleBackwardsStart,\n    stationNumber,\n    extraBlockLength,\n    gateDirection,\n    display,\n    entranceStairs,\n    exitStairs,\n    gatesColor,\n    railingsColor,\n    structureColor,\n  };\n};\n\nexport const writeStationSection = (\n  stream: NoLimitsStream,\n  station: StationSection,\n): void => {\n  writeBoolean(stream, station.useTransportDevice);\n\n  writeUnsigned8(stream, station.transportDevice.transportType);\n  writeDouble(stream, station.transportDevice.speed);\n  writeDouble(stream, station.transportDevice.acceleration);\n  writeDouble(stream, station.transportDevice.deceleration);\n\n  writeDouble(stream, station.brakeDevice.deceleration);\n\n  writeDouble(stream, station.waitTime.average);\n  writeDouble(stream, station.waitTime.minimum);\n  writeDouble(stream, station.waitTime.maximum);\n  writeDouble(stream, station.waitTime.deviation);\n\n  writeBoolean(stream, station.transportDevice.launch);\n  writeDouble(stream, station.transportDevice.launchAcceleration);\n  writeDouble(stream, station.transportDevice.launchMaxSpeed);\n\n  writeBoolean(stream, station.unloadingOnly);\n\n  writeNull(stream, 3);\n\n  writeUnsigned8(stream, station.passes);\n  writeBoolean(stream, station.shuttleBackwardsStart);\n  writeUnsignedInteger(stream, station.stationNumber);\n\n  writeNull(stream, 3);\n\n  writeUnsigned8(\n    stream,\n    station.waitTime.synchronizeDispatchWith.length,\n  );\n  for (const id of station.waitTime.synchronizeDispatchWith) {\n    writeUnsignedInteger(stream, id);\n  }\n\n  writeDouble(stream, station.extraBlockLength);\n\n  writeUnsigned8(stream, station.brakeDevice.brakeType);\n  writeUnsigned8(stream, station.gateDirection);\n  writeUnsigned8(stream, station.display);\n  writeUnsigned8(stream, station.entranceStairs);\n  writeUnsigned8(stream, station.exitStairs);\n\n  writeNull(stream, 1);\n\n  writeColor(stream, station.gatesColor);\n  writeColor(stream, station.railingsColor);\n  writeColor(stream, station.structureColor);\n\n  writeNull(stream, 142);\n};\n",
    "functions": {},
    "types": {
      "StationSection": "type StationSection = ReturnType<typeof readStationSection>;"
    },
    "variables": {
      "readStationSection": "const readStationSection = (stream: NoLimitsStream) => {\n  const useTransportDevice = readBoolean(stream);\n\n  const transportTransportType = readUnsigned8(stream); // Transport::TransportType\n  const transportSpeed = readDouble(stream);\n  const transportAcceleration = readDouble(stream);\n  const transportDeceleration = readDouble(stream);\n\n  const brakeDeceleration = readDouble(stream);\n\n  const waitTimeAverage = readDouble(stream);\n  const waitTimeMinimum = readDouble(stream);\n  const waitTimeMaximum = readDouble(stream);\n  const waitTimeDeviation = readDouble(stream);\n\n  const transportLaunch = readBoolean(stream);\n  const transportLaunchAcceleration = readDouble(stream);\n  const transportLaunchMaxSpeed = readDouble(stream);\n\n  const unloadingOnly = readBoolean(stream);\n\n  readNull(stream, 3);\n\n  const passes = readUnsigned8(stream);\n  const shuttleBackwardsStart = readBoolean(stream);\n  const stationNumber = readUnsignedInteger(stream);\n\n  readNull(stream, 3);\n\n  const numSynchronizeDispatchWith = readUnsigned8(stream);\n  const synchronizeDispatchWith: number[] = [];\n\n  for (let i = 0; i < numSynchronizeDispatchWith; i++) {\n    synchronizeDispatchWith.push(readUnsignedInteger(stream));\n  }\n\n  const extraBlockLength = readDouble(stream);\n\n  const brakeType = readUnsigned8(stream); // Brake::BrakeType\n  const gateDirection = readUnsigned8(stream); // Station::GateDirection\n  const display = readUnsigned8(stream); // Station::Display\n  const entranceStairs = readUnsigned8(stream); // Station::Stairs\n  const exitStairs = readUnsigned8(stream); // Station::Stairs\n\n  readNull(stream, 1);\n\n  const gatesColor = readColor(stream);\n  const railingsColor = readColor(stream);\n  const structureColor = readColor(stream);\n\n  readNull(stream, 142);\n\n  return {\n    useTransportDevice,\n    transportDevice: {\n      transportType: transportTransportType,\n      speed: transportSpeed,\n      acceleration: transportAcceleration,\n      deceleration: transportDeceleration,\n      launch: transportLaunch,\n      launchAcceleration: transportLaunchAcceleration,\n      launchMaxSpeed: transportLaunchMaxSpeed,\n    },\n    brakeDevice: {\n      deceleration: brakeDeceleration,\n      brakeType,\n    },\n    waitTime: {\n      average: waitTimeAverage,\n      minimum: waitTimeMinimum,\n      maximum: waitTimeMaximum,\n      deviation: waitTimeDeviation,\n      synchronizeDispatchWith,\n    },\n    unloadingOnly,\n    passes,\n    shuttleBackwardsStart,\n    stationNumber,\n    extraBlockLength,\n    gateDirection,\n    display,\n    entranceStairs,\n    exitStairs,\n    gatesColor,\n    railingsColor,\n    structureColor,\n  };\n};",
      "writeStationSection": "const writeStationSection = (\n  stream: NoLimitsStream,\n  station: StationSection,\n): void => {\n  writeBoolean(stream, station.useTransportDevice);\n\n  writeUnsigned8(stream, station.transportDevice.transportType);\n  writeDouble(stream, station.transportDevice.speed);\n  writeDouble(stream, station.transportDevice.acceleration);\n  writeDouble(stream, station.transportDevice.deceleration);\n\n  writeDouble(stream, station.brakeDevice.deceleration);\n\n  writeDouble(stream, station.waitTime.average);\n  writeDouble(stream, station.waitTime.minimum);\n  writeDouble(stream, station.waitTime.maximum);\n  writeDouble(stream, station.waitTime.deviation);\n\n  writeBoolean(stream, station.transportDevice.launch);\n  writeDouble(stream, station.transportDevice.launchAcceleration);\n  writeDouble(stream, station.transportDevice.launchMaxSpeed);\n\n  writeBoolean(stream, station.unloadingOnly);\n\n  writeNull(stream, 3);\n\n  writeUnsigned8(stream, station.passes);\n  writeBoolean(stream, station.shuttleBackwardsStart);\n  writeUnsignedInteger(stream, station.stationNumber);\n\n  writeNull(stream, 3);\n\n  writeUnsigned8(\n    stream,\n    station.waitTime.synchronizeDispatchWith.length,\n  );\n  for (const id of station.waitTime.synchronizeDispatchWith) {\n    writeUnsignedInteger(stream, id);\n  }\n\n  writeDouble(stream, station.extraBlockLength);\n\n  writeUnsigned8(stream, station.brakeDevice.brakeType);\n  writeUnsigned8(stream, station.gateDirection);\n  writeUnsigned8(stream, station.display);\n  writeUnsigned8(stream, station.entranceStairs);\n  writeUnsigned8(stream, station.exitStairs);\n\n  writeNull(stream, 1);\n\n  writeColor(stream, station.gatesColor);\n  writeColor(stream, station.railingsColor);\n  writeColor(stream, station.structureColor);\n\n  writeNull(stream, 142);\n};"
    }
  },
  "src/helper/nl2park/section/storage-section.ts": {
    "source": "import {\n  NoLimitsStream,\n  readBoolean,\n  readColor,\n  readNull,\n  readUnsigned8,\n  writeBoolean,\n  writeColor,\n  writeNull,\n  writeUnsigned8,\n} from '../nolimits-stream';\n\nexport type StorageSection = ReturnType<typeof readStorageSection>;\n\nexport const readStorageSection = (stream: NoLimitsStream) => {\n  const enableTransportDevice = readBoolean(stream);\n  const transportType = readUnsigned8(stream); // Transport::TransportType\n  const building = readUnsigned8(stream); // Storage::Building\n\n  const roofColor = readColor(stream);\n  const sideColor = readColor(stream);\n  const frameColor = readColor(stream);\n\n  readNull(stream, 20);\n\n  return {\n    enableTransportDevice,\n    transportType,\n    building,\n    roofColor,\n    sideColor,\n    frameColor,\n  };\n};\n\nexport const writeStorageSection = (\n  stream: NoLimitsStream,\n  storage: StorageSection,\n): void => {\n  writeBoolean(stream, storage.enableTransportDevice);\n  writeUnsigned8(stream, storage.transportType);\n  writeUnsigned8(stream, storage.building);\n\n  writeColor(stream, storage.roofColor);\n  writeColor(stream, storage.sideColor);\n  writeColor(stream, storage.frameColor);\n\n  writeNull(stream, 20);\n};\n",
    "functions": {},
    "types": {
      "StorageSection": "type StorageSection = ReturnType<typeof readStorageSection>;"
    },
    "variables": {
      "readStorageSection": "const readStorageSection = (stream: NoLimitsStream) => {\n  const enableTransportDevice = readBoolean(stream);\n  const transportType = readUnsigned8(stream); // Transport::TransportType\n  const building = readUnsigned8(stream); // Storage::Building\n\n  const roofColor = readColor(stream);\n  const sideColor = readColor(stream);\n  const frameColor = readColor(stream);\n\n  readNull(stream, 20);\n\n  return {\n    enableTransportDevice,\n    transportType,\n    building,\n    roofColor,\n    sideColor,\n    frameColor,\n  };\n};",
      "writeStorageSection": "const writeStorageSection = (\n  stream: NoLimitsStream,\n  storage: StorageSection,\n): void => {\n  writeBoolean(stream, storage.enableTransportDevice);\n  writeUnsigned8(stream, storage.transportType);\n  writeUnsigned8(stream, storage.building);\n\n  writeColor(stream, storage.roofColor);\n  writeColor(stream, storage.sideColor);\n  writeColor(stream, storage.frameColor);\n\n  writeNull(stream, 20);\n};"
    }
  },
  "src/helper/nl2park/section/transport-section.ts": {
    "source": "import {\n  NoLimitsStream,\n  readBoolean,\n  readDouble,\n  readNull,\n  readUnsigned8,\n  readUnsignedInteger,\n  writeBoolean,\n  writeDouble,\n  writeNull,\n  writeUnsigned8,\n  writeUnsignedInteger,\n} from '../nolimits-stream';\n\nexport type TransportSection = ReturnType<\n  typeof readTransportSection\n>;\n\nexport const readTransportSection = (stream: NoLimitsStream) => {\n  const transportType = readUnsigned8(stream); // Transport::TransportType\n  const speed = readDouble(stream);\n  const acceleration = readDouble(stream);\n  const deceleration = readDouble(stream);\n  const speedingUpPasses = readUnsignedInteger(stream);\n  const speedingDown = readBoolean(stream);\n  const minSpeed = readDouble(stream);\n\n  readNull(stream, 26);\n\n  return {\n    transportType,\n    speed,\n    acceleration,\n    deceleration,\n    speedingUpPasses,\n    speedingDown,\n    minSpeed,\n  };\n};\n\nexport const writeTransportSection = (\n  stream: NoLimitsStream,\n  transport: TransportSection,\n): void => {\n  writeUnsigned8(stream, transport.transportType);\n  writeDouble(stream, transport.speed);\n  writeDouble(stream, transport.acceleration);\n  writeDouble(stream, transport.deceleration);\n  writeUnsignedInteger(stream, transport.speedingUpPasses);\n  writeBoolean(stream, transport.speedingDown);\n  writeDouble(stream, transport.minSpeed);\n\n  writeNull(stream, 26);\n};\n",
    "functions": {},
    "types": {
      "TransportSection": "type TransportSection = ReturnType<\n  typeof readTransportSection\n>;"
    },
    "variables": {
      "readTransportSection": "const readTransportSection = (stream: NoLimitsStream) => {\n  const transportType = readUnsigned8(stream); // Transport::TransportType\n  const speed = readDouble(stream);\n  const acceleration = readDouble(stream);\n  const deceleration = readDouble(stream);\n  const speedingUpPasses = readUnsignedInteger(stream);\n  const speedingDown = readBoolean(stream);\n  const minSpeed = readDouble(stream);\n\n  readNull(stream, 26);\n\n  return {\n    transportType,\n    speed,\n    acceleration,\n    deceleration,\n    speedingUpPasses,\n    speedingDown,\n    minSpeed,\n  };\n};",
      "writeTransportSection": "const writeTransportSection = (\n  stream: NoLimitsStream,\n  transport: TransportSection,\n): void => {\n  writeUnsigned8(stream, transport.transportType);\n  writeDouble(stream, transport.speed);\n  writeDouble(stream, transport.acceleration);\n  writeDouble(stream, transport.deceleration);\n  writeUnsignedInteger(stream, transport.speedingUpPasses);\n  writeBoolean(stream, transport.speedingDown);\n  writeDouble(stream, transport.minSpeed);\n\n  writeNull(stream, 26);\n};"
    }
  },
  "src/helper/nl2park/track/custom-track.ts": {
    "source": "import { sortBy } from 'lodash';\n\nimport {\n  makeChunkReader,\n  NoLimitsStream,\n  readBoolean,\n  readChunks,\n  readDouble,\n  readDoubleVector4,\n  readInteger,\n  readNull,\n  writeBoolean,\n  writeChunk,\n  writeDouble,\n  writeDoubleVector4,\n  writeNull,\n  writeUnsignedInteger,\n} from '../nolimits-stream';\nimport {\n  readSection,\n  Section,\n  writeSection,\n} from '../section/section';\nimport {\n  Parameter4dPoint,\n  readParameter4DPoint,\n  writeParameter4DPoint,\n} from './parameter-4d-point';\nimport {\n  readRollPoint,\n  RollPoint,\n  writeRollPoint,\n} from './roll-point';\nimport { readSegment, Segment, writeSegment } from './segment';\nimport {\n  readSeparatorPoint,\n  writeSeparatorPoint,\n} from './separator-point';\nimport {\n  readTriggerPoint,\n  TriggerPoint,\n  writeTriggerPoint,\n} from './trigger-point';\n\nexport type TrackPoint =\n  | RollPoint\n  | TriggerPoint\n  | ReturnType<typeof readSeparatorPoint>\n  | Parameter4dPoint\n  | { pointType: 'none'; position: number };\n\nexport type CustomTrack = ReturnType<typeof readCustomTrack>;\n\nexport const readCustomTrack = (stream: NoLimitsStream) => {\n  const closed = readBoolean(stream);\n  const startRoll = {\n    roll: readDouble(stream),\n    vertical: readBoolean(stream),\n  };\n  const endRoll = {\n    roll: readDouble(stream),\n    vertical: readBoolean(stream),\n  };\n\n  readNull(stream, 53);\n\n  const numberOfControlPoints = readInteger(stream);\n\n  let points: Array<TrackPoint> = [];\n\n  let segment: Segment | undefined;\n  let section: Section | undefined;\n  const vertices: Array<{\n    position: [number, number, number, number];\n    locked: boolean;\n    strict: boolean;\n  }> = [];\n\n  for (let i = 0; i < numberOfControlPoints; i++) {\n    vertices.push({\n      position: readDoubleVector4(stream),\n      locked: readBoolean(stream),\n      strict: readBoolean(stream),\n    });\n    readNull(stream, 22);\n  }\n\n  readNull(stream, 60);\n\n  readChunks(\n    [\n      makeChunkReader(readRollPoint, 'ROLL', (r) => points.push(r)),\n      makeChunkReader(readTriggerPoint, 'TTRG', (t) =>\n        points.push(t),\n      ),\n      makeChunkReader(readSeparatorPoint, 'SEPA', (s) =>\n        points.push(s),\n      ),\n      makeChunkReader(readParameter4DPoint, '4DPM', (p) =>\n        points.push(p),\n      ),\n      makeChunkReader(readSegment, 'SEGM', (s) => (segment = s)),\n      makeChunkReader(readSection, 'SECT', (s) => (section = s)),\n    ],\n    stream,\n  );\n\n  return {\n    closed,\n    vertices,\n    segment,\n    section,\n    points,\n    startRoll,\n    endRoll,\n  };\n};\n\nexport const writeCustomTrack = (\n  stream: NoLimitsStream,\n  track: CustomTrack,\n): void => {\n  writeBoolean(stream, track.closed);\n\n  writeDouble(stream, track.startRoll.roll);\n  writeBoolean(stream, track.startRoll.vertical);\n\n  writeDouble(stream, track.endRoll.roll);\n  writeBoolean(stream, track.endRoll.vertical);\n\n  writeNull(stream, 53);\n\n  writeUnsignedInteger(stream, track.vertices.length);\n\n  for (const v of track.vertices) {\n    writeDoubleVector4(stream, v.position);\n    writeBoolean(stream, v.locked);\n    writeBoolean(stream, v.strict);\n    writeNull(stream, 22);\n  }\n\n  writeNull(stream, 60);\n\n  for (const p of sortBy(track.points, 'pointType')) {\n    switch (p.pointType) {\n      case 'roll':\n        writeChunk(stream, 'ROLL', (s) => writeRollPoint(s, p));\n        break;\n\n      case 'trigger':\n        writeChunk(stream, 'TTRG', (s) => writeTriggerPoint(s, p));\n        break;\n\n      case 'separator':\n        writeChunk(stream, 'SEPA', (s) => writeSeparatorPoint(s, p));\n        break;\n\n      case 'parameter4D':\n        writeChunk(stream, '4DPM', (s) =>\n          writeParameter4DPoint(s, p),\n        );\n        break;\n    }\n  }\n\n  writeChunk(stream, 'SEGM', (s) => {\n    if (!track.segment) return;\n    writeSegment(s, track.segment);\n  });\n\n  writeChunk(stream, 'SECT', (s) => {\n    if (!track.section) return;\n    writeSection(s, track.section);\n  });\n};\n",
    "functions": {},
    "types": {
      "TrackPoint": "type TrackPoint =\n  | RollPoint\n  | TriggerPoint\n  | ReturnType<typeof readSeparatorPoint>\n  | Parameter4dPoint\n  | { pointType: 'none'; position: number };",
      "CustomTrack": "type CustomTrack = ReturnType<typeof readCustomTrack>;"
    },
    "variables": {
      "readCustomTrack": "const readCustomTrack = (stream: NoLimitsStream) => {\n  const closed = readBoolean(stream);\n  const startRoll = {\n    roll: readDouble(stream),\n    vertical: readBoolean(stream),\n  };\n  const endRoll = {\n    roll: readDouble(stream),\n    vertical: readBoolean(stream),\n  };\n\n  readNull(stream, 53);\n\n  const numberOfControlPoints = readInteger(stream);\n\n  let points: Array<TrackPoint> = [];\n\n  let segment: Segment | undefined;\n  let section: Section | undefined;\n  const vertices: Array<{\n    position: [number, number, number, number];\n    locked: boolean;\n    strict: boolean;\n  }> = [];\n\n  for (let i = 0; i < numberOfControlPoints; i++) {\n    vertices.push({\n      position: readDoubleVector4(stream),\n      locked: readBoolean(stream),\n      strict: readBoolean(stream),\n    });\n    readNull(stream, 22);\n  }\n\n  readNull(stream, 60);\n\n  readChunks(\n    [\n      makeChunkReader(readRollPoint, 'ROLL', (r) => points.push(r)),\n      makeChunkReader(readTriggerPoint, 'TTRG', (t) =>\n        points.push(t),\n      ),\n      makeChunkReader(readSeparatorPoint, 'SEPA', (s) =>\n        points.push(s),\n      ),\n      makeChunkReader(readParameter4DPoint, '4DPM', (p) =>\n        points.push(p),\n      ),\n      makeChunkReader(readSegment, 'SEGM', (s) => (segment = s)),\n      makeChunkReader(readSection, 'SECT', (s) => (section = s)),\n    ],\n    stream,\n  );\n\n  return {\n    closed,\n    vertices,\n    segment,\n    section,\n    points,\n    startRoll,\n    endRoll,\n  };\n};",
      "writeCustomTrack": "const writeCustomTrack = (\n  stream: NoLimitsStream,\n  track: CustomTrack,\n): void => {\n  writeBoolean(stream, track.closed);\n\n  writeDouble(stream, track.startRoll.roll);\n  writeBoolean(stream, track.startRoll.vertical);\n\n  writeDouble(stream, track.endRoll.roll);\n  writeBoolean(stream, track.endRoll.vertical);\n\n  writeNull(stream, 53);\n\n  writeUnsignedInteger(stream, track.vertices.length);\n\n  for (const v of track.vertices) {\n    writeDoubleVector4(stream, v.position);\n    writeBoolean(stream, v.locked);\n    writeBoolean(stream, v.strict);\n    writeNull(stream, 22);\n  }\n\n  writeNull(stream, 60);\n\n  for (const p of sortBy(track.points, 'pointType')) {\n    switch (p.pointType) {\n      case 'roll':\n        writeChunk(stream, 'ROLL', (s) => writeRollPoint(s, p));\n        break;\n\n      case 'trigger':\n        writeChunk(stream, 'TTRG', (s) => writeTriggerPoint(s, p));\n        break;\n\n      case 'separator':\n        writeChunk(stream, 'SEPA', (s) => writeSeparatorPoint(s, p));\n        break;\n\n      case 'parameter4D':\n        writeChunk(stream, '4DPM', (s) =>\n          writeParameter4DPoint(s, p),\n        );\n        break;\n    }\n  }\n\n  writeChunk(stream, 'SEGM', (s) => {\n    if (!track.segment) return;\n    writeSegment(s, track.segment);\n  });\n\n  writeChunk(stream, 'SECT', (s) => {\n    if (!track.section) return;\n    writeSection(s, track.section);\n  });\n};"
    }
  },
  "src/helper/nl2park/track/parameter-4d-point.ts": {
    "source": "import {\n  NoLimitsStream,\n  readDouble,\n  readNull,\n  writeDouble,\n  writeNull,\n} from '../nolimits-stream';\n\nexport type Parameter4dPoint = ReturnType<\n  typeof readParameter4DPoint\n>;\n\nexport const readParameter4DPoint = (stream: NoLimitsStream) => {\n  const position = readDouble(stream);\n  const angle = readDouble(stream);\n\n  readNull(stream, 20);\n\n  return {\n    pointType: 'parameter4D' as const,\n    position,\n    angle,\n  };\n};\n\nexport const writeParameter4DPoint = (\n  stream: NoLimitsStream,\n  parameter: Parameter4dPoint,\n): void => {\n  writeDouble(stream, parameter.position);\n  writeDouble(stream, parameter.angle);\n\n  writeNull(stream, 20);\n};\n",
    "functions": {},
    "types": {
      "Parameter4dPoint": "type Parameter4dPoint = ReturnType<\n  typeof readParameter4DPoint\n>;"
    },
    "variables": {
      "readParameter4DPoint": "const readParameter4DPoint = (stream: NoLimitsStream) => {\n  const position = readDouble(stream);\n  const angle = readDouble(stream);\n\n  readNull(stream, 20);\n\n  return {\n    pointType: 'parameter4D' as const,\n    position,\n    angle,\n  };\n};",
      "writeParameter4DPoint": "const writeParameter4DPoint = (\n  stream: NoLimitsStream,\n  parameter: Parameter4dPoint,\n): void => {\n  writeDouble(stream, parameter.position);\n  writeDouble(stream, parameter.angle);\n\n  writeNull(stream, 20);\n};"
    }
  },
  "src/helper/nl2park/track/roll-point.ts": {
    "source": "import {\n  NoLimitsStream,\n  readBoolean,\n  readDouble,\n  writeBoolean,\n  writeDouble,\n} from '../nolimits-stream';\nimport { TrackPoint } from './custom-track';\n\nexport type RollPoint = ReturnType<typeof readRollPoint>;\n\nexport const readRollPoint = (stream: NoLimitsStream) => {\n  return {\n    pointType: 'roll' as const,\n    position: readDouble(stream),\n    roll: readDouble(stream),\n    vertical: readBoolean(stream),\n    strict: readBoolean(stream),\n  };\n};\n\nexport const writeRollPoint = (\n  stream: NoLimitsStream,\n  point: RollPoint,\n): void => {\n  writeDouble(stream, point.position);\n  writeDouble(stream, point.roll);\n  writeBoolean(stream, point.vertical);\n  writeBoolean(stream, point.strict);\n};\n\nexport const isRollPoint = (p: TrackPoint): p is RollPoint => {\n  return p.pointType === 'roll';\n};\n",
    "functions": {},
    "types": {
      "RollPoint": "type RollPoint = ReturnType<typeof readRollPoint>;"
    },
    "variables": {
      "readRollPoint": "const readRollPoint = (stream: NoLimitsStream) => {\n  return {\n    pointType: 'roll' as const,\n    position: readDouble(stream),\n    roll: readDouble(stream),\n    vertical: readBoolean(stream),\n    strict: readBoolean(stream),\n  };\n};",
      "writeRollPoint": "const writeRollPoint = (\n  stream: NoLimitsStream,\n  point: RollPoint,\n): void => {\n  writeDouble(stream, point.position);\n  writeDouble(stream, point.roll);\n  writeBoolean(stream, point.vertical);\n  writeBoolean(stream, point.strict);\n};",
      "isRollPoint": "const isRollPoint = (p: TrackPoint): p is RollPoint => {\n  return p.pointType === 'roll';\n};"
    }
  },
  "src/helper/nl2park/track/segment.ts": {
    "source": "import {\n  NoLimitsStream,\n  readBoolean,\n  readColor,\n  readNull,\n  readUnsigned8,\n  writeBoolean,\n  writeColor,\n  writeNull,\n  writeUnsigned8,\n} from '../nolimits-stream';\n\nexport enum Tunnel {\n  None = 0,\n  Steel = 1,\n  Wooden = 2,\n  RoundConcrete = 3,\n  RectangularConcrete = 4,\n  Virtual = 5,\n}\n\nexport enum TieSpacing {\n  LowestStress = 0,\n  LowerStress = 1,\n  LowStress = 2,\n  Normal = 3,\n  HighStress = 4,\n  HighestStress = 5,\n}\n\nexport type Segment = ReturnType<typeof readSegment>;\n\nexport const readSegment = (stream: NoLimitsStream) => {\n  const useMainSpineColor = readBoolean(stream);\n  const railColor = readColor(stream);\n  const crossTiesColor = readColor(stream);\n  const mainSpineColor = readColor(stream);\n\n  const tunnel = readUnsigned8(stream) as Tunnel;\n\n  const leftRailingAndCatwalk = readBoolean(stream);\n  const rightRailingAndCatwalk = readBoolean(stream);\n\n  const spineType = readUnsigned8(stream);\n  const spineColorScheme = readUnsigned8(stream);\n  const invisibleSegment = readBoolean(stream);\n\n  readNull(stream, 2);\n\n  const woodenSupportFlag1 = readUnsigned8(stream);\n  const woodenSupportFlag2 = readUnsigned8(stream);\n\n  const handrailsColor = readColor(stream);\n  const catwalksColor = readColor(stream);\n\n  const transparentCatwalks = readBoolean(stream);\n  const useRailsColor = readBoolean(stream);\n  const useCrossTiesColor = readBoolean(stream);\n  const useHandrailsColor = readBoolean(stream);\n  const useCatwalksColor = readBoolean(stream);\n  const useSpineColorScheme = readBoolean(stream);\n\n  const leftRailingLights = readBoolean(stream);\n  const leftRailingLightsColor = readColor(stream);\n\n  const rightRailingLights = readBoolean(stream);\n  const rightRailingLightsColor = readColor(stream);\n\n  readNull(stream, 45);\n\n  return {\n    useMainSpineColor,\n    railColor,\n    crossTiesColor,\n    mainSpineColor,\n    tunnel,\n    leftRailingAndCatwalk,\n    rightRailingAndCatwalk,\n    spineType,\n    spineColorScheme,\n    invisibleSegment,\n    woodenSupport: {\n      flag1: woodenSupportFlag1,\n      flag2: woodenSupportFlag2,\n    },\n    handrailsColor,\n    catwalksColor,\n    transparentCatwalks,\n    useRailsColor,\n    useCrossTiesColor,\n    useHandrailsColor,\n    useCatwalksColor,\n    useSpineColorScheme,\n    leftRailingLights,\n    leftRailingLightsColor,\n    rightRailingLights,\n    rightRailingLightsColor,\n  };\n};\n\nexport const writeSegment = (\n  stream: NoLimitsStream,\n  segment: Segment,\n): void => {\n  writeBoolean(stream, segment.useMainSpineColor);\n  writeColor(stream, segment.railColor);\n  writeColor(stream, segment.crossTiesColor);\n  writeColor(stream, segment.mainSpineColor);\n\n  writeUnsigned8(stream, segment.tunnel);\n\n  writeBoolean(stream, segment.leftRailingAndCatwalk);\n  writeBoolean(stream, segment.rightRailingAndCatwalk);\n\n  writeUnsigned8(stream, segment.spineType);\n  writeUnsigned8(stream, segment.spineColorScheme);\n  writeBoolean(stream, segment.invisibleSegment);\n\n  writeNull(stream, 2);\n\n  writeUnsigned8(stream, segment.woodenSupport.flag1);\n  writeUnsigned8(stream, segment.woodenSupport.flag2);\n\n  writeColor(stream, segment.handrailsColor);\n  writeColor(stream, segment.catwalksColor);\n\n  writeBoolean(stream, segment.transparentCatwalks);\n  writeBoolean(stream, segment.useRailsColor);\n  writeBoolean(stream, segment.useCrossTiesColor);\n  writeBoolean(stream, segment.useHandrailsColor);\n  writeBoolean(stream, segment.useCatwalksColor);\n  writeBoolean(stream, segment.useSpineColorScheme);\n\n  writeBoolean(stream, segment.leftRailingLights);\n  writeColor(stream, segment.leftRailingLightsColor);\n\n  writeBoolean(stream, segment.rightRailingLights);\n  writeColor(stream, segment.rightRailingLightsColor);\n\n  writeNull(stream, 45);\n};\n",
    "functions": {},
    "types": {
      "Segment": "type Segment = ReturnType<typeof readSegment>;"
    },
    "variables": {
      "readSegment": "const readSegment = (stream: NoLimitsStream) => {\n  const useMainSpineColor = readBoolean(stream);\n  const railColor = readColor(stream);\n  const crossTiesColor = readColor(stream);\n  const mainSpineColor = readColor(stream);\n\n  const tunnel = readUnsigned8(stream) as Tunnel;\n\n  const leftRailingAndCatwalk = readBoolean(stream);\n  const rightRailingAndCatwalk = readBoolean(stream);\n\n  const spineType = readUnsigned8(stream);\n  const spineColorScheme = readUnsigned8(stream);\n  const invisibleSegment = readBoolean(stream);\n\n  readNull(stream, 2);\n\n  const woodenSupportFlag1 = readUnsigned8(stream);\n  const woodenSupportFlag2 = readUnsigned8(stream);\n\n  const handrailsColor = readColor(stream);\n  const catwalksColor = readColor(stream);\n\n  const transparentCatwalks = readBoolean(stream);\n  const useRailsColor = readBoolean(stream);\n  const useCrossTiesColor = readBoolean(stream);\n  const useHandrailsColor = readBoolean(stream);\n  const useCatwalksColor = readBoolean(stream);\n  const useSpineColorScheme = readBoolean(stream);\n\n  const leftRailingLights = readBoolean(stream);\n  const leftRailingLightsColor = readColor(stream);\n\n  const rightRailingLights = readBoolean(stream);\n  const rightRailingLightsColor = readColor(stream);\n\n  readNull(stream, 45);\n\n  return {\n    useMainSpineColor,\n    railColor,\n    crossTiesColor,\n    mainSpineColor,\n    tunnel,\n    leftRailingAndCatwalk,\n    rightRailingAndCatwalk,\n    spineType,\n    spineColorScheme,\n    invisibleSegment,\n    woodenSupport: {\n      flag1: woodenSupportFlag1,\n      flag2: woodenSupportFlag2,\n    },\n    handrailsColor,\n    catwalksColor,\n    transparentCatwalks,\n    useRailsColor,\n    useCrossTiesColor,\n    useHandrailsColor,\n    useCatwalksColor,\n    useSpineColorScheme,\n    leftRailingLights,\n    leftRailingLightsColor,\n    rightRailingLights,\n    rightRailingLightsColor,\n  };\n};",
      "writeSegment": "const writeSegment = (\n  stream: NoLimitsStream,\n  segment: Segment,\n): void => {\n  writeBoolean(stream, segment.useMainSpineColor);\n  writeColor(stream, segment.railColor);\n  writeColor(stream, segment.crossTiesColor);\n  writeColor(stream, segment.mainSpineColor);\n\n  writeUnsigned8(stream, segment.tunnel);\n\n  writeBoolean(stream, segment.leftRailingAndCatwalk);\n  writeBoolean(stream, segment.rightRailingAndCatwalk);\n\n  writeUnsigned8(stream, segment.spineType);\n  writeUnsigned8(stream, segment.spineColorScheme);\n  writeBoolean(stream, segment.invisibleSegment);\n\n  writeNull(stream, 2);\n\n  writeUnsigned8(stream, segment.woodenSupport.flag1);\n  writeUnsigned8(stream, segment.woodenSupport.flag2);\n\n  writeColor(stream, segment.handrailsColor);\n  writeColor(stream, segment.catwalksColor);\n\n  writeBoolean(stream, segment.transparentCatwalks);\n  writeBoolean(stream, segment.useRailsColor);\n  writeBoolean(stream, segment.useCrossTiesColor);\n  writeBoolean(stream, segment.useHandrailsColor);\n  writeBoolean(stream, segment.useCatwalksColor);\n  writeBoolean(stream, segment.useSpineColorScheme);\n\n  writeBoolean(stream, segment.leftRailingLights);\n  writeColor(stream, segment.leftRailingLightsColor);\n\n  writeBoolean(stream, segment.rightRailingLights);\n  writeColor(stream, segment.rightRailingLightsColor);\n\n  writeNull(stream, 45);\n};"
    }
  },
  "src/helper/nl2park/track/separator-point.ts": {
    "source": "import {\n  makeChunkReader,\n  NoLimitsStream,\n  readChunks,\n  readDouble,\n  writeChunk,\n  writeDouble,\n} from '../nolimits-stream';\nimport {\n  readSection,\n  Section,\n  writeSection,\n} from '../section/section';\nimport { TrackPoint } from './custom-track';\nimport { readSegment, Segment, writeSegment } from './segment';\n\nexport type SeparatorPoint = ReturnType<typeof readSeparatorPoint>;\n\nexport const readSeparatorPoint = (stream: NoLimitsStream) => {\n  const position = readDouble(stream);\n\n  let segment: Segment | undefined;\n  let section: Section | undefined;\n\n  readChunks(\n    [\n      makeChunkReader(readSegment, 'SEGM', (s) => {\n        segment = s;\n      }),\n      makeChunkReader(readSection, 'SECT', (s) => (section = s)),\n    ],\n    stream,\n  );\n\n  return {\n    pointType: 'separator' as const,\n    position,\n    segment,\n    section,\n  };\n};\n\nexport const writeSeparatorPoint = (\n  stream: NoLimitsStream,\n  separator: SeparatorPoint,\n): void => {\n  writeDouble(stream, separator.position);\n\n  writeChunk(stream, 'SEGM', (s) => {\n    if (!separator.segment) return;\n    writeSegment(s, separator.segment);\n  });\n\n  writeChunk(stream, 'SECT', (s) => {\n    if (!separator.section) return;\n    writeSection(s, separator.section);\n  });\n};\n\nexport const isSeparatorPoint = (\n  p: TrackPoint,\n): p is SeparatorPoint => {\n  return p.pointType === 'separator';\n};\n",
    "functions": {},
    "types": {
      "SeparatorPoint": "type SeparatorPoint = ReturnType<typeof readSeparatorPoint>;"
    },
    "variables": {
      "readSeparatorPoint": "const readSeparatorPoint = (stream: NoLimitsStream) => {\n  const position = readDouble(stream);\n\n  let segment: Segment | undefined;\n  let section: Section | undefined;\n\n  readChunks(\n    [\n      makeChunkReader(readSegment, 'SEGM', (s) => {\n        segment = s;\n      }),\n      makeChunkReader(readSection, 'SECT', (s) => (section = s)),\n    ],\n    stream,\n  );\n\n  return {\n    pointType: 'separator' as const,\n    position,\n    segment,\n    section,\n  };\n};",
      "writeSeparatorPoint": "const writeSeparatorPoint = (\n  stream: NoLimitsStream,\n  separator: SeparatorPoint,\n): void => {\n  writeDouble(stream, separator.position);\n\n  writeChunk(stream, 'SEGM', (s) => {\n    if (!separator.segment) return;\n    writeSegment(s, separator.segment);\n  });\n\n  writeChunk(stream, 'SECT', (s) => {\n    if (!separator.section) return;\n    writeSection(s, separator.section);\n  });\n};",
      "isSeparatorPoint": "const isSeparatorPoint = (\n  p: TrackPoint,\n): p is SeparatorPoint => {\n  return p.pointType === 'separator';\n};"
    }
  },
  "src/helper/nl2park/track/trigger-point.ts": {
    "source": "import {\n  NoLimitsStream,\n  readDouble,\n  readNull,\n  readString,\n  readUnsigned8,\n  writeDouble,\n  writeNull,\n  writeString,\n  writeUnsigned8,\n} from '../nolimits-stream';\n\nexport enum TriggerTrainEvent {\n  None = 0,\n  UnlockSpinning = 1,\n  LockSpinning = 2,\n  UnlockSwinging = 3,\n  LockSwinging = 4,\n}\n\nexport type TriggerPoint = ReturnType<typeof readTriggerPoint>;\n\nexport const readTriggerPoint = (stream: NoLimitsStream) => {\n  const position = readDouble(stream);\n  const name = readString(stream);\n\n  readNull(stream, 3);\n\n  const trainEvent = readUnsigned8(stream) as TriggerTrainEvent;\n\n  readNull(stream, 26);\n\n  return {\n    pointType: 'trigger' as const,\n    position,\n    name,\n    trainEvent,\n  };\n};\n\nexport const writeTriggerPoint = (\n  stream: NoLimitsStream,\n  trigger: TriggerPoint,\n): void => {\n  writeDouble(stream, trigger.position);\n  writeString(stream, trigger.name);\n  writeNull(stream, 3);\n  writeUnsigned8(stream, trigger.trainEvent);\n  writeNull(stream, 26);\n};\n",
    "functions": {},
    "types": {
      "TriggerPoint": "type TriggerPoint = ReturnType<typeof readTriggerPoint>;"
    },
    "variables": {
      "readTriggerPoint": "const readTriggerPoint = (stream: NoLimitsStream) => {\n  const position = readDouble(stream);\n  const name = readString(stream);\n\n  readNull(stream, 3);\n\n  const trainEvent = readUnsigned8(stream) as TriggerTrainEvent;\n\n  readNull(stream, 26);\n\n  return {\n    pointType: 'trigger' as const,\n    position,\n    name,\n    trainEvent,\n  };\n};",
      "writeTriggerPoint": "const writeTriggerPoint = (\n  stream: NoLimitsStream,\n  trigger: TriggerPoint,\n): void => {\n  writeDouble(stream, trigger.position);\n  writeString(stream, trigger.name);\n  writeNull(stream, 3);\n  writeUnsigned8(stream, trigger.trainEvent);\n  writeNull(stream, 26);\n};"
    }
  },
  "src/helper/nl2park/track/vertex.ts": {
    "source": "import {\n  NoLimitsStream,\n  readBoolean,\n  readDoubleVector4,\n  readNull,\n  writeBoolean,\n  writeDoubleVector4,\n  writeNull,\n} from '../nolimits-stream';\n\nexport type Vertex = ReturnType<typeof readVertex>;\n\nexport const readVertex = (stream: NoLimitsStream) => {\n  const vertex = {\n    position: readDoubleVector4(stream),\n    locked: readBoolean(stream),\n    strict: readBoolean(stream),\n  };\n  readNull(stream, 22);\n  return vertex;\n};\n\nexport const writeVertex = (\n  stream: NoLimitsStream,\n  vertex: Vertex,\n): void => {\n  writeDoubleVector4(stream, vertex.position);\n  writeBoolean(stream, vertex.locked);\n  writeBoolean(stream, vertex.strict);\n  writeNull(stream, 22);\n};\n",
    "functions": {},
    "types": {
      "Vertex": "type Vertex = ReturnType<typeof readVertex>;"
    },
    "variables": {
      "readVertex": "const readVertex = (stream: NoLimitsStream) => {\n  const vertex = {\n    position: readDoubleVector4(stream),\n    locked: readBoolean(stream),\n    strict: readBoolean(stream),\n  };\n  readNull(stream, 22);\n  return vertex;\n};",
      "writeVertex": "const writeVertex = (\n  stream: NoLimitsStream,\n  vertex: Vertex,\n): void => {\n  writeDoubleVector4(stream, vertex.position);\n  writeBoolean(stream, vertex.locked);\n  writeBoolean(stream, vertex.strict);\n  writeNull(stream, 22);\n};"
    }
  },
  "src/content/posts/writing-a-roller-coaster-simulation/evaluating-motion/physics.ts": {
    "source": "export type SimulationState = {\n  velocity: number;\n  distanceTraveled: number;\n};\n\nexport const evaluateMotion = (\n  state: SimulationState,\n  acceleration: number,\n  deltaTime: number,\n): SimulationState => {\n  const velocity = state.velocity + acceleration * deltaTime;\n  const distanceTraveled =\n    state.distanceTraveled + velocity * deltaTime;\n\n  return { velocity, distanceTraveled };\n};\n",
    "functions": {},
    "types": {
      "SimulationState": "type SimulationState = {\n  velocity: number;\n  distanceTraveled: number;\n};"
    },
    "variables": {
      "evaluateMotion": "const evaluateMotion = (\n  state: SimulationState,\n  acceleration: number,\n  deltaTime: number,\n): SimulationState => {\n  const velocity = state.velocity + acceleration * deltaTime;\n  const distanceTraveled =\n    state.distanceTraveled + velocity * deltaTime;\n\n  return { velocity, distanceTraveled };\n};"
    }
  }
}