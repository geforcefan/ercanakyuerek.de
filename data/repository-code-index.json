{
  "src/index.tsx": {
    "source": "import React, { StrictMode } from 'react';\nimport ReactDOM from 'react-dom/client';\nimport { createBrowserRouter, RouterProvider } from 'react-router';\n\nimport { contentComponents } from './helper/render-content-component';\n\nimport { ContentComponent } from './components/ContentComponent';\n\nimport { ContentComponentsListPage } from './pages/ContentComponentsListPage';\n\nimport './themes/hello-friend-ng/assets/scss/main-webpack.scss';\n\nimport { ExperimentScene } from './experiments/Experiment';\nimport { NoLimitsTrackScene } from './experiments/NoLimitsTrack';\n\nexport const router = createBrowserRouter([\n  {\n    path: '/',\n    Component: ContentComponentsListPage,\n  },\n  {\n    path: '/experiment',\n    Component: NoLimitsTrackScene,\n  },\n  {\n    path: '/experiment2',\n    Component: ExperimentScene,\n  },\n  ...contentComponents.keys().map((path: string) => {\n    return {\n      path: '/src/content/' + path.replace('./', ''),\n      Component: () => <ContentComponent path={path} />,\n    };\n  }),\n]);\n\nReactDOM.createRoot(\n  document.getElementById('root') as HTMLElement,\n).render(\n  <StrictMode>\n    <RouterProvider router={router} />\n  </StrictMode>,\n);\n",
    "functions": {},
    "types": {},
    "variables": {
      "router": "const router = createBrowserRouter([\n  {\n    path: '/',\n    Component: ContentComponentsListPage,\n  },\n  {\n    path: '/experiment',\n    Component: NoLimitsTrackScene,\n  },\n  {\n    path: '/experiment2',\n    Component: ExperimentScene,\n  },\n  ...contentComponents.keys().map((path: string) => {\n    return {\n      path: '/src/content/' + path.replace('./', ''),\n      Component: () => <ContentComponent path={path} />,\n    };\n  }),\n]);"
    }
  },
  "src/coaster/b-spline-track.ts": {
    "source": "import { Vector4 } from 'three';\n\nimport { fromPoints as bSplineFromPoints } from '../maths/b-spline';\n\nexport const fromPoints = (\n  points: Vector4[],\n  closed: boolean = false,\n  resolution: number = 20,\n) => {\n  const bSplinePoints: Vector4[] = [...points];\n\n  if (!closed) {\n    const firstPoint = bSplinePoints[0];\n    const lastPoint = bSplinePoints[bSplinePoints.length - 1];\n\n    bSplinePoints.unshift(firstPoint, firstPoint);\n    bSplinePoints.push(lastPoint, lastPoint);\n  } else if (closed && bSplinePoints.length >= 4) {\n    bSplinePoints.unshift(bSplinePoints[bSplinePoints.length - 1]);\n    bSplinePoints.push(bSplinePoints[1]);\n    bSplinePoints.push(bSplinePoints[2]);\n  }\n\n  return bSplineFromPoints(bSplinePoints, resolution);\n};\n",
    "functions": {},
    "types": {},
    "variables": {
      "fromPoints": "const fromPoints = (\n  points: Vector4[],\n  closed: boolean = false,\n  resolution: number = 20,\n) => {\n  const bSplinePoints: Vector4[] = [...points];\n\n  if (!closed) {\n    const firstPoint = bSplinePoints[0];\n    const lastPoint = bSplinePoints[bSplinePoints.length - 1];\n\n    bSplinePoints.unshift(firstPoint, firstPoint);\n    bSplinePoints.push(lastPoint, lastPoint);\n  } else if (closed && bSplinePoints.length >= 4) {\n    bSplinePoints.unshift(bSplinePoints[bSplinePoints.length - 1]);\n    bSplinePoints.push(bSplinePoints[1]);\n    bSplinePoints.push(bSplinePoints[2]);\n  }\n\n  return bSplineFromPoints(bSplinePoints, resolution);\n};"
    }
  },
  "src/coaster/cubic-roll.ts": {
    "source": "import { MathUtils, Vector2 } from 'three';\n\nimport { clampedCubicSplineCurve } from '../maths/cubic';\nimport {\n  arcLengthAtOffset,\n  Curve,\n  emptyCurve,\n  transformationAtArcLength,\n} from '../maths/curve';\nimport { toLeftDirection, toUpDirection } from '../maths/matrix4';\nimport { splitPointsByStrict } from '../helper/strict-point';\n\nexport const fromRollPoints = (\n  curve: Curve,\n  rollPoints: Array<{\n    position: number;\n    roll: number;\n    strict: boolean;\n    vertical: boolean;\n  }>,\n  resolution: number = 20,\n) => {\n  const rollSections = splitPointsByStrict(rollPoints);\n\n  let lastRoll = 0;\n  let offset = 0;\n\n  const rollCurve = emptyCurve();\n\n  for (const sectionRollPoints of rollSections) {\n    const points: Vector2[] = [];\n\n    for (const p of sectionRollPoints) {\n      const arcLength = arcLengthAtOffset(\n        p.position,\n        curve.segmentOffsets,\n      );\n      const matrix = transformationAtArcLength(curve, arcLength);\n\n      let roll = MathUtils.degToRad(p.roll);\n\n      const up = toUpDirection(matrix);\n      const left = toLeftDirection(matrix);\n\n      if (p.vertical) {\n        roll += Math.atan2(left.z, up.z);\n      } else {\n        roll += Math.atan2(left.y, up.y);\n      }\n\n      const deltaRoll = roll - lastRoll;\n      lastRoll = roll;\n\n      if (Math.abs(deltaRoll) >= Math.PI) {\n        offset += deltaRoll > 0 ? -Math.PI * 2 : Math.PI * 2;\n      }\n\n      roll += offset;\n\n      points.push(new Vector2(arcLength, roll));\n    }\n\n    // TODO(ercan.akyuerek): write curve merge utility? or something different, I dont know\n    rollCurve.nodes.push(\n      ...clampedCubicSplineCurve(points, 0, 0, resolution).nodes,\n    );\n  }\n\n  return rollCurve;\n};\n",
    "functions": {},
    "types": {},
    "variables": {
      "fromRollPoints": "const fromRollPoints = (\n  curve: Curve,\n  rollPoints: Array<{\n    position: number;\n    roll: number;\n    strict: boolean;\n    vertical: boolean;\n  }>,\n  resolution: number = 20,\n) => {\n  const rollSections = splitPointsByStrict(rollPoints);\n\n  let lastRoll = 0;\n  let offset = 0;\n\n  const rollCurve = emptyCurve();\n\n  for (const sectionRollPoints of rollSections) {\n    const points: Vector2[] = [];\n\n    for (const p of sectionRollPoints) {\n      const arcLength = arcLengthAtOffset(\n        p.position,\n        curve.segmentOffsets,\n      );\n      const matrix = transformationAtArcLength(curve, arcLength);\n\n      let roll = MathUtils.degToRad(p.roll);\n\n      const up = toUpDirection(matrix);\n      const left = toLeftDirection(matrix);\n\n      if (p.vertical) {\n        roll += Math.atan2(left.z, up.z);\n      } else {\n        roll += Math.atan2(left.y, up.y);\n      }\n\n      const deltaRoll = roll - lastRoll;\n      lastRoll = roll;\n\n      if (Math.abs(deltaRoll) >= Math.PI) {\n        offset += deltaRoll > 0 ? -Math.PI * 2 : Math.PI * 2;\n      }\n\n      roll += offset;\n\n      points.push(new Vector2(arcLength, roll));\n    }\n\n    // TODO(ercan.akyuerek): write curve merge utility? or something different, I dont know\n    rollCurve.nodes.push(\n      ...clampedCubicSplineCurve(points, 0, 0, resolution).nodes,\n    );\n  }\n\n  return rollCurve;\n};"
    }
  },
  "src/coaster/nolimits-csv-track.ts": {
    "source": "import { parse } from 'csv-parse/browser/esm';\nimport { Matrix4, Vector3 } from 'three';\n\nimport {\n  Curve,\n  emptyCurve,\n  insertTransformationMatrix,\n} from '../maths/curve';\n\nexport const fromUrl = async (url: string): Promise<Curve> => {\n  const response = await fetch(url);\n  const data = await response.text();\n\n  return new Promise((resolve, reject) => {\n    parse<{\n      PosX: string;\n      PosY: string;\n      PosZ: string;\n      FrontX: string;\n      FrontY: string;\n      FrontZ: string;\n      LeftX: string;\n      LeftY: string;\n      LeftZ: string;\n      UpX: string;\n      UpY: string;\n      UpZ: string;\n    }>(\n      data,\n      {\n        trim: true,\n        columns: true,\n        skip_empty_lines: true,\n        delimiter: '\\t',\n      },\n      (err, records) => {\n        if (err) reject(err);\n        const curve = emptyCurve();\n        for (const row of records) {\n          insertTransformationMatrix(\n            curve,\n            new Matrix4()\n              .makeBasis(\n                new Vector3(\n                  parseFloat(row.LeftX),\n                  parseFloat(row.LeftY),\n                  parseFloat(row.LeftZ),\n                ),\n                new Vector3(\n                  parseFloat(row.UpX),\n                  parseFloat(row.UpY),\n                  parseFloat(row.UpZ),\n                ),\n                new Vector3(\n                  parseFloat(row.FrontX),\n                  parseFloat(row.FrontY),\n                  parseFloat(row.FrontZ),\n                ),\n              )\n              .setPosition(\n                new Vector3(\n                  parseFloat(row.PosX),\n                  parseFloat(row.PosY),\n                  parseFloat(row.PosZ),\n                ),\n              ),\n          );\n        }\n        resolve(curve);\n      },\n    );\n  });\n};\n",
    "functions": {},
    "types": {},
    "variables": {
      "fromUrl": "const fromUrl = async (url: string): Promise<Curve> => {\n  const response = await fetch(url);\n  const data = await response.text();\n\n  return new Promise((resolve, reject) => {\n    parse<{\n      PosX: string;\n      PosY: string;\n      PosZ: string;\n      FrontX: string;\n      FrontY: string;\n      FrontZ: string;\n      LeftX: string;\n      LeftY: string;\n      LeftZ: string;\n      UpX: string;\n      UpY: string;\n      UpZ: string;\n    }>(\n      data,\n      {\n        trim: true,\n        columns: true,\n        skip_empty_lines: true,\n        delimiter: '\\t',\n      },\n      (err, records) => {\n        if (err) reject(err);\n        const curve = emptyCurve();\n        for (const row of records) {\n          insertTransformationMatrix(\n            curve,\n            new Matrix4()\n              .makeBasis(\n                new Vector3(\n                  parseFloat(row.LeftX),\n                  parseFloat(row.LeftY),\n                  parseFloat(row.LeftZ),\n                ),\n                new Vector3(\n                  parseFloat(row.UpX),\n                  parseFloat(row.UpY),\n                  parseFloat(row.UpZ),\n                ),\n                new Vector3(\n                  parseFloat(row.FrontX),\n                  parseFloat(row.FrontY),\n                  parseFloat(row.FrontZ),\n                ),\n              )\n              .setPosition(\n                new Vector3(\n                  parseFloat(row.PosX),\n                  parseFloat(row.PosY),\n                  parseFloat(row.PosZ),\n                ),\n              ),\n          );\n        }\n        resolve(curve);\n      },\n    );\n  });\n};"
    }
  },
  "src/coaster/nolimits-track.ts": {
    "source": "import { Vector4 } from 'three';\n\nimport { Curve, emptyCurve } from '../maths/curve';\nimport { fromPoints, makeClampedKnots } from '../maths/nurbs';\nimport { splitPointsByStrict } from '../helper/strict-point';\n\nexport const fromVertices = (\n  vertices: Array<{ position: Vector4; strict: boolean }>,\n  closed: boolean = false,\n  resolution: number = 20,\n) => {\n  if (vertices.length < 2) return emptyCurve();\n  const nurbsVertices = [...vertices];\n\n  if (closed) {\n    nurbsVertices.push({\n      position: vertices[0].position,\n      strict: false,\n    });\n  }\n\n  const curve: Curve = emptyCurve();\n  const nurbsSections = splitPointsByStrict(nurbsVertices);\n\n  for (let i = 0; i < nurbsSections.length; i += 1) {\n    const vertices = nurbsSections[i];\n    const lastCurveNode = curve.nodes[curve.nodes.length - 1];\n\n    fromPoints(\n      vertices.map((v) => v.position),\n      makeClampedKnots,\n      curve,\n      resolution,\n      3,\n      (lastCurveNode?.segmentIndex ?? -1) + 1,\n    );\n  }\n\n  return curve;\n};\n",
    "functions": {},
    "types": {},
    "variables": {
      "fromVertices": "const fromVertices = (\n  vertices: Array<{ position: Vector4; strict: boolean }>,\n  closed: boolean = false,\n  resolution: number = 20,\n) => {\n  if (vertices.length < 2) return emptyCurve();\n  const nurbsVertices = [...vertices];\n\n  if (closed) {\n    nurbsVertices.push({\n      position: vertices[0].position,\n      strict: false,\n    });\n  }\n\n  const curve: Curve = emptyCurve();\n  const nurbsSections = splitPointsByStrict(nurbsVertices);\n\n  for (let i = 0; i < nurbsSections.length; i += 1) {\n    const vertices = nurbsSections[i];\n    const lastCurveNode = curve.nodes[curve.nodes.length - 1];\n\n    fromPoints(\n      vertices.map((v) => v.position),\n      makeClampedKnots,\n      curve,\n      resolution,\n      3,\n      (lastCurveNode?.segmentIndex ?? -1) + 1,\n    );\n  }\n\n  return curve;\n};"
    }
  },
  "src/components/Arrow.tsx": {
    "source": "import React from 'react';\nimport { ThreeElements } from '@react-three/fiber';\n\nexport const Arrow = (\n  props: { color?: number } & ThreeElements['mesh'],\n) => {\n  const { color, ...restProps } = props;\n\n  return (\n    <mesh {...restProps}>\n      <coneGeometry args={[0.3, 0.5, 5]} />\n      <meshBasicMaterial color={color} />\n    </mesh>\n  );\n};\n",
    "functions": {},
    "types": {},
    "variables": {
      "Arrow": "const Arrow = (\n  props: { color?: number } & ThreeElements['mesh'],\n) => {\n  const { color, ...restProps } = props;\n\n  return (\n    <mesh {...restProps}>\n      <coneGeometry args={[0.3, 0.5, 5]} />\n      <meshBasicMaterial color={color} />\n    </mesh>\n  );\n};"
    }
  },
  "src/components/ContentComponent.tsx": {
    "source": "import React, { lazy, Suspense, useMemo, useRef } from 'react';\nimport {\n  ArrowsPointingInIcon,\n  ArrowsPointingOutIcon,\n} from '@heroicons/react/24/solid';\nimport { Leva } from 'leva';\nimport { useFullscreen, useToggle } from 'react-use';\n\nimport { numberToHexString } from '../helper/numberToHexString';\nimport { contentComponents } from '../helper/render-content-component';\nimport { useColors } from '../hooks/useColors';\n\nimport { LoadingScreen } from './LoadingScreen';\n\nexport const ContentComponent = ({ path }: { path: string }) => {\n  const colors = useColors();\n  const LazyComponent = useMemo(\n    () =>\n      lazy(async () => {\n        const module = await contentComponents(path);\n        return {\n          default: module.default ?? Object.values(module).pop(),\n        };\n      }),\n    [path],\n  );\n\n  const ref = useRef(null);\n  const [show, toggle] = useToggle(false);\n  // @ts-ignore\n  const isFullscreen = useFullscreen(ref, show, {\n    onClose: () => toggle(false),\n  });\n\n  return (\n    <div ref={ref} className=\"full-screen content-component\">\n      <Suspense fallback={<LoadingScreen />}>\n        <Leva\n          titleBar={{ filter: false, title: false }}\n          theme={{\n            sizes: { rootWidth: '300px' },\n            shadows: {\n              level1: 'none',\n            },\n            colors: {\n              accent2: numberToHexString(colors.highlight),\n              accent1: numberToHexString(colors.highlight),\n              elevation1: '#1b1c1d',\n              elevation2: '#232425',\n              elevation3: numberToHexString(colors.primary),\n            },\n          }}\n        />\n        <LazyComponent />\n      </Suspense>\n      <div className=\"bottom-controls\">\n        <button onClick={() => toggle()}>\n          {!isFullscreen ? (\n            <ArrowsPointingOutIcon />\n          ) : (\n            <ArrowsPointingInIcon />\n          )}\n        </button>\n      </div>\n    </div>\n  );\n};\n",
    "functions": {},
    "types": {},
    "variables": {
      "ContentComponent": "const ContentComponent = ({ path }: { path: string }) => {\n  const colors = useColors();\n  const LazyComponent = useMemo(\n    () =>\n      lazy(async () => {\n        const module = await contentComponents(path);\n        return {\n          default: module.default ?? Object.values(module).pop(),\n        };\n      }),\n    [path],\n  );\n\n  const ref = useRef(null);\n  const [show, toggle] = useToggle(false);\n  // @ts-ignore\n  const isFullscreen = useFullscreen(ref, show, {\n    onClose: () => toggle(false),\n  });\n\n  return (\n    <div ref={ref} className=\"full-screen content-component\">\n      <Suspense fallback={<LoadingScreen />}>\n        <Leva\n          titleBar={{ filter: false, title: false }}\n          theme={{\n            sizes: { rootWidth: '300px' },\n            shadows: {\n              level1: 'none',\n            },\n            colors: {\n              accent2: numberToHexString(colors.highlight),\n              accent1: numberToHexString(colors.highlight),\n              elevation1: '#1b1c1d',\n              elevation2: '#232425',\n              elevation3: numberToHexString(colors.primary),\n            },\n          }}\n        />\n        <LazyComponent />\n      </Suspense>\n      <div className=\"bottom-controls\">\n        <button onClick={() => toggle()}>\n          {!isFullscreen ? (\n            <ArrowsPointingOutIcon />\n          ) : (\n            <ArrowsPointingInIcon />\n          )}\n        </button>\n      </div>\n    </div>\n  );\n};"
    }
  },
  "src/components/Ground.tsx": {
    "source": "import React from 'react';\nimport { ThreeElements } from '@react-three/fiber';\n\nimport { useColors } from '../hooks/useColors';\n\nexport const Ground = (props: ThreeElements['group']) => {\n  const colors = useColors();\n\n  return (\n    <group position={[0, -1, 0]} {...props}>\n      <mesh receiveShadow={true} rotation-x={-Math.PI / 2}>\n        <planeGeometry args={[1000, 1000]} />\n        <meshStandardMaterial\n          dithering={true}\n          color={colors.silent}\n        />\n      </mesh>\n    </group>\n  );\n};\n",
    "functions": {},
    "types": {},
    "variables": {
      "Ground": "const Ground = (props: ThreeElements['group']) => {\n  const colors = useColors();\n\n  return (\n    <group position={[0, -1, 0]} {...props}>\n      <mesh receiveShadow={true} rotation-x={-Math.PI / 2}>\n        <planeGeometry args={[1000, 1000]} />\n        <meshStandardMaterial\n          dithering={true}\n          color={colors.silent}\n        />\n      </mesh>\n    </group>\n  );\n};"
    }
  },
  "src/components/LoadingScreen.tsx": {
    "source": "import React from 'react';\n\nexport const LoadingScreen = () => {\n  return (\n    <div\n      className=\"loading-screen full-screen\"\n      style={{\n        display: 'flex',\n        justifyContent: 'center',\n        alignItems: 'center',\n      }}\n    >\n      <div className={'logo'}>\n        <div className={'logo__cursor'}></div>\n      </div>\n    </div>\n  );\n};\n",
    "functions": {},
    "types": {},
    "variables": {
      "LoadingScreen": "const LoadingScreen = () => {\n  return (\n    <div\n      className=\"loading-screen full-screen\"\n      style={{\n        display: 'flex',\n        justifyContent: 'center',\n        alignItems: 'center',\n      }}\n    >\n      <div className={'logo'}>\n        <div className={'logo__cursor'}></div>\n      </div>\n    </div>\n  );\n};"
    }
  },
  "src/components/MatrixArrowHelper.tsx": {
    "source": "import React from 'react';\nimport { ThreeElements } from '@react-three/fiber';\nimport { Vector3 } from 'three';\n\nexport const MatrixArrowHelper = (props: ThreeElements['group']) => {\n  return (\n    <group matrixAutoUpdate={false} {...props}>\n      <arrowHelper\n        args={[\n          new Vector3(0, 1, 0),\n          new Vector3(0, 0, 0),\n          2,\n          0x00dd00,\n        ]}\n      />\n      <arrowHelper\n        args={[\n          new Vector3(1, 0, 0),\n          new Vector3(0, 0, 0),\n          2,\n          0x0000dd,\n        ]}\n      />\n      <arrowHelper\n        args={[\n          new Vector3(0, 0, 1),\n          new Vector3(0, 0, 0),\n          2,\n          0xdd0000,\n        ]}\n      />\n    </group>\n  );\n};\n",
    "functions": {},
    "types": {},
    "variables": {
      "MatrixArrowHelper": "const MatrixArrowHelper = (props: ThreeElements['group']) => {\n  return (\n    <group matrixAutoUpdate={false} {...props}>\n      <arrowHelper\n        args={[\n          new Vector3(0, 1, 0),\n          new Vector3(0, 0, 0),\n          2,\n          0x00dd00,\n        ]}\n      />\n      <arrowHelper\n        args={[\n          new Vector3(1, 0, 0),\n          new Vector3(0, 0, 0),\n          2,\n          0x0000dd,\n        ]}\n      />\n      <arrowHelper\n        args={[\n          new Vector3(0, 0, 1),\n          new Vector3(0, 0, 0),\n          2,\n          0xdd0000,\n        ]}\n      />\n    </group>\n  );\n};"
    }
  },
  "src/components/PointWithMatrixArrows.tsx": {
    "source": "import React from 'react';\nimport { ThreeElements } from '@react-three/fiber';\n\nimport { useColors } from '../hooks/useColors';\n\nimport { ControlPoint } from './curve/ControlPoint';\nimport { MatrixArrowHelper } from './MatrixArrowHelper';\n\nexport const PointWithMatrixArrows = (\n  props: ThreeElements['group'],\n) => {\n  const colors = useColors();\n\n  return (\n    <group matrixAutoUpdate={false} {...props}>\n      <MatrixArrowHelper />\n      <ControlPoint castShadow={true} color={colors.highlight} />\n    </group>\n  );\n};\n",
    "functions": {},
    "types": {},
    "variables": {
      "PointWithMatrixArrows": "const PointWithMatrixArrows = (\n  props: ThreeElements['group'],\n) => {\n  const colors = useColors();\n\n  return (\n    <group matrixAutoUpdate={false} {...props}>\n      <MatrixArrowHelper />\n      <ControlPoint castShadow={true} color={colors.highlight} />\n    </group>\n  );\n};"
    }
  },
  "src/components/TrainWithPhysics.tsx": {
    "source": "import React from 'react';\nimport { Vector3 } from 'three';\n\nimport { Curve } from '../maths/curve';\nimport { useMotionSimulation } from '../hooks/useMotionSimulation';\n\nimport {\n  CameraView,\n  useCameraViewManager,\n} from './camera/CameraViewManager';\nimport { TransformationMatrixCamera } from './camera/TransformationMatrixCamera';\nimport { PointWithMatrixArrows } from './PointWithMatrixArrows';\n\nexport const TrainWithPhysics = ({\n  curve,\n  init = {},\n  activateCamera = false,\n  resetWhenReachedLimit = true,\n  sections = [],\n}: {\n  curve: Curve;\n  activateCamera?: boolean;\n} & Parameters<typeof useMotionSimulation>[1]) => {\n  const motionMatrix = useMotionSimulation(curve, {\n    init,\n    resetWhenReachedLimit,\n    sections,\n  });\n  const cameraViewManager = useCameraViewManager();\n\n  return (\n    <>\n      {cameraViewManager.activeView !== 'train' && (\n        <PointWithMatrixArrows matrix={motionMatrix} />\n      )}\n      <CameraView name=\"train\" makeDefault={activateCamera}>\n        <TransformationMatrixCamera\n          matrix={motionMatrix}\n          translate={new Vector3(0, 0.75, 0)}\n          makeDefault={true}\n        />\n      </CameraView>\n    </>\n  );\n};\n",
    "functions": {},
    "types": {},
    "variables": {
      "TrainWithPhysics": "const TrainWithPhysics = ({\n  curve,\n  init = {},\n  activateCamera = false,\n  resetWhenReachedLimit = true,\n  sections = [],\n}: {\n  curve: Curve;\n  activateCamera?: boolean;\n} & Parameters<typeof useMotionSimulation>[1]) => {\n  const motionMatrix = useMotionSimulation(curve, {\n    init,\n    resetWhenReachedLimit,\n    sections,\n  });\n  const cameraViewManager = useCameraViewManager();\n\n  return (\n    <>\n      {cameraViewManager.activeView !== 'train' && (\n        <PointWithMatrixArrows matrix={motionMatrix} />\n      )}\n      <CameraView name=\"train\" makeDefault={activateCamera}>\n        <TransformationMatrixCamera\n          matrix={motionMatrix}\n          translate={new Vector3(0, 0.75, 0)}\n          makeDefault={true}\n        />\n      </CameraView>\n    </>\n  );\n};"
    }
  },
  "src/experiments/Experiment.tsx": {
    "source": "import React, { useMemo } from 'react';\nimport { Line } from '@react-three/drei';\nimport { useControls } from 'leva';\nimport { Vector3 } from 'three';\n\nimport { fromURL } from '../helper/nl2park/nl2park';\nimport { useColors } from '../hooks/useColors';\n\nimport { PerspectiveCameraControls } from '../components/camera/PerspectiveCameraControls';\nimport { CurveWireframe } from '../components/curve/CurveWireframe';\nimport { DragControlPoints } from '../components/curve/DragControlPoints';\nimport { Ground } from '../components/Ground';\nimport { PerspectiveScene } from '../components/scenes/PerspectiveScene';\n\nimport { fromPoints } from '../coaster/b-spline-track';\nimport Park from './Experiment.nl2park';\n\nconst park = await fromURL(Park);\nconst exampleCoaster = park.coaster[0];\nconst exampleTrack = exampleCoaster?.tracks[0];\n\nexport const ExperimentScene = () => {\n  const colors = useColors();\n\n  const { pov, closed } = useControls({\n    pov: true,\n    closed: false,\n  });\n\n  const points = useMemo(\n    () =>\n      exampleTrack?.vertices.map(\n        (v) => new Vector3(v.position.x, v.position.y, v.position.z),\n      ),\n    [],\n  );\n\n  const curve = useMemo(() => {\n    return fromPoints(\n      exampleTrack?.vertices.map((v) => v.position),\n      closed,\n    );\n  }, [closed]);\n\n  return (\n    <>\n      <PerspectiveScene>\n        <Ground />\n        <DragControlPoints points={points} setPoints={() => {}} />\n        <Line points={points} color={colors.secondary} />\n        {!pov && <PerspectiveCameraControls />}\n        <CurveWireframe color={colors.secondary} curve={curve} />\n      </PerspectiveScene>\n    </>\n  );\n};\n",
    "functions": {},
    "types": {},
    "variables": {
      "park": "const park = await fromURL(Park);",
      "exampleCoaster": "const exampleCoaster = park.coaster[0];",
      "exampleTrack": "const exampleTrack = exampleCoaster?.tracks[0];",
      "ExperimentScene": "const ExperimentScene = () => {\n  const colors = useColors();\n\n  const { pov, closed } = useControls({\n    pov: true,\n    closed: false,\n  });\n\n  const points = useMemo(\n    () =>\n      exampleTrack?.vertices.map(\n        (v) => new Vector3(v.position.x, v.position.y, v.position.z),\n      ),\n    [],\n  );\n\n  const curve = useMemo(() => {\n    return fromPoints(\n      exampleTrack?.vertices.map((v) => v.position),\n      closed,\n    );\n  }, [closed]);\n\n  return (\n    <>\n      <PerspectiveScene>\n        <Ground />\n        <DragControlPoints points={points} setPoints={() => {}} />\n        <Line points={points} color={colors.secondary} />\n        {!pov && <PerspectiveCameraControls />}\n        <CurveWireframe color={colors.secondary} curve={curve} />\n      </PerspectiveScene>\n    </>\n  );\n};"
    }
  },
  "src/experiments/NoLimitsTrack.tsx": {
    "source": "import React from 'react';\nimport { useControls } from 'leva';\nimport { Vector3 } from 'three';\n\nimport { toLocalTransformed } from '../maths/curve';\nimport { fromURL } from '../helper/nl2park/nl2park';\nimport { curveFromCustomTrack } from '../helper/nolimits';\nimport { useColors } from '../hooks/useColors';\n\nimport { PerspectiveCameraControls } from '../components/camera/PerspectiveCameraControls';\nimport { CurveWireframe } from '../components/curve/CurveWireframe';\nimport { Ground } from '../components/Ground';\nimport { PerspectiveScene } from '../components/scenes/PerspectiveScene';\nimport { TrainWithPhysics } from '../components/TrainWithPhysics';\n\nimport { fromUrl } from '../coaster/nolimits-csv-track';\nimport ParkCSV from './Experiment.csv';\nimport Park from './Experiment.nl2park';\n\nconst park = await fromURL(Park);\nconst exampleCoaster = park.coaster[0];\nconst exampleTrack = exampleCoaster?.tracks[0];\n\nconst exampleTrackCurve = toLocalTransformed(\n  curveFromCustomTrack(exampleTrack, true),\n  new Vector3(0, -1.1, 0),\n);\n\nconst exampleCSVCurve = await fromUrl(ParkCSV);\n\nexport const NoLimitsTrackScene = () => {\n  const colors = useColors();\n\n  const { pov } = useControls({\n    pov: true,\n  });\n\n  return (\n    <>\n      <PerspectiveScene>\n        <Ground />\n        {/*<DragControlPoints points={points} setPoints={() => {}} />\n        <Line points={points} color={colors.secondary} />*/}\n        {!pov && <PerspectiveCameraControls />}\n        <CurveWireframe\n          color={colors.highlight}\n          curve={exampleCSVCurve}\n        />\n        <CurveWireframe\n          color={colors.secondary}\n          curve={exampleTrackCurve}\n        />\n        <TrainWithPhysics\n          curve={exampleTrackCurve}\n          init={{\n            velocity: 7,\n            distanceTraveled: 186,\n            friction: 0.026,\n            airResistance: 2e-5,\n          }}\n        />\n      </PerspectiveScene>\n    </>\n  );\n};\n",
    "functions": {},
    "types": {},
    "variables": {
      "park": "const park = await fromURL(Park);",
      "exampleCoaster": "const exampleCoaster = park.coaster[0];",
      "exampleTrack": "const exampleTrack = exampleCoaster?.tracks[0];",
      "exampleTrackCurve": "const exampleTrackCurve = toLocalTransformed(\n  curveFromCustomTrack(exampleTrack, true),\n  new Vector3(0, -1.1, 0),\n);",
      "exampleCSVCurve": "const exampleCSVCurve = await fromUrl(ParkCSV);",
      "NoLimitsTrackScene": "const NoLimitsTrackScene = () => {\n  const colors = useColors();\n\n  const { pov } = useControls({\n    pov: true,\n  });\n\n  return (\n    <>\n      <PerspectiveScene>\n        <Ground />\n        {/*<DragControlPoints points={points} setPoints={() => {}} />\n        <Line points={points} color={colors.secondary} />*/}\n        {!pov && <PerspectiveCameraControls />}\n        <CurveWireframe\n          color={colors.highlight}\n          curve={exampleCSVCurve}\n        />\n        <CurveWireframe\n          color={colors.secondary}\n          curve={exampleTrackCurve}\n        />\n        <TrainWithPhysics\n          curve={exampleTrackCurve}\n          init={{\n            velocity: 7,\n            distanceTraveled: 186,\n            friction: 0.026,\n            airResistance: 2e-5,\n          }}\n        />\n      </PerspectiveScene>\n    </>\n  );\n};"
    }
  },
  "src/experiments/plot.ts": {
    "source": "import { Matrix4, Vector2, Vector3, Vector4 } from 'three';\n\nimport {\n  Curve,\n  totalArcLength,\n  transformationAtArcLength,\n} from '../maths/curve';\nimport { uniformSampleMap } from '../helper/uniform-sample';\n\nexport const plotDataFromPoints = (\n  nodes: (Vector2 | Vector3 | Vector4)[],\n) => ({\n  x: nodes.map((v) => v.x),\n  y: nodes.map((v) => v.y),\n});\n\nexport const plotDataFromCurve = (\n  curve: Curve,\n  resolution: number = 8,\n  fn: (m: Matrix4) => number,\n) => {\n  const points = uniformSampleMap(\n    0,\n    totalArcLength(curve),\n    resolution,\n    (at: number) =>\n      new Vector2(at, fn(transformationAtArcLength(curve, at))),\n  );\n\n  return plotDataFromPoints(points);\n};\n",
    "functions": {},
    "types": {},
    "variables": {
      "plotDataFromPoints": "const plotDataFromPoints = (\n  nodes: (Vector2 | Vector3 | Vector4)[],\n) => ({\n  x: nodes.map((v) => v.x),\n  y: nodes.map((v) => v.y),\n});",
      "plotDataFromCurve": "const plotDataFromCurve = (\n  curve: Curve,\n  resolution: number = 8,\n  fn: (m: Matrix4) => number,\n) => {\n  const points = uniformSampleMap(\n    0,\n    totalArcLength(curve),\n    resolution,\n    (at: number) =>\n      new Vector2(at, fn(transformationAtArcLength(curve, at))),\n  );\n\n  return plotDataFromPoints(points);\n};"
    }
  },
  "src/helper/binary-search.ts": {
    "source": "import { MathUtils } from 'three';\n\nexport const lowerBound = <T>(\n  array: T[],\n  value: number,\n  accessor: (item: T, index: number) => number,\n): number => {\n  let first = 0;\n  let len = array.length;\n\n  while (len > 0) {\n    const half = Math.floor(len / 2);\n    const middle = first + half;\n\n    if (accessor(array[middle], middle) < value) {\n      first = middle + 1;\n      len = len - half - 1;\n    } else {\n      len = half;\n    }\n  }\n\n  return first;\n};\n\nexport const findBoundingIndices = <T>(\n  array: T[],\n  value: number,\n  accessor: (item: T, index: number) => number,\n) => {\n  if (array.length < 2) return;\n\n  const lowerNodeIndex = lowerBound(array, value, accessor);\n  const rightNodeIndex = MathUtils.clamp(\n    lowerNodeIndex,\n    1,\n    array.length - 1,\n  );\n  const leftNodeIndex = rightNodeIndex - 1;\n\n  return [leftNodeIndex, rightNodeIndex];\n};\n",
    "functions": {},
    "types": {},
    "variables": {
      "lowerBound": "const lowerBound = <T>(\n  array: T[],\n  value: number,\n  accessor: (item: T, index: number) => number,\n): number => {\n  let first = 0;\n  let len = array.length;\n\n  while (len > 0) {\n    const half = Math.floor(len / 2);\n    const middle = first + half;\n\n    if (accessor(array[middle], middle) < value) {\n      first = middle + 1;\n      len = len - half - 1;\n    } else {\n      len = half;\n    }\n  }\n\n  return first;\n};",
      "findBoundingIndices": "const findBoundingIndices = <T>(\n  array: T[],\n  value: number,\n  accessor: (item: T, index: number) => number,\n) => {\n  if (array.length < 2) return;\n\n  const lowerNodeIndex = lowerBound(array, value, accessor);\n  const rightNodeIndex = MathUtils.clamp(\n    lowerNodeIndex,\n    1,\n    array.length - 1,\n  );\n  const leftNodeIndex = rightNodeIndex - 1;\n\n  return [leftNodeIndex, rightNodeIndex];\n};"
    }
  },
  "src/helper/nolimits.ts": {
    "source": "import { applyRollCurve, arcLengthAtOffset } from '../maths/curve';\n\nimport { fromRollPoints } from '../coaster/cubic-roll';\nimport { fromVertices } from '../coaster/nolimits-track';\nimport { readCustomTrack } from './nl2park/track/custom-track';\nimport { isRollPoint } from './nl2park/track/roll-point';\nimport { splitPointsByStrict } from './strict-point';\n\nexport const curveFromCustomTrack = (\n  track: ReturnType<typeof readCustomTrack>,\n  withRoll: boolean = true,\n  resolution: number = 20,\n) => {\n  const curve = fromVertices(\n    track.vertices.map((vertex) => ({\n      ...vertex,\n      position: vertex.position.clone(),\n    })),\n    track.closed,\n    resolution,\n  );\n\n  if (withRoll)\n    applyRollCurve(\n      curve,\n      fromRollPoints(curve, rollPointsFromCustomTrack(track)),\n    );\n\n  return curve;\n};\n\nexport const parameterSpaceFromCustomTrack = (\n  track: ReturnType<typeof readCustomTrack>,\n) => {\n  if (track.vertices.length < 2) return [];\n\n  const sections = splitPointsByStrict(track.vertices);\n\n  const parameterSpace: number[] = [0];\n  for (let i = 0; i < sections.length; i += 1) {\n    const vertices = sections[i];\n    const lastParameterSpace =\n      parameterSpace[parameterSpace.length - 1];\n\n    parameterSpace.push(\n      ...makeParameterSpaceMap(vertices.length, track.closed)\n        .slice(1)\n        .map((u) => lastParameterSpace + u),\n    );\n  }\n\n  return parameterSpace;\n};\n\nexport const rollPointsFromCustomTrack = (\n  track: ReturnType<typeof readCustomTrack>,\n) => {\n  if (track.vertices.length < 2) return [];\n\n  const parameterSpace = parameterSpaceFromCustomTrack(track);\n\n  const rollPoints = [\n    {\n      position: 0,\n      roll: track.startRoll.roll,\n      vertical: track.startRoll.vertical,\n      strict: false,\n    },\n    {\n      position: track.vertices.length - 1,\n      roll: track.endRoll.roll,\n      vertical: track.endRoll.vertical,\n      strict: false,\n    },\n    ...track?.points.filter(isRollPoint),\n  ];\n\n  return rollPoints\n    .sort((a, b) => a.position - b.position)\n    .map((point) => ({\n      ...point,\n      position: arcLengthAtOffset(point.position, parameterSpace),\n    }));\n};\n\nexport const makeParameterSpaceMap = (\n  numberOfPoints: number,\n  closed: boolean = false,\n) => {\n  const space: number[] = [0];\n  const degree = Math.min(numberOfPoints - 1, 3);\n\n  const push = (u: number, repeat: number) => {\n    for (let i = 0; i < repeat; i++)\n      space.push(space[space.length - 1] + u);\n  };\n\n  const hasMiddle = numberOfPoints > degree + 1;\n  const splits = hasMiddle ? Math.min(2, degree) : numberOfPoints - 1;\n  //const middle = numberOfPoints - splits - 1;\n\n  if (closed) {\n    /*if ((isFirstSection || isLastSection) && numberOfPoints <= 3) {\n      push(1, 1) }\n    else if (isFirstSection && numberOfPoints <= 3) {\n      push(0.5, 4);\n    } else if (isFirstSection && numberOfPoints <= 4) {\n      push(1, 1);\n      push(1 / 2, 2);\n    } else if (isLastSection && numberOfPoints <= 4) {\n      push(1 / 2, 2);\n      push(1, 2);\n    } else if (isFirstSection) {\n      push(1, middle);\n      push(1 / splits, splits);\n    } else if (isLastSection) {\n      push(1 / splits, splits);\n      push(1, middle);\n    } else */ push(1, numberOfPoints);\n  } else {\n    push(1 / splits, splits);\n    if (hasMiddle) {\n      push(1, numberOfPoints - 1 - 2 * splits);\n      push(1 / splits, splits);\n    }\n  }\n\n  return space;\n};\n",
    "functions": {},
    "types": {},
    "variables": {
      "curveFromCustomTrack": "const curveFromCustomTrack = (\n  track: ReturnType<typeof readCustomTrack>,\n  withRoll: boolean = true,\n  resolution: number = 20,\n) => {\n  const curve = fromVertices(\n    track.vertices.map((vertex) => ({\n      ...vertex,\n      position: vertex.position.clone(),\n    })),\n    track.closed,\n    resolution,\n  );\n\n  if (withRoll)\n    applyRollCurve(\n      curve,\n      fromRollPoints(curve, rollPointsFromCustomTrack(track)),\n    );\n\n  return curve;\n};",
      "parameterSpaceFromCustomTrack": "const parameterSpaceFromCustomTrack = (\n  track: ReturnType<typeof readCustomTrack>,\n) => {\n  if (track.vertices.length < 2) return [];\n\n  const sections = splitPointsByStrict(track.vertices);\n\n  const parameterSpace: number[] = [0];\n  for (let i = 0; i < sections.length; i += 1) {\n    const vertices = sections[i];\n    const lastParameterSpace =\n      parameterSpace[parameterSpace.length - 1];\n\n    parameterSpace.push(\n      ...makeParameterSpaceMap(vertices.length, track.closed)\n        .slice(1)\n        .map((u) => lastParameterSpace + u),\n    );\n  }\n\n  return parameterSpace;\n};",
      "rollPointsFromCustomTrack": "const rollPointsFromCustomTrack = (\n  track: ReturnType<typeof readCustomTrack>,\n) => {\n  if (track.vertices.length < 2) return [];\n\n  const parameterSpace = parameterSpaceFromCustomTrack(track);\n\n  const rollPoints = [\n    {\n      position: 0,\n      roll: track.startRoll.roll,\n      vertical: track.startRoll.vertical,\n      strict: false,\n    },\n    {\n      position: track.vertices.length - 1,\n      roll: track.endRoll.roll,\n      vertical: track.endRoll.vertical,\n      strict: false,\n    },\n    ...track?.points.filter(isRollPoint),\n  ];\n\n  return rollPoints\n    .sort((a, b) => a.position - b.position)\n    .map((point) => ({\n      ...point,\n      position: arcLengthAtOffset(point.position, parameterSpace),\n    }));\n};",
      "makeParameterSpaceMap": "const makeParameterSpaceMap = (\n  numberOfPoints: number,\n  closed: boolean = false,\n) => {\n  const space: number[] = [0];\n  const degree = Math.min(numberOfPoints - 1, 3);\n\n  const push = (u: number, repeat: number) => {\n    for (let i = 0; i < repeat; i++)\n      space.push(space[space.length - 1] + u);\n  };\n\n  const hasMiddle = numberOfPoints > degree + 1;\n  const splits = hasMiddle ? Math.min(2, degree) : numberOfPoints - 1;\n  //const middle = numberOfPoints - splits - 1;\n\n  if (closed) {\n    /*if ((isFirstSection || isLastSection) && numberOfPoints <= 3) {\n      push(1, 1) }\n    else if (isFirstSection && numberOfPoints <= 3) {\n      push(0.5, 4);\n    } else if (isFirstSection && numberOfPoints <= 4) {\n      push(1, 1);\n      push(1 / 2, 2);\n    } else if (isLastSection && numberOfPoints <= 4) {\n      push(1 / 2, 2);\n      push(1, 2);\n    } else if (isFirstSection) {\n      push(1, middle);\n      push(1 / splits, splits);\n    } else if (isLastSection) {\n      push(1 / splits, splits);\n      push(1, middle);\n    } else */ push(1, numberOfPoints);\n  } else {\n    push(1 / splits, splits);\n    if (hasMiddle) {\n      push(1, numberOfPoints - 1 - 2 * splits);\n      push(1 / splits, splits);\n    }\n  }\n\n  return space;\n};"
    }
  },
  "src/helper/numberToHexString.ts": {
    "source": "export const numberToHexString = (value: number): string => {\n  return '#' + value.toString(16).padStart(6, '0');\n};\n",
    "functions": {},
    "types": {},
    "variables": {
      "numberToHexString": "const numberToHexString = (value: number): string => {\n  return '#' + value.toString(16).padStart(6, '0');\n};"
    }
  },
  "src/helper/physics.ts": {
    "source": "import { Matrix4, Vector3 } from 'three';\n\nimport { toForwardDirection } from '../maths/matrix4';\n\nexport type SimulationState = {\n  velocity: number;\n  distanceTraveled: number;\n  acceleration: number;\n};\n\nexport const evaluateMotion = (\n  state: SimulationState,\n  transformation: Matrix4,\n  activeAcceleration: number,\n  friction: number,\n  airResistance: number,\n  gravity: number,\n  deltaTime: number,\n): SimulationState => {\n  const forwardDirection = toForwardDirection(transformation);\n  const velocityDirection = state.velocity < 0 ? -1 : 1;\n\n  let energyLoss = airResistance * state.velocity * state.velocity;\n  energyLoss += friction * gravity;\n  energyLoss *= velocityDirection;\n\n  let acceleration = forwardDirection.dot(\n    new Vector3(0, -gravity, 0),\n  );\n  acceleration += activeAcceleration;\n  acceleration -= energyLoss;\n\n  const velocity = state.velocity + acceleration * deltaTime;\n  const distanceTraveled =\n    state.distanceTraveled + velocity * deltaTime;\n\n  return { velocity, distanceTraveled, acceleration };\n};\n",
    "functions": {},
    "types": {
      "SimulationState": "type SimulationState = {\n  velocity: number;\n  distanceTraveled: number;\n  acceleration: number;\n};"
    },
    "variables": {
      "evaluateMotion": "const evaluateMotion = (\n  state: SimulationState,\n  transformation: Matrix4,\n  activeAcceleration: number,\n  friction: number,\n  airResistance: number,\n  gravity: number,\n  deltaTime: number,\n): SimulationState => {\n  const forwardDirection = toForwardDirection(transformation);\n  const velocityDirection = state.velocity < 0 ? -1 : 1;\n\n  let energyLoss = airResistance * state.velocity * state.velocity;\n  energyLoss += friction * gravity;\n  energyLoss *= velocityDirection;\n\n  let acceleration = forwardDirection.dot(\n    new Vector3(0, -gravity, 0),\n  );\n  acceleration += activeAcceleration;\n  acceleration -= energyLoss;\n\n  const velocity = state.velocity + acceleration * deltaTime;\n  const distanceTraveled =\n    state.distanceTraveled + velocity * deltaTime;\n\n  return { velocity, distanceTraveled, acceleration };\n};"
    }
  },
  "src/helper/render-content-component.tsx": {
    "source": "import React from 'react';\nimport { createRoot } from 'react-dom/client';\n\nimport { ContentComponent } from '../components/ContentComponent';\n\nimport '../themes/hello-friend-ng/assets/scss/main-content-component.scss';\n\n// @ts-ignore\nexport const contentComponents = require.context(\n  '../content',\n  true,\n  /\\.tsx$/,\n);\n\nconst renderContentComponentByPath = async (\n  rootElementId: string,\n  path: string,\n) => {\n  const element = document.getElementById(rootElementId);\n\n  if (!element)\n    throw new Error(`Cannot find element by id: ${rootElementId}`);\n\n  createRoot(element).render(<ContentComponent path={path} />);\n};\n\nexport { renderContentComponentByPath };\n",
    "functions": {},
    "types": {},
    "variables": {
      "contentComponents": "const contentComponents = require.context(\n  '../content',\n  true,\n  /\\.tsx$/,\n);",
      "renderContentComponentByPath": "const renderContentComponentByPath = async (\n  rootElementId: string,\n  path: string,\n) => {\n  const element = document.getElementById(rootElementId);\n\n  if (!element)\n    throw new Error(`Cannot find element by id: ${rootElementId}`);\n\n  createRoot(element).render(<ContentComponent path={path} />);\n};"
    }
  },
  "src/helper/strict-point.ts": {
    "source": "export const splitPointsByStrict = <T extends { strict: boolean }>(\n  points: Array<T>,\n) => {\n  const result: T[][] = [];\n  const indices = points.reduce<Array<number>>(\n    (indices, v, i) => {\n      if ((v.strict && i) || i === points.length - 1) indices.push(i);\n      return indices;\n    },\n    [0],\n  );\n\n  for (let i = 0; i < indices.length - 1; i += 1) {\n    result.push(points.slice(indices[i], indices[i + 1] + 1));\n  }\n\n  return result;\n};\n",
    "functions": {},
    "types": {},
    "variables": {
      "splitPointsByStrict": "const splitPointsByStrict = <T extends { strict: boolean }>(\n  points: Array<T>,\n) => {\n  const result: T[][] = [];\n  const indices = points.reduce<Array<number>>(\n    (indices, v, i) => {\n      if ((v.strict && i) || i === points.length - 1) indices.push(i);\n      return indices;\n    },\n    [0],\n  );\n\n  for (let i = 0; i < indices.length - 1; i += 1) {\n    result.push(points.slice(indices[i], indices[i + 1] + 1));\n  }\n\n  return result;\n};"
    }
  },
  "src/helper/three.ts": {
    "source": "import { BufferGeometry, Matrix4, Mesh, Object3D } from 'three';\n\nexport const bufferGeometriesFromObject3D = (\n  object: Object3D,\n  extraTransform: Matrix4 = new Matrix4(),\n) => {\n  const geometries: BufferGeometry[] = [];\n\n  object.updateWorldMatrix(true, true);\n\n  object.traverse((child) => {\n    if ((child as any).isMesh) {\n      const mesh = child as Mesh;\n      const geom = mesh.geometry.clone();\n      geom.applyMatrix4(mesh.matrixWorld);\n      geom.applyMatrix4(extraTransform);\n      geometries.push(geom);\n    }\n  });\n\n  return geometries;\n};\n",
    "functions": {},
    "types": {},
    "variables": {
      "bufferGeometriesFromObject3D": "const bufferGeometriesFromObject3D = (\n  object: Object3D,\n  extraTransform: Matrix4 = new Matrix4(),\n) => {\n  const geometries: BufferGeometry[] = [];\n\n  object.updateWorldMatrix(true, true);\n\n  object.traverse((child) => {\n    if ((child as any).isMesh) {\n      const mesh = child as Mesh;\n      const geom = mesh.geometry.clone();\n      geom.applyMatrix4(mesh.matrixWorld);\n      geom.applyMatrix4(extraTransform);\n      geometries.push(geom);\n    }\n  });\n\n  return geometries;\n};"
    }
  },
  "src/helper/uniform-sample.ts": {
    "source": "export const uniformSample = (\n  from: number,\n  to: number,\n  resolution: number = 20,\n  fn: (at: number, t: number) => void,\n) => {\n  const length = to - from;\n  const numberOfNodes = Math.max(Math.floor(length * resolution), 2);\n\n  for (let i = 0; i < numberOfNodes; i++) {\n    const t = i / (numberOfNodes - 1);\n    const at = from + t * length;\n    fn(at, t);\n  }\n};\n\nexport const uniformSampleMap = <T>(\n  from: number,\n  to: number,\n  resolution: number = 20,\n  mapFn: (at: number, t: number) => T,\n) => {\n  const out: T[] = [];\n\n  uniformSample(from, to, resolution, (at, t) => {\n    out.push(mapFn(at, t));\n  });\n\n  return out;\n};\n",
    "functions": {},
    "types": {},
    "variables": {
      "uniformSample": "const uniformSample = (\n  from: number,\n  to: number,\n  resolution: number = 20,\n  fn: (at: number, t: number) => void,\n) => {\n  const length = to - from;\n  const numberOfNodes = Math.max(Math.floor(length * resolution), 2);\n\n  for (let i = 0; i < numberOfNodes; i++) {\n    const t = i / (numberOfNodes - 1);\n    const at = from + t * length;\n    fn(at, t);\n  }\n};",
      "uniformSampleMap": "const uniformSampleMap = <T>(\n  from: number,\n  to: number,\n  resolution: number = 20,\n  mapFn: (at: number, t: number) => T,\n) => {\n  const out: T[] = [];\n\n  uniformSample(from, to, resolution, (at, t) => {\n    out.push(mapFn(at, t));\n  });\n\n  return out;\n};"
    }
  },
  "src/hooks/useColors.ts": {
    "source": "import { useMemo } from 'react';\n\nexport const useColors = () => {\n  return useMemo(() => {\n    return {\n      primary: 0x2b2b2b,\n      silent: 0x404040,\n      secondary: 0xa9b7c6,\n      highlight: 0xcc7832,\n    };\n  }, []);\n};\n",
    "functions": {},
    "types": {},
    "variables": {
      "useColors": "const useColors = () => {\n  return useMemo(() => {\n    return {\n      primary: 0x2b2b2b,\n      silent: 0x404040,\n      secondary: 0xa9b7c6,\n      highlight: 0xcc7832,\n    };\n  }, []);\n};"
    }
  },
  "src/hooks/useMeasure.ts": {
    "source": "import { useCallback, useRef, useState } from 'react';\n\nexport const useMeasure = <T extends Element>() => {\n  const [dimensions, setDimensions] = useState({\n    width: 0,\n    height: 0,\n  });\n\n  const previousObserver = useRef<ResizeObserver>(null);\n\n  const ref = useCallback((node: T) => {\n    if (previousObserver.current) {\n      previousObserver.current.disconnect();\n      previousObserver.current = null;\n    }\n\n    if (node?.nodeType === Node.ELEMENT_NODE) {\n      const observer = new ResizeObserver(([entry]) => {\n        if (entry && entry.borderBoxSize) {\n          const { inlineSize: width, blockSize: height } =\n            entry.borderBoxSize[0];\n\n          setDimensions({ width, height });\n        }\n      });\n\n      observer.observe(node);\n      previousObserver.current = observer;\n    }\n  }, []);\n\n  return {\n    ref,\n    dimensions,\n  };\n};\n",
    "functions": {},
    "types": {},
    "variables": {
      "useMeasure": "const useMeasure = <T extends Element>() => {\n  const [dimensions, setDimensions] = useState({\n    width: 0,\n    height: 0,\n  });\n\n  const previousObserver = useRef<ResizeObserver>(null);\n\n  const ref = useCallback((node: T) => {\n    if (previousObserver.current) {\n      previousObserver.current.disconnect();\n      previousObserver.current = null;\n    }\n\n    if (node?.nodeType === Node.ELEMENT_NODE) {\n      const observer = new ResizeObserver(([entry]) => {\n        if (entry && entry.borderBoxSize) {\n          const { inlineSize: width, blockSize: height } =\n            entry.borderBoxSize[0];\n\n          setDimensions({ width, height });\n        }\n      });\n\n      observer.observe(node);\n      previousObserver.current = observer;\n    }\n  }, []);\n\n  return {\n    ref,\n    dimensions,\n  };\n};"
    }
  },
  "src/hooks/useMotionSimulation.ts": {
    "source": "import { useEffect, useRef, useState } from 'react';\nimport { useControls } from 'leva';\nimport { find } from 'lodash';\nimport { MathUtils, Matrix4 } from 'three';\n\nimport {\n  Curve,\n  totalArcLength,\n  transformationAtArcLength,\n} from '../maths/curve';\nimport { evaluateMotion } from '../helper/physics';\n\nimport { useSimulationStateControls } from './useSimulationStateControls';\n\nexport const useMotionSimulation = (\n  curve: Curve,\n  options: {\n    init?: Parameters<typeof useSimulationStateControls>[0];\n    resetWhenReachedLimit?: boolean;\n    sections?: Array<{\n      acceleration: number;\n      fromArcLength: number;\n      toArcLength: number;\n      minVelocity?: number;\n      maxVelocity?: number;\n    }>;\n  } = {},\n) => {\n  const {\n    init = {},\n    resetWhenReachedLimit = true,\n    sections = [],\n  } = options;\n  const [matrix, setMatrix] = useState(new Matrix4());\n  const [{ friction, airResistance, gravity, simulationSpeed }] =\n    useControls('Simulation', () => ({\n      friction: {\n        value: init.friction ?? 0.03,\n        pad: 5,\n      },\n      airResistance: {\n        value: init.airResistance ?? 2e-5,\n        pad: 6,\n      },\n      gravity: {\n        value: init.gravity ?? 9.81665,\n        pad: 5,\n      },\n      simulationSpeed: {\n        min: 0.25,\n        max: 4,\n        step: 0.25,\n        value: init.simulationSpeed ?? 1,\n      },\n    }));\n\n  const simulationState = useRef({\n    distanceTraveled: init?.distanceTraveled ?? 0,\n    velocity: init?.velocity ?? 0,\n    acceleration: 0,\n  });\n\n  useEffect(() => {\n    let timeoutId: number;\n    let lastTime = performance.now();\n\n    const tick = () => {\n      const now = performance.now();\n      const deltaTime = (now - lastTime) / 1000;\n      lastTime = now;\n\n      if (deltaTime > 0.032 || !deltaTime) {\n        timeoutId = window.setTimeout(tick);\n        return;\n      }\n\n      if (\n        resetWhenReachedLimit &&\n        (simulationState.current.distanceTraveled >\n          totalArcLength(curve) ||\n          simulationState.current.distanceTraveled < 0)\n      ) {\n        simulationState.current = {\n          velocity: init?.velocity ?? 0,\n          distanceTraveled: init?.distanceTraveled ?? 0,\n          acceleration: 0,\n        };\n      } else {\n        const section = find(\n          sections,\n          (s) =>\n            simulationState.current.distanceTraveled >=\n              s.fromArcLength &&\n            simulationState.current.distanceTraveled <= s.toArcLength,\n        );\n\n        let acceleration = 0;\n        if (\n          section &&\n          section.maxVelocity !== undefined &&\n          simulationState.current.velocity < section.maxVelocity\n        )\n          acceleration = section.acceleration;\n        if (\n          section &&\n          section.minVelocity !== undefined &&\n          simulationState.current.velocity > section.minVelocity\n        )\n          acceleration = section.acceleration;\n\n        simulationState.current = evaluateMotion(\n          simulationState.current,\n          transformationAtArcLength(\n            curve,\n            simulationState.current.distanceTraveled,\n          ),\n          acceleration,\n          friction,\n          airResistance,\n          gravity,\n          deltaTime * simulationSpeed,\n        );\n\n        const arcLength = totalArcLength(curve);\n\n        if (!resetWhenReachedLimit)\n          simulationState.current.distanceTraveled =\n            ((simulationState.current.distanceTraveled % arcLength) +\n              arcLength) %\n            arcLength;\n      }\n\n      setMatrix(\n        transformationAtArcLength(\n          curve,\n          MathUtils.clamp(\n            simulationState.current.distanceTraveled,\n            0,\n            totalArcLength(curve),\n          ),\n        ),\n      );\n\n      timeoutId = window.setTimeout(tick);\n    };\n\n    tick();\n\n    return () => {\n      clearTimeout(timeoutId);\n    };\n  }, [\n    curve,\n    simulationSpeed,\n    gravity,\n    airResistance,\n    friction,\n    resetWhenReachedLimit,\n    sections,\n    init?.distanceTraveled,\n    init?.velocity,\n  ]);\n\n  return matrix;\n};\n",
    "functions": {},
    "types": {},
    "variables": {
      "useMotionSimulation": "const useMotionSimulation = (\n  curve: Curve,\n  options: {\n    init?: Parameters<typeof useSimulationStateControls>[0];\n    resetWhenReachedLimit?: boolean;\n    sections?: Array<{\n      acceleration: number;\n      fromArcLength: number;\n      toArcLength: number;\n      minVelocity?: number;\n      maxVelocity?: number;\n    }>;\n  } = {},\n) => {\n  const {\n    init = {},\n    resetWhenReachedLimit = true,\n    sections = [],\n  } = options;\n  const [matrix, setMatrix] = useState(new Matrix4());\n  const [{ friction, airResistance, gravity, simulationSpeed }] =\n    useControls('Simulation', () => ({\n      friction: {\n        value: init.friction ?? 0.03,\n        pad: 5,\n      },\n      airResistance: {\n        value: init.airResistance ?? 2e-5,\n        pad: 6,\n      },\n      gravity: {\n        value: init.gravity ?? 9.81665,\n        pad: 5,\n      },\n      simulationSpeed: {\n        min: 0.25,\n        max: 4,\n        step: 0.25,\n        value: init.simulationSpeed ?? 1,\n      },\n    }));\n\n  const simulationState = useRef({\n    distanceTraveled: init?.distanceTraveled ?? 0,\n    velocity: init?.velocity ?? 0,\n    acceleration: 0,\n  });\n\n  useEffect(() => {\n    let timeoutId: number;\n    let lastTime = performance.now();\n\n    const tick = () => {\n      const now = performance.now();\n      const deltaTime = (now - lastTime) / 1000;\n      lastTime = now;\n\n      if (deltaTime > 0.032 || !deltaTime) {\n        timeoutId = window.setTimeout(tick);\n        return;\n      }\n\n      if (\n        resetWhenReachedLimit &&\n        (simulationState.current.distanceTraveled >\n          totalArcLength(curve) ||\n          simulationState.current.distanceTraveled < 0)\n      ) {\n        simulationState.current = {\n          velocity: init?.velocity ?? 0,\n          distanceTraveled: init?.distanceTraveled ?? 0,\n          acceleration: 0,\n        };\n      } else {\n        const section = find(\n          sections,\n          (s) =>\n            simulationState.current.distanceTraveled >=\n              s.fromArcLength &&\n            simulationState.current.distanceTraveled <= s.toArcLength,\n        );\n\n        let acceleration = 0;\n        if (\n          section &&\n          section.maxVelocity !== undefined &&\n          simulationState.current.velocity < section.maxVelocity\n        )\n          acceleration = section.acceleration;\n        if (\n          section &&\n          section.minVelocity !== undefined &&\n          simulationState.current.velocity > section.minVelocity\n        )\n          acceleration = section.acceleration;\n\n        simulationState.current = evaluateMotion(\n          simulationState.current,\n          transformationAtArcLength(\n            curve,\n            simulationState.current.distanceTraveled,\n          ),\n          acceleration,\n          friction,\n          airResistance,\n          gravity,\n          deltaTime * simulationSpeed,\n        );\n\n        const arcLength = totalArcLength(curve);\n\n        if (!resetWhenReachedLimit)\n          simulationState.current.distanceTraveled =\n            ((simulationState.current.distanceTraveled % arcLength) +\n              arcLength) %\n            arcLength;\n      }\n\n      setMatrix(\n        transformationAtArcLength(\n          curve,\n          MathUtils.clamp(\n            simulationState.current.distanceTraveled,\n            0,\n            totalArcLength(curve),\n          ),\n        ),\n      );\n\n      timeoutId = window.setTimeout(tick);\n    };\n\n    tick();\n\n    return () => {\n      clearTimeout(timeoutId);\n    };\n  }, [\n    curve,\n    simulationSpeed,\n    gravity,\n    airResistance,\n    friction,\n    resetWhenReachedLimit,\n    sections,\n    init?.distanceTraveled,\n    init?.velocity,\n  ]);\n\n  return matrix;\n};"
    }
  },
  "src/hooks/useSimulationStateControls.ts": {
    "source": "import { useControls } from 'leva';\n\nexport const useSimulationStateControls = (\n  init: {\n    velocity?: number;\n    distanceTraveled?: number;\n    friction?: number;\n    airResistance?: number;\n    gravity?: number;\n    simulationSpeed?: number;\n  } = {},\n) => {\n  return useControls('Simulation', () => ({\n    velocity: init.velocity ?? 0,\n    distanceTraveled: init.distanceTraveled ?? 0,\n    friction: {\n      value: init.friction ?? 0.03,\n      pad: 5,\n    },\n    airResistance: {\n      value: init.airResistance ?? 2e-5,\n      pad: 6,\n    },\n    acceleration: {\n      value: 0,\n      pad: 5,\n    },\n    gravity: {\n      value: init.gravity ?? 9.81665,\n      pad: 5,\n    },\n    simulationSpeed: {\n      min: 0.25,\n      max: 4,\n      step: 0.25,\n      value: init.simulationSpeed ?? 1,\n    },\n  }));\n};\n",
    "functions": {},
    "types": {},
    "variables": {
      "useSimulationStateControls": "const useSimulationStateControls = (\n  init: {\n    velocity?: number;\n    distanceTraveled?: number;\n    friction?: number;\n    airResistance?: number;\n    gravity?: number;\n    simulationSpeed?: number;\n  } = {},\n) => {\n  return useControls('Simulation', () => ({\n    velocity: init.velocity ?? 0,\n    distanceTraveled: init.distanceTraveled ?? 0,\n    friction: {\n      value: init.friction ?? 0.03,\n      pad: 5,\n    },\n    airResistance: {\n      value: init.airResistance ?? 2e-5,\n      pad: 6,\n    },\n    acceleration: {\n      value: 0,\n      pad: 5,\n    },\n    gravity: {\n      value: init.gravity ?? 9.81665,\n      pad: 5,\n    },\n    simulationSpeed: {\n      min: 0.25,\n      max: 4,\n      step: 0.25,\n      value: init.simulationSpeed ?? 1,\n    },\n  }));\n};"
    }
  },
  "src/maths/b-spline.ts": {
    "source": "import { Vector3, Vector4 } from 'three';\n\nimport {\n  uniformSample,\n  uniformSampleMap,\n} from '../helper/uniform-sample';\n\nimport { emptyCurve, insertPosition } from './curve';\n\nconst cubicUniformRationalBSpline = (\n  p0: Vector4,\n  p1: Vector4,\n  p2: Vector4,\n  p3: Vector4,\n  t: number,\n) => {\n  const t2 = t * t;\n  const t3 = t2 * t;\n\n  const b0 = (-t3 + 3 * t2 - 3 * t + 1) / 6;\n  const b1 = (3 * t3 - 6 * t2 + 4) / 6;\n  const b2 = (-3 * t3 + 3 * t2 + 3 * t + 1) / 6;\n  const b3 = t3 / 6;\n\n  const denominator = b0 * p0.w + b1 * p1.w + b2 * p2.w + b3 * p3.w;\n\n  const num = new Vector4()\n    .addScaledVector(p0, b0 * p0.w)\n    .addScaledVector(p1, b1 * p1.w)\n    .addScaledVector(p2, b2 * p2.w)\n    .addScaledVector(p3, b3 * p3.w);\n\n  return new Vector3(num.x, num.y, num.z).divideScalar(denominator);\n};\n\nexport const estimateTotalArcLength = (\n  p0: Vector4,\n  p1: Vector4,\n  p2: Vector4,\n  p3: Vector4,\n) => {\n  const positions = uniformSampleMap(0, 8, 1, (at, t) =>\n    cubicUniformRationalBSpline(p0, p1, p2, p3, t),\n  );\n\n  return positions\n    .slice(1)\n    .reduce(\n      (arcLength, position, i) =>\n        arcLength + position.distanceTo(positions[i]),\n      0,\n    );\n};\n\nexport const fromPoints = (\n  points: Vector4[],\n  resolution: number = 20,\n) => {\n  const curve = emptyCurve();\n  if (points.length < 4) return curve;\n\n  for (let i = 0; i < points.length - 3; i++) {\n    const p0 = points[i];\n    const p1 = points[i + 1];\n    const p2 = points[i + 2];\n    const p3 = points[i + 3];\n\n    uniformSample(\n      0,\n      estimateTotalArcLength(p0, p1, p2, p3),\n      resolution,\n      (at, t) => {\n        insertPosition(\n          curve,\n          cubicUniformRationalBSpline(p0, p1, p2, p3, t),\n        );\n      },\n    );\n  }\n\n  return curve;\n};\n",
    "functions": {},
    "types": {},
    "variables": {
      "cubicUniformRationalBSpline": "const cubicUniformRationalBSpline = (\n  p0: Vector4,\n  p1: Vector4,\n  p2: Vector4,\n  p3: Vector4,\n  t: number,\n) => {\n  const t2 = t * t;\n  const t3 = t2 * t;\n\n  const b0 = (-t3 + 3 * t2 - 3 * t + 1) / 6;\n  const b1 = (3 * t3 - 6 * t2 + 4) / 6;\n  const b2 = (-3 * t3 + 3 * t2 + 3 * t + 1) / 6;\n  const b3 = t3 / 6;\n\n  const denominator = b0 * p0.w + b1 * p1.w + b2 * p2.w + b3 * p3.w;\n\n  const num = new Vector4()\n    .addScaledVector(p0, b0 * p0.w)\n    .addScaledVector(p1, b1 * p1.w)\n    .addScaledVector(p2, b2 * p2.w)\n    .addScaledVector(p3, b3 * p3.w);\n\n  return new Vector3(num.x, num.y, num.z).divideScalar(denominator);\n};",
      "estimateTotalArcLength": "const estimateTotalArcLength = (\n  p0: Vector4,\n  p1: Vector4,\n  p2: Vector4,\n  p3: Vector4,\n) => {\n  const positions = uniformSampleMap(0, 8, 1, (at, t) =>\n    cubicUniformRationalBSpline(p0, p1, p2, p3, t),\n  );\n\n  return positions\n    .slice(1)\n    .reduce(\n      (arcLength, position, i) =>\n        arcLength + position.distanceTo(positions[i]),\n      0,\n    );\n};",
      "fromPoints": "const fromPoints = (\n  points: Vector4[],\n  resolution: number = 20,\n) => {\n  const curve = emptyCurve();\n  if (points.length < 4) return curve;\n\n  for (let i = 0; i < points.length - 3; i++) {\n    const p0 = points[i];\n    const p1 = points[i + 1];\n    const p2 = points[i + 2];\n    const p3 = points[i + 3];\n\n    uniformSample(\n      0,\n      estimateTotalArcLength(p0, p1, p2, p3),\n      resolution,\n      (at, t) => {\n        insertPosition(\n          curve,\n          cubicUniformRationalBSpline(p0, p1, p2, p3, t),\n        );\n      },\n    );\n  }\n\n  return curve;\n};"
    }
  },
  "src/maths/bezier.ts": {
    "source": "import { Vector3 } from 'three';\n\nimport {\n  uniformSample,\n  uniformSampleMap,\n} from '../helper/uniform-sample';\n\nimport { emptyCurve, insertPosition } from './curve';\n\nexport const deCasteljau = (points: Vector3[], t: number) => {\n  if (points.length < 1)\n    throw new Error(`Expected control points, got ${points.length}`);\n\n  const p = points.map((v) => v.clone());\n\n  for (let k = points.length - 1; k > 0; k--) {\n    for (let i = 0; i < k; i++) {\n      p[i].lerp(p[i + 1], t);\n    }\n  }\n\n  return p[0];\n};\n\nexport const estimateTotalArcLength = (points: Vector3[]) => {\n  const positions = uniformSampleMap(0, 8, 1, (at, t) =>\n    deCasteljau(points, t),\n  );\n\n  return positions\n    .slice(1)\n    .reduce(\n      (arcLength, position, i) =>\n        arcLength + position.distanceTo(positions[i]),\n      0,\n    );\n};\n\nexport const bezierSplineCurve = (\n  points: Vector3[],\n  resolution: number = 20,\n) => {\n  const curve = emptyCurve();\n\n  uniformSample(\n    0,\n    estimateTotalArcLength(points),\n    resolution,\n    (at, t) => {\n      insertPosition(curve, deCasteljau(points, t));\n    },\n  );\n\n  return curve;\n};\n",
    "functions": {},
    "types": {},
    "variables": {
      "deCasteljau": "const deCasteljau = (points: Vector3[], t: number) => {\n  if (points.length < 1)\n    throw new Error(`Expected control points, got ${points.length}`);\n\n  const p = points.map((v) => v.clone());\n\n  for (let k = points.length - 1; k > 0; k--) {\n    for (let i = 0; i < k; i++) {\n      p[i].lerp(p[i + 1], t);\n    }\n  }\n\n  return p[0];\n};",
      "estimateTotalArcLength": "const estimateTotalArcLength = (points: Vector3[]) => {\n  const positions = uniformSampleMap(0, 8, 1, (at, t) =>\n    deCasteljau(points, t),\n  );\n\n  return positions\n    .slice(1)\n    .reduce(\n      (arcLength, position, i) =>\n        arcLength + position.distanceTo(positions[i]),\n      0,\n    );\n};",
      "bezierSplineCurve": "const bezierSplineCurve = (\n  points: Vector3[],\n  resolution: number = 20,\n) => {\n  const curve = emptyCurve();\n\n  uniformSample(\n    0,\n    estimateTotalArcLength(points),\n    resolution,\n    (at, t) => {\n      insertPosition(curve, deCasteljau(points, t));\n    },\n  );\n\n  return curve;\n};"
    }
  },
  "src/maths/cubic.ts": {
    "source": "import { Vector2, Vector3 } from 'three';\n\nimport { lowerBound } from '../helper/binary-search';\nimport { uniformSample } from '../helper/uniform-sample';\n\nimport { emptyCurve, insertPosition } from './curve';\n\nexport const clampedCubicSpline = (\n  points: Vector2[],\n  startSlope: number = 0,\n  endSlope: number = 0,\n) => {\n  const n = points.length - 1;\n\n  const x = points.map((p) => p.x);\n  const y = points.map((p) => p.y);\n  const dx = Array.from({ length: n }, (_, i) => x[i + 1] - x[i]);\n\n  const alpha = Array(n + 1).fill(0);\n\n  // clamped\n  alpha[0] = 3 * ((y[1] - y[0]) / dx[0] + startSlope);\n  alpha[n] = 3 * (endSlope - (y[n] - y[n - 1]) / dx[n - 1]);\n\n  for (let i = 1; i < n; i++) {\n    const sR = (y[i + 1] - y[i]) / dx[i];\n    const sL = (y[i] - y[i - 1]) / dx[i - 1];\n    alpha[i] = 3 * (sR - sL);\n  }\n\n  // solve tridiagonal system\n  const c = Array(n + 1).fill(0);\n  const b = Array(n + 1).fill(0);\n  const d = Array(n + 1).fill(0);\n\n  const l = Array(n + 1).fill(0);\n  const mu = Array(n + 1).fill(0);\n  const z = Array(n + 1).fill(0);\n\n  // start\n  l[0] = 2 * dx[0];\n  mu[0] = 0.5;\n  z[0] = alpha[0] / l[0];\n\n  // inner\n  for (let i = 1; i < n; i++) {\n    l[i] = 2 * (x[i + 1] - x[i - 1]) - dx[i - 1] * mu[i - 1];\n    mu[i] = dx[i] / l[i];\n    z[i] = (alpha[i] - dx[i - 1] * z[i - 1]) / l[i];\n  }\n\n  // end\n  l[n] = dx[n - 1] * (2 - mu[n - 1]);\n  z[n] = (alpha[n] - dx[n - 1] * z[n - 1]) / l[n];\n  c[n] = z[n];\n\n  // back substitution\n  for (let j = n - 1; j >= 0; j--) {\n    c[j] = z[j] - mu[j] * c[j + 1];\n    b[j] =\n      (y[j + 1] - y[j]) / dx[j] - (dx[j] * (c[j + 1] + 2 * c[j])) / 3;\n    d[j] = (c[j + 1] - c[j]) / (3 * dx[j]);\n  }\n\n  return { x, y, b, c, d };\n};\n\nconst evaluate = (\n  s: ReturnType<typeof clampedCubicSpline>,\n  t: number,\n) => {\n  const j = lowerBound(s.x, t, (v) => v);\n  const i = Math.max(0, j - 1);\n  const dx = t - s.x[i];\n\n  return (\n    s.y[i] + s.b[i] * dx + s.c[i] * dx * dx + s.d[i] * dx * dx * dx\n  );\n};\n\nexport const clampedCubicSplineCurve = (\n  points: Vector2[],\n  startSlope: number = 0,\n  endSlope: number = 0,\n  resolution: number = 8,\n) => {\n  if (points.length < 2) return emptyCurve();\n\n  const spline = clampedCubicSpline(points, startSlope, endSlope);\n  const curve = emptyCurve();\n\n  uniformSample(\n    points[0].x,\n    points[points.length - 1].x,\n    resolution,\n    (at) =>\n      insertPosition(curve, new Vector3(at, evaluate(spline, at), 0)),\n  );\n\n  return curve;\n};\n",
    "functions": {},
    "types": {},
    "variables": {
      "clampedCubicSpline": "const clampedCubicSpline = (\n  points: Vector2[],\n  startSlope: number = 0,\n  endSlope: number = 0,\n) => {\n  const n = points.length - 1;\n\n  const x = points.map((p) => p.x);\n  const y = points.map((p) => p.y);\n  const dx = Array.from({ length: n }, (_, i) => x[i + 1] - x[i]);\n\n  const alpha = Array(n + 1).fill(0);\n\n  // clamped\n  alpha[0] = 3 * ((y[1] - y[0]) / dx[0] + startSlope);\n  alpha[n] = 3 * (endSlope - (y[n] - y[n - 1]) / dx[n - 1]);\n\n  for (let i = 1; i < n; i++) {\n    const sR = (y[i + 1] - y[i]) / dx[i];\n    const sL = (y[i] - y[i - 1]) / dx[i - 1];\n    alpha[i] = 3 * (sR - sL);\n  }\n\n  // solve tridiagonal system\n  const c = Array(n + 1).fill(0);\n  const b = Array(n + 1).fill(0);\n  const d = Array(n + 1).fill(0);\n\n  const l = Array(n + 1).fill(0);\n  const mu = Array(n + 1).fill(0);\n  const z = Array(n + 1).fill(0);\n\n  // start\n  l[0] = 2 * dx[0];\n  mu[0] = 0.5;\n  z[0] = alpha[0] / l[0];\n\n  // inner\n  for (let i = 1; i < n; i++) {\n    l[i] = 2 * (x[i + 1] - x[i - 1]) - dx[i - 1] * mu[i - 1];\n    mu[i] = dx[i] / l[i];\n    z[i] = (alpha[i] - dx[i - 1] * z[i - 1]) / l[i];\n  }\n\n  // end\n  l[n] = dx[n - 1] * (2 - mu[n - 1]);\n  z[n] = (alpha[n] - dx[n - 1] * z[n - 1]) / l[n];\n  c[n] = z[n];\n\n  // back substitution\n  for (let j = n - 1; j >= 0; j--) {\n    c[j] = z[j] - mu[j] * c[j + 1];\n    b[j] =\n      (y[j + 1] - y[j]) / dx[j] - (dx[j] * (c[j + 1] + 2 * c[j])) / 3;\n    d[j] = (c[j + 1] - c[j]) / (3 * dx[j]);\n  }\n\n  return { x, y, b, c, d };\n};",
      "evaluate": "const evaluate = (\n  s: ReturnType<typeof clampedCubicSpline>,\n  t: number,\n) => {\n  const j = lowerBound(s.x, t, (v) => v);\n  const i = Math.max(0, j - 1);\n  const dx = t - s.x[i];\n\n  return (\n    s.y[i] + s.b[i] * dx + s.c[i] * dx * dx + s.d[i] * dx * dx * dx\n  );\n};",
      "clampedCubicSplineCurve": "const clampedCubicSplineCurve = (\n  points: Vector2[],\n  startSlope: number = 0,\n  endSlope: number = 0,\n  resolution: number = 8,\n) => {\n  if (points.length < 2) return emptyCurve();\n\n  const spline = clampedCubicSpline(points, startSlope, endSlope);\n  const curve = emptyCurve();\n\n  uniformSample(\n    points[0].x,\n    points[points.length - 1].x,\n    resolution,\n    (at) =>\n      insertPosition(curve, new Vector3(at, evaluate(spline, at), 0)),\n  );\n\n  return curve;\n};"
    }
  },
  "src/maths/curve.ts": {
    "source": "import last from 'lodash/last';\nimport { MathUtils, Matrix4, Vector3 } from 'three';\n\nimport { findBoundingIndices } from '../helper/binary-search';\n\nimport {\n  applyRoll,\n  distance,\n  lerp,\n  parallelTransportTransformation,\n  rollDirection,\n  toForwardDirection,\n  toPosition,\n} from './matrix4';\n\nexport type CurveNode = {\n  transformation: Matrix4;\n  arcLength: number;\n  segmentIndex: number;\n};\n\nexport type Curve = {\n  nodes: CurveNode[];\n  segmentOffsets: number[];\n};\n\nexport const totalArcLength = (curve: Curve) => {\n  return last(curve.nodes)?.arcLength ?? 0;\n};\n\nexport const transformationAtArcLength = (\n  curve: Curve,\n  at: number,\n) => {\n  const nodes = findBoundingIndices(\n    curve.nodes,\n    at,\n    (node) => node.arcLength,\n  );\n  if (!nodes) return new Matrix4();\n\n  const left = curve.nodes[nodes[0]];\n  const right = curve.nodes[nodes[1]];\n\n  const length = right.arcLength - left.arcLength;\n\n  if (length > Number.EPSILON) {\n    const t = MathUtils.clamp(\n      (at - left.arcLength) / length,\n      0.0,\n      1.0,\n    );\n    return lerp(left.transformation, right.transformation, t);\n  }\n\n  return left.transformation.clone();\n};\n\nexport const positionAtX = (curve: Curve, at: number) => {\n  const nodes = findBoundingIndices(\n    curve.nodes,\n    at,\n    (node) => toPosition(node.transformation).x,\n  );\n  if (!nodes) return new Vector3();\n\n  const left = toPosition(curve.nodes[nodes[0]].transformation);\n  const right = toPosition(curve.nodes[nodes[1]].transformation);\n\n  const length = right.x - left.x;\n\n  if (length > Number.EPSILON) {\n    return left.lerp(\n      right,\n      MathUtils.clamp((at - left.x) / length, 0.0, 1.0),\n    );\n  }\n\n  return left;\n};\n\nexport const arcLengthAtOffset = (\n  at: number,\n  segmentOffsets: number[],\n) => {\n  const i = Math.floor(at);\n  const t = at - i;\n\n  const left = segmentOffsets[i] ?? 0;\n  const right = segmentOffsets[i + 1] ?? left;\n\n  return MathUtils.lerp(left, right, t);\n};\n\nexport const insertTransformationMatrix = (\n  curve: Curve,\n  transformation: Matrix4,\n  segmentIndex: number = 0,\n) => {\n  const lastNode = last(curve.nodes);\n\n  let arcLength = 0;\n\n  if (lastNode) {\n    const distanceToLastNode = distance(\n      lastNode.transformation,\n      transformation,\n    );\n    if (distanceToLastNode < Number.EPSILON) return;\n\n    arcLength = lastNode.arcLength + distanceToLastNode;\n  }\n\n  curve.segmentOffsets[segmentIndex + 1] = arcLength;\n\n  curve.nodes.push({\n    arcLength,\n    transformation,\n    segmentIndex,\n  });\n};\n\nexport const insertPosition = (\n  curve: Curve,\n  position: Vector3,\n  segmentIndex: number = 0,\n) => {\n  const lastNode = last(curve.nodes);\n  if (!lastNode)\n    return insertTransformationMatrix(\n      curve,\n      new Matrix4().setPosition(position),\n    );\n\n  if (\n    position.distanceTo(toPosition(lastNode.transformation)) <\n    Number.EPSILON\n  )\n    return;\n\n  if (curve.nodes.length === 1) {\n    lastNode.transformation = parallelTransportTransformation(\n      lastNode.transformation,\n      position,\n    );\n  }\n\n  lastNode.transformation = parallelTransportTransformation(\n    lastNode.transformation,\n    position,\n  );\n\n  return insertTransformationMatrix(\n    curve,\n    lastNode.transformation.clone().setPosition(position),\n    segmentIndex,\n  );\n};\n\nexport const applyRollCurve = (curve: Curve, rollCurve: Curve) => {\n  curve.nodes.forEach(({ transformation, arcLength }) => {\n    applyRoll(transformation, -positionAtX(rollCurve, arcLength).y);\n  });\n\n  return curve;\n};\n\nexport const emptyCurve = (\n  nodes: CurveNode[] = [],\n  segmentOffsets: number[] = [0],\n): Curve => {\n  return {\n    nodes,\n    segmentOffsets,\n  };\n};\n\nexport const fromPoints = (points: Vector3[]) => {\n  const curve = emptyCurve();\n\n  points.forEach((point) => {\n    insertPosition(curve, point);\n  });\n\n  return curve;\n};\n\nexport const toPoints = (curve: Curve) => {\n  return curve.nodes.map((node) => toPosition(node.transformation));\n};\n\nexport const toLocalTransformed = (\n  curve: Curve,\n  translation: Vector3,\n): Curve => {\n  const transformedCurve = emptyCurve();\n\n  curve.nodes.forEach((node) => {\n    insertPosition(\n      transformedCurve,\n      toPosition(\n        node.transformation\n          .clone()\n          .multiply(new Matrix4().makeTranslation(translation)),\n      ),\n      node.segmentIndex,\n    );\n  });\n\n  transformedCurve.nodes.forEach((node, index) => {\n    const position = toPosition(node.transformation);\n    const originalRollDirection = rollDirection(\n      curve.nodes[index].transformation,\n    );\n\n    const front = toForwardDirection(node.transformation);\n    const left = originalRollDirection\n      .sub(\n        front\n          .clone()\n          .multiplyScalar(originalRollDirection.dot(front)),\n      )\n      .normalize();\n\n    const up = new Vector3().crossVectors(front, left).normalize();\n\n    node.transformation = new Matrix4()\n      .makeBasis(left, up, front)\n      .setPosition(position);\n  });\n\n  return transformedCurve;\n};\n",
    "functions": {},
    "types": {
      "CurveNode": "type CurveNode = {\n  transformation: Matrix4;\n  arcLength: number;\n  segmentIndex: number;\n};",
      "Curve": "type Curve = {\n  nodes: CurveNode[];\n  segmentOffsets: number[];\n};"
    },
    "variables": {
      "totalArcLength": "const totalArcLength = (curve: Curve) => {\n  return last(curve.nodes)?.arcLength ?? 0;\n};",
      "transformationAtArcLength": "const transformationAtArcLength = (\n  curve: Curve,\n  at: number,\n) => {\n  const nodes = findBoundingIndices(\n    curve.nodes,\n    at,\n    (node) => node.arcLength,\n  );\n  if (!nodes) return new Matrix4();\n\n  const left = curve.nodes[nodes[0]];\n  const right = curve.nodes[nodes[1]];\n\n  const length = right.arcLength - left.arcLength;\n\n  if (length > Number.EPSILON) {\n    const t = MathUtils.clamp(\n      (at - left.arcLength) / length,\n      0.0,\n      1.0,\n    );\n    return lerp(left.transformation, right.transformation, t);\n  }\n\n  return left.transformation.clone();\n};",
      "positionAtX": "const positionAtX = (curve: Curve, at: number) => {\n  const nodes = findBoundingIndices(\n    curve.nodes,\n    at,\n    (node) => toPosition(node.transformation).x,\n  );\n  if (!nodes) return new Vector3();\n\n  const left = toPosition(curve.nodes[nodes[0]].transformation);\n  const right = toPosition(curve.nodes[nodes[1]].transformation);\n\n  const length = right.x - left.x;\n\n  if (length > Number.EPSILON) {\n    return left.lerp(\n      right,\n      MathUtils.clamp((at - left.x) / length, 0.0, 1.0),\n    );\n  }\n\n  return left;\n};",
      "arcLengthAtOffset": "const arcLengthAtOffset = (\n  at: number,\n  segmentOffsets: number[],\n) => {\n  const i = Math.floor(at);\n  const t = at - i;\n\n  const left = segmentOffsets[i] ?? 0;\n  const right = segmentOffsets[i + 1] ?? left;\n\n  return MathUtils.lerp(left, right, t);\n};",
      "insertTransformationMatrix": "const insertTransformationMatrix = (\n  curve: Curve,\n  transformation: Matrix4,\n  segmentIndex: number = 0,\n) => {\n  const lastNode = last(curve.nodes);\n\n  let arcLength = 0;\n\n  if (lastNode) {\n    const distanceToLastNode = distance(\n      lastNode.transformation,\n      transformation,\n    );\n    if (distanceToLastNode < Number.EPSILON) return;\n\n    arcLength = lastNode.arcLength + distanceToLastNode;\n  }\n\n  curve.segmentOffsets[segmentIndex + 1] = arcLength;\n\n  curve.nodes.push({\n    arcLength,\n    transformation,\n    segmentIndex,\n  });\n};",
      "insertPosition": "const insertPosition = (\n  curve: Curve,\n  position: Vector3,\n  segmentIndex: number = 0,\n) => {\n  const lastNode = last(curve.nodes);\n  if (!lastNode)\n    return insertTransformationMatrix(\n      curve,\n      new Matrix4().setPosition(position),\n    );\n\n  if (\n    position.distanceTo(toPosition(lastNode.transformation)) <\n    Number.EPSILON\n  )\n    return;\n\n  if (curve.nodes.length === 1) {\n    lastNode.transformation = parallelTransportTransformation(\n      lastNode.transformation,\n      position,\n    );\n  }\n\n  lastNode.transformation = parallelTransportTransformation(\n    lastNode.transformation,\n    position,\n  );\n\n  return insertTransformationMatrix(\n    curve,\n    lastNode.transformation.clone().setPosition(position),\n    segmentIndex,\n  );\n};",
      "applyRollCurve": "const applyRollCurve = (curve: Curve, rollCurve: Curve) => {\n  curve.nodes.forEach(({ transformation, arcLength }) => {\n    applyRoll(transformation, -positionAtX(rollCurve, arcLength).y);\n  });\n\n  return curve;\n};",
      "emptyCurve": "const emptyCurve = (\n  nodes: CurveNode[] = [],\n  segmentOffsets: number[] = [0],\n): Curve => {\n  return {\n    nodes,\n    segmentOffsets,\n  };\n};",
      "fromPoints": "const fromPoints = (points: Vector3[]) => {\n  const curve = emptyCurve();\n\n  points.forEach((point) => {\n    insertPosition(curve, point);\n  });\n\n  return curve;\n};",
      "toPoints": "const toPoints = (curve: Curve) => {\n  return curve.nodes.map((node) => toPosition(node.transformation));\n};",
      "toLocalTransformed": "const toLocalTransformed = (\n  curve: Curve,\n  translation: Vector3,\n): Curve => {\n  const transformedCurve = emptyCurve();\n\n  curve.nodes.forEach((node) => {\n    insertPosition(\n      transformedCurve,\n      toPosition(\n        node.transformation\n          .clone()\n          .multiply(new Matrix4().makeTranslation(translation)),\n      ),\n      node.segmentIndex,\n    );\n  });\n\n  transformedCurve.nodes.forEach((node, index) => {\n    const position = toPosition(node.transformation);\n    const originalRollDirection = rollDirection(\n      curve.nodes[index].transformation,\n    );\n\n    const front = toForwardDirection(node.transformation);\n    const left = originalRollDirection\n      .sub(\n        front\n          .clone()\n          .multiplyScalar(originalRollDirection.dot(front)),\n      )\n      .normalize();\n\n    const up = new Vector3().crossVectors(front, left).normalize();\n\n    node.transformation = new Matrix4()\n      .makeBasis(left, up, front)\n      .setPosition(position);\n  });\n\n  return transformedCurve;\n};"
    }
  },
  "src/maths/geometries.ts": {
    "source": "import {\n  BufferAttribute,\n  BufferGeometry,\n  Vector2,\n  Vector3,\n} from 'three';\n\nimport {\n  Curve,\n  totalArcLength,\n  transformationAtArcLength,\n} from './curve';\n\nexport const sweep = (\n  shapes: Vector2[][],\n  curve: Curve,\n  spacing: number,\n) => {\n  const from = 0;\n  const to = totalArcLength(curve);\n  const length = to - from;\n\n  const numberOfNodes = Math.max(Math.ceil(length / spacing) + 1, 2);\n\n  let totalShapePoints = 0;\n  for (const shape of shapes) totalShapePoints += shape.length;\n\n  const positions = new Float32Array(\n    numberOfNodes * totalShapePoints * 3,\n  );\n  const indices = new Uint32Array(\n    (numberOfNodes - 1) * totalShapePoints * 6,\n  );\n\n  let p = 0;\n  let i = 0;\n\n  for (let r = 0; r < numberOfNodes; r++) {\n    const t = r / (numberOfNodes - 1);\n    const at = from + t * length;\n    const matrix = transformationAtArcLength(curve, at);\n\n    const currentShape = r * totalShapePoints;\n    const previousShape = (r - 1) * totalShapePoints;\n\n    let shapeOffset = 0;\n\n    for (const shape of shapes) {\n      for (let s = 0; s < shape.length; s++) {\n        const v = shape[s];\n        const v3 = new Vector3(v.x, v.y, 0).applyMatrix4(matrix);\n\n        positions[p++] = v3.x;\n        positions[p++] = v3.y;\n        positions[p++] = v3.z;\n\n        if (r > 0) {\n          const s1 = (s + 1) % shape.length;\n\n          const a = previousShape + shapeOffset + s;\n          const b = currentShape + shapeOffset + s;\n          const a1 = previousShape + shapeOffset + s1;\n          const b1 = currentShape + shapeOffset + s1;\n\n          indices[i++] = a;\n          indices[i++] = b1;\n          indices[i++] = b;\n\n          indices[i++] = a;\n          indices[i++] = a1;\n          indices[i++] = b1;\n        }\n      }\n\n      shapeOffset += shape.length;\n    }\n  }\n\n  const geometry = new BufferGeometry();\n  geometry.setAttribute(\n    'position',\n    new BufferAttribute(positions, 3),\n  );\n  geometry.setIndex(new BufferAttribute(indices, 1));\n  geometry.computeVertexNormals();\n\n  return geometry;\n};\n",
    "functions": {},
    "types": {},
    "variables": {
      "sweep": "const sweep = (\n  shapes: Vector2[][],\n  curve: Curve,\n  spacing: number,\n) => {\n  const from = 0;\n  const to = totalArcLength(curve);\n  const length = to - from;\n\n  const numberOfNodes = Math.max(Math.ceil(length / spacing) + 1, 2);\n\n  let totalShapePoints = 0;\n  for (const shape of shapes) totalShapePoints += shape.length;\n\n  const positions = new Float32Array(\n    numberOfNodes * totalShapePoints * 3,\n  );\n  const indices = new Uint32Array(\n    (numberOfNodes - 1) * totalShapePoints * 6,\n  );\n\n  let p = 0;\n  let i = 0;\n\n  for (let r = 0; r < numberOfNodes; r++) {\n    const t = r / (numberOfNodes - 1);\n    const at = from + t * length;\n    const matrix = transformationAtArcLength(curve, at);\n\n    const currentShape = r * totalShapePoints;\n    const previousShape = (r - 1) * totalShapePoints;\n\n    let shapeOffset = 0;\n\n    for (const shape of shapes) {\n      for (let s = 0; s < shape.length; s++) {\n        const v = shape[s];\n        const v3 = new Vector3(v.x, v.y, 0).applyMatrix4(matrix);\n\n        positions[p++] = v3.x;\n        positions[p++] = v3.y;\n        positions[p++] = v3.z;\n\n        if (r > 0) {\n          const s1 = (s + 1) % shape.length;\n\n          const a = previousShape + shapeOffset + s;\n          const b = currentShape + shapeOffset + s;\n          const a1 = previousShape + shapeOffset + s1;\n          const b1 = currentShape + shapeOffset + s1;\n\n          indices[i++] = a;\n          indices[i++] = b1;\n          indices[i++] = b;\n\n          indices[i++] = a;\n          indices[i++] = a1;\n          indices[i++] = b1;\n        }\n      }\n\n      shapeOffset += shape.length;\n    }\n  }\n\n  const geometry = new BufferGeometry();\n  geometry.setAttribute(\n    'position',\n    new BufferAttribute(positions, 3),\n  );\n  geometry.setIndex(new BufferAttribute(indices, 1));\n  geometry.computeVertexNormals();\n\n  return geometry;\n};"
    }
  },
  "src/maths/linear.ts": {
    "source": "import { Matrix4, Vector3 } from 'three';\n\nexport const totalArcLength = (cp1: Vector3, cp2: Vector3) =>\n  cp1.distanceTo(cp2);\n\nexport const positionAtArcLength = (\n  cp1: Vector3,\n  cp2: Vector3,\n  at: number,\n) => {\n  return cp1.clone().lerp(cp2, at / totalArcLength(cp1, cp2));\n};\n\nexport const forwardDirectionAtArcLength = (\n  cp1: Vector3,\n  cp2: Vector3,\n  at: number,\n) => {\n  return cp2.clone().sub(cp1).normalize();\n};\n\nexport const transformationAtArcLength = (\n  cp1: Vector3,\n  cp2: Vector3,\n  at: number,\n) => {\n  const position = cp1\n    .clone()\n    .lerp(cp2, at / totalArcLength(cp1, cp2));\n\n  return new Matrix4()\n    .lookAt(cp2, cp1, new Vector3(0, 1, 0))\n    .setPosition(position);\n};\n",
    "functions": {},
    "types": {},
    "variables": {
      "totalArcLength": "const totalArcLength = (cp1: Vector3, cp2: Vector3) =>\n  cp1.distanceTo(cp2);",
      "positionAtArcLength": "const positionAtArcLength = (\n  cp1: Vector3,\n  cp2: Vector3,\n  at: number,\n) => {\n  return cp1.clone().lerp(cp2, at / totalArcLength(cp1, cp2));\n};",
      "forwardDirectionAtArcLength": "const forwardDirectionAtArcLength = (\n  cp1: Vector3,\n  cp2: Vector3,\n  at: number,\n) => {\n  return cp2.clone().sub(cp1).normalize();\n};",
      "transformationAtArcLength": "const transformationAtArcLength = (\n  cp1: Vector3,\n  cp2: Vector3,\n  at: number,\n) => {\n  const position = cp1\n    .clone()\n    .lerp(cp2, at / totalArcLength(cp1, cp2));\n\n  return new Matrix4()\n    .lookAt(cp2, cp1, new Vector3(0, 1, 0))\n    .setPosition(position);\n};"
    }
  },
  "src/maths/matrix4.ts": {
    "source": "import { Matrix4, Quaternion, Vector2, Vector3 } from 'three';\n\nexport const lerp = (\n  matrixA: Matrix4,\n  matrixB: Matrix4,\n  t: number,\n) => {\n  const fromQuaternion = new Quaternion();\n  const toQuaternion = new Quaternion();\n\n  const fromPosition = new Vector3();\n  const toPosition = new Vector3();\n\n  const scale = new Vector3();\n\n  matrixA.decompose(fromPosition, fromQuaternion, scale);\n  matrixB.decompose(toPosition, toQuaternion, scale);\n\n  return new Matrix4().compose(\n    fromPosition.clone().lerp(toPosition, t),\n    fromQuaternion.slerp(toQuaternion, t),\n    scale,\n  );\n};\n\nexport const distance = (from: Matrix4, to: Matrix4) => {\n  return toPosition(from).distanceTo(toPosition(to));\n};\n\nexport const toUpDirection = (m: Matrix4) => {\n  return new Vector3(\n    m.elements[4],\n    m.elements[5],\n    m.elements[6],\n  ).normalize();\n};\n\nexport const toLeftDirection = (m: Matrix4) => {\n  return new Vector3(\n    m.elements[0],\n    m.elements[1],\n    m.elements[2],\n  ).normalize();\n};\n\nexport const toForwardDirection = (m: Matrix4) => {\n  return new Vector3(\n    m.elements[8],\n    m.elements[9],\n    m.elements[10],\n  ).normalize();\n};\n\nexport const toRotationMatrix = (transformation: Matrix4) => {\n  return transformation.clone().setPosition(0, 0, 0);\n};\n\nexport const toPosition = (m: Matrix4) => {\n  return new Vector3(m.elements[12], m.elements[13], m.elements[14]);\n};\n\nexport const parallelTransportTransformation = (\n  transformation: Matrix4,\n  nextPosition: Vector3,\n) => {\n  const position = toPosition(transformation);\n  const direction = position.clone().sub(nextPosition).normalize();\n\n  const rotationMatrix = toRotationMatrix(transformation);\n  const localRotation = new Matrix4().copy(rotationMatrix).invert();\n\n  const relativeDirection = direction\n    .clone()\n    .applyMatrix4(localRotation);\n\n  const relativeDirectionLength = new Vector2(\n    relativeDirection.x,\n    relativeDirection.z,\n  ).length();\n\n  const rotationY = new Matrix4().makeRotationY(\n    Math.atan2(-relativeDirection.x, -relativeDirection.z),\n  );\n  const rotationX = new Matrix4().makeRotationX(\n    Math.atan2(relativeDirection.y, relativeDirectionLength),\n  );\n\n  rotationMatrix.multiply(rotationY);\n  rotationMatrix.multiply(rotationX);\n\n  return rotationMatrix.setPosition(position);\n};\n\nexport const rollDirection = (m: Matrix4) => {\n  const front = toForwardDirection(m);\n  const left = toLeftDirection(m);\n\n  return left\n    .sub(front.clone().multiplyScalar(left.dot(front)))\n    .normalize();\n};\n\nexport const toRollAngle = (m: Matrix4) =>\n  Math.atan2(m.elements[1], m.elements[5]);\n\nexport const applyRoll = (m: Matrix4, roll: number) => {\n  m.multiply(new Matrix4().makeRotationZ(roll));\n  return m;\n};\n",
    "functions": {},
    "types": {},
    "variables": {
      "lerp": "const lerp = (\n  matrixA: Matrix4,\n  matrixB: Matrix4,\n  t: number,\n) => {\n  const fromQuaternion = new Quaternion();\n  const toQuaternion = new Quaternion();\n\n  const fromPosition = new Vector3();\n  const toPosition = new Vector3();\n\n  const scale = new Vector3();\n\n  matrixA.decompose(fromPosition, fromQuaternion, scale);\n  matrixB.decompose(toPosition, toQuaternion, scale);\n\n  return new Matrix4().compose(\n    fromPosition.clone().lerp(toPosition, t),\n    fromQuaternion.slerp(toQuaternion, t),\n    scale,\n  );\n};",
      "distance": "const distance = (from: Matrix4, to: Matrix4) => {\n  return toPosition(from).distanceTo(toPosition(to));\n};",
      "toUpDirection": "const toUpDirection = (m: Matrix4) => {\n  return new Vector3(\n    m.elements[4],\n    m.elements[5],\n    m.elements[6],\n  ).normalize();\n};",
      "toLeftDirection": "const toLeftDirection = (m: Matrix4) => {\n  return new Vector3(\n    m.elements[0],\n    m.elements[1],\n    m.elements[2],\n  ).normalize();\n};",
      "toForwardDirection": "const toForwardDirection = (m: Matrix4) => {\n  return new Vector3(\n    m.elements[8],\n    m.elements[9],\n    m.elements[10],\n  ).normalize();\n};",
      "toRotationMatrix": "const toRotationMatrix = (transformation: Matrix4) => {\n  return transformation.clone().setPosition(0, 0, 0);\n};",
      "toPosition": "const toPosition = (m: Matrix4) => {\n  return new Vector3(m.elements[12], m.elements[13], m.elements[14]);\n};",
      "parallelTransportTransformation": "const parallelTransportTransformation = (\n  transformation: Matrix4,\n  nextPosition: Vector3,\n) => {\n  const position = toPosition(transformation);\n  const direction = position.clone().sub(nextPosition).normalize();\n\n  const rotationMatrix = toRotationMatrix(transformation);\n  const localRotation = new Matrix4().copy(rotationMatrix).invert();\n\n  const relativeDirection = direction\n    .clone()\n    .applyMatrix4(localRotation);\n\n  const relativeDirectionLength = new Vector2(\n    relativeDirection.x,\n    relativeDirection.z,\n  ).length();\n\n  const rotationY = new Matrix4().makeRotationY(\n    Math.atan2(-relativeDirection.x, -relativeDirection.z),\n  );\n  const rotationX = new Matrix4().makeRotationX(\n    Math.atan2(relativeDirection.y, relativeDirectionLength),\n  );\n\n  rotationMatrix.multiply(rotationY);\n  rotationMatrix.multiply(rotationX);\n\n  return rotationMatrix.setPosition(position);\n};",
      "rollDirection": "const rollDirection = (m: Matrix4) => {\n  const front = toForwardDirection(m);\n  const left = toLeftDirection(m);\n\n  return left\n    .sub(front.clone().multiplyScalar(left.dot(front)))\n    .normalize();\n};",
      "toRollAngle": "const toRollAngle = (m: Matrix4) =>\n  Math.atan2(m.elements[1], m.elements[5]);",
      "applyRoll": "const applyRoll = (m: Matrix4, roll: number) => {\n  m.multiply(new Matrix4().makeRotationZ(roll));\n  return m;\n};"
    }
  },
  "src/maths/nurbs.ts": {
    "source": "import { MathUtils, Vector3, Vector4 } from 'three';\n\nimport { lowerBound } from '../helper/binary-search';\nimport {\n  uniformSample,\n  uniformSampleMap,\n} from '../helper/uniform-sample';\n\nimport { Curve, emptyCurve, insertPosition } from './curve';\n\nexport const makeClampedKnots = (\n  points: Vector4[],\n  degree: number,\n): number[] => {\n  const n = points.length - 1;\n  const knotCount = n + degree + 2;\n  const knots = new Array<number>(knotCount);\n\n  for (let i = 0; i <= degree; i++) {\n    knots[i] = 0;\n  }\n\n  for (let i = 1; i <= n - degree; i++) {\n    knots[degree + i] = i;\n  }\n\n  for (let i = knotCount - degree - 1; i < knotCount; i++) {\n    knots[i] = n - degree + 1;\n  }\n\n  return knots;\n};\n\nexport const makeUniformKnots = (\n  points: Vector4[],\n  degree: number,\n): number[] => {\n  const n = points.length - 1;\n  const knotCount = n + degree + 2;\n\n  const knots = new Array<number>(knotCount);\n\n  for (let i = 0; i < knotCount; i++) {\n    knots[i] = i - degree;\n  }\n\n  return knots;\n};\n\nconst deBoor = (\n  points: Vector4[],\n  knots: number[],\n  degree: number,\n  k: number,\n  i: number,\n  t: number,\n): Vector4 => {\n  if (k === 0) {\n    return new Vector4(\n      points[i].x,\n      points[i].y,\n      points[i].z,\n    ).multiplyScalar(points[i].w);\n  }\n\n  const alpha =\n    (t - knots[i]) / (knots[i + degree + 1 - k] - knots[i]);\n\n  const p0 = deBoor(points, knots, degree, k - 1, i - 1, t);\n  const p1 = deBoor(points, knots, degree, k - 1, i, t);\n\n  return p0.lerp(p1, alpha);\n};\n\nexport const evaluate = (\n  points: Vector4[],\n  knots: number[],\n  degree: number,\n  t: number,\n) => {\n  const knotIndex = MathUtils.clamp(\n    lowerBound(knots, t, (v) => v) - 1,\n    degree,\n    knots.length - degree - 2,\n  );\n\n  const p = deBoor(points, knots, degree, degree, knotIndex, t);\n  return new Vector3(p.x, p.y, p.z).divideScalar(p.w);\n};\n\nexport const intervals = (knots: number[], degree: number) => {\n  return knots.slice(degree, knots.length - degree);\n};\n\nexport const estimateLength = (\n  points: Vector4[],\n  knots: number[],\n  degree: number,\n  min: number,\n  max: number,\n) => {\n  const positions = uniformSampleMap(\n    min,\n    max,\n    Math.ceil(max - min),\n    (at, t) => evaluate(points, knots, degree, t),\n  );\n\n  return positions\n    .slice(1)\n    .reduce(\n      (arcLength, position, i) =>\n        arcLength + position.distanceTo(positions[i]),\n      0,\n    );\n};\n\nexport const fromPoints = (\n  points: Vector4[],\n  knotVectorFactory: (points: Vector4[], degree: number) => number[],\n  out: Curve = emptyCurve(),\n  resolution: number = 20,\n  maxDegree: number = 3,\n  minSegmentIndex: number = 0,\n) => {\n  const numberOfPoints = points.length;\n  const degree = Math.min(numberOfPoints - 1, maxDegree);\n  const knots = knotVectorFactory(points, degree);\n\n  intervals(knots, degree).forEach((_, index, intervals) => {\n    const min = intervals[index];\n    const max = intervals[index + 1];\n    if (!max) return;\n\n    uniformSample(\n      min,\n      max,\n      estimateLength(points, knots, degree, min, max) * resolution,\n      (at) => {\n        insertPosition(\n          out,\n          evaluate(points, knots, degree, at),\n          minSegmentIndex + min,\n        );\n      },\n    );\n  });\n\n  return out;\n};\n",
    "functions": {},
    "types": {},
    "variables": {
      "makeClampedKnots": "const makeClampedKnots = (\n  points: Vector4[],\n  degree: number,\n): number[] => {\n  const n = points.length - 1;\n  const knotCount = n + degree + 2;\n  const knots = new Array<number>(knotCount);\n\n  for (let i = 0; i <= degree; i++) {\n    knots[i] = 0;\n  }\n\n  for (let i = 1; i <= n - degree; i++) {\n    knots[degree + i] = i;\n  }\n\n  for (let i = knotCount - degree - 1; i < knotCount; i++) {\n    knots[i] = n - degree + 1;\n  }\n\n  return knots;\n};",
      "makeUniformKnots": "const makeUniformKnots = (\n  points: Vector4[],\n  degree: number,\n): number[] => {\n  const n = points.length - 1;\n  const knotCount = n + degree + 2;\n\n  const knots = new Array<number>(knotCount);\n\n  for (let i = 0; i < knotCount; i++) {\n    knots[i] = i - degree;\n  }\n\n  return knots;\n};",
      "deBoor": "const deBoor = (\n  points: Vector4[],\n  knots: number[],\n  degree: number,\n  k: number,\n  i: number,\n  t: number,\n): Vector4 => {\n  if (k === 0) {\n    return new Vector4(\n      points[i].x,\n      points[i].y,\n      points[i].z,\n    ).multiplyScalar(points[i].w);\n  }\n\n  const alpha =\n    (t - knots[i]) / (knots[i + degree + 1 - k] - knots[i]);\n\n  const p0 = deBoor(points, knots, degree, k - 1, i - 1, t);\n  const p1 = deBoor(points, knots, degree, k - 1, i, t);\n\n  return p0.lerp(p1, alpha);\n};",
      "evaluate": "const evaluate = (\n  points: Vector4[],\n  knots: number[],\n  degree: number,\n  t: number,\n) => {\n  const knotIndex = MathUtils.clamp(\n    lowerBound(knots, t, (v) => v) - 1,\n    degree,\n    knots.length - degree - 2,\n  );\n\n  const p = deBoor(points, knots, degree, degree, knotIndex, t);\n  return new Vector3(p.x, p.y, p.z).divideScalar(p.w);\n};",
      "intervals": "const intervals = (knots: number[], degree: number) => {\n  return knots.slice(degree, knots.length - degree);\n};",
      "estimateLength": "const estimateLength = (\n  points: Vector4[],\n  knots: number[],\n  degree: number,\n  min: number,\n  max: number,\n) => {\n  const positions = uniformSampleMap(\n    min,\n    max,\n    Math.ceil(max - min),\n    (at, t) => evaluate(points, knots, degree, t),\n  );\n\n  return positions\n    .slice(1)\n    .reduce(\n      (arcLength, position, i) =>\n        arcLength + position.distanceTo(positions[i]),\n      0,\n    );\n};",
      "fromPoints": "const fromPoints = (\n  points: Vector4[],\n  knotVectorFactory: (points: Vector4[], degree: number) => number[],\n  out: Curve = emptyCurve(),\n  resolution: number = 20,\n  maxDegree: number = 3,\n  minSegmentIndex: number = 0,\n) => {\n  const numberOfPoints = points.length;\n  const degree = Math.min(numberOfPoints - 1, maxDegree);\n  const knots = knotVectorFactory(points, degree);\n\n  intervals(knots, degree).forEach((_, index, intervals) => {\n    const min = intervals[index];\n    const max = intervals[index + 1];\n    if (!max) return;\n\n    uniformSample(\n      min,\n      max,\n      estimateLength(points, knots, degree, min, max) * resolution,\n      (at) => {\n        insertPosition(\n          out,\n          evaluate(points, knots, degree, at),\n          minSegmentIndex + min,\n        );\n      },\n    );\n  });\n\n  return out;\n};"
    }
  },
  "src/maths/shapes.ts": {
    "source": "import { Vector2 } from 'three';\n\nexport const makeCircleShape = (\n  radius: number,\n  segments: number,\n  offset: Vector2 = new Vector2(0, 0),\n): Vector2[] => {\n  const points: Vector2[] = [];\n\n  for (let i = 0; i < segments; i++) {\n    const t = (i / segments) * Math.PI * 2;\n    points.push(\n      new Vector2(\n        Math.cos(t) * radius + offset.x,\n        Math.sin(t) * radius + offset.y,\n      ),\n    );\n  }\n\n  return points;\n};\n",
    "functions": {},
    "types": {},
    "variables": {
      "makeCircleShape": "const makeCircleShape = (\n  radius: number,\n  segments: number,\n  offset: Vector2 = new Vector2(0, 0),\n): Vector2[] => {\n  const points: Vector2[] = [];\n\n  for (let i = 0; i < segments; i++) {\n    const t = (i / segments) * Math.PI * 2;\n    points.push(\n      new Vector2(\n        Math.cos(t) * radius + offset.x,\n        Math.sin(t) * radius + offset.y,\n      ),\n    );\n  }\n\n  return points;\n};"
    }
  },
  "src/pages/ContentComponentsListPage.tsx": {
    "source": "import React from 'react';\n\nimport { router } from '../index';\n\nexport const ContentComponentsListPage = () => {\n  return (\n    <ul>\n      {router.routes\n        .filter(({ path }) => path !== '/')\n        .map(({ path }) => {\n          const fullPath = `${path?.replace('./', '/')}`;\n          return (\n            <li key={fullPath}>\n              <a href={fullPath}>{fullPath}</a>\n            </li>\n          );\n        })}\n    </ul>\n  );\n};\n",
    "functions": {},
    "types": {},
    "variables": {
      "ContentComponentsListPage": "const ContentComponentsListPage = () => {\n  return (\n    <ul>\n      {router.routes\n        .filter(({ path }) => path !== '/')\n        .map(({ path }) => {\n          const fullPath = `${path?.replace('./', '/')}`;\n          return (\n            <li key={fullPath}>\n              <a href={fullPath}>{fullPath}</a>\n            </li>\n          );\n        })}\n    </ul>\n  );\n};"
    }
  },
  "src/components/camera/CameraViewManager.tsx": {
    "source": "import React, {\n  createContext,\n  ReactNode,\n  useCallback,\n  useContext,\n  useEffect,\n  useMemo,\n  useState,\n} from 'react';\nimport { useControls } from 'leva';\n\nimport { LoadingScreen } from '../LoadingScreen';\n\ntype CameraViewManagerContextType = {\n  registerView: (name: string, makeDefault?: boolean) => void;\n  unregisterView: (name: string) => void;\n  activeView?: string;\n};\n\nconst CameraViewManagerContext =\n  createContext<CameraViewManagerContextType | null>(null);\n\nexport const useCameraViewManager = () => {\n  const ctx = useContext(CameraViewManagerContext);\n  if (!ctx) {\n    throw new Error(\n      'CameraView must be used within CameraViewManager',\n    );\n  }\n  return ctx;\n};\nexport const CameraViewManager: React.FC<{ children: ReactNode }> = ({\n  children,\n}) => {\n  const [views, setViews] = useState<string[]>([]);\n  const [showLoading, setShowLoading] = useState(true);\n\n  const [{ activeView }, setCameraViews] = useControls(\n    'Camera Views',\n    () => ({\n      activeView: {\n        options: views,\n      },\n    }),\n    [views],\n  );\n\n  useEffect(() => {\n    const id = setTimeout(() => setShowLoading(false), 500);\n    return () => clearTimeout(id);\n  }, []);\n\n  const registerView = useCallback(\n    (name: string, makeDefault?: boolean) => {\n      setViews((prev) => [...prev, name]);\n      if (makeDefault)\n        setTimeout(() => setCameraViews({ activeView: name }), 50);\n    },\n    [setCameraViews],\n  );\n\n  const unregisterView = useCallback((name: string) => {\n    setViews((prev) => prev.filter((view) => view !== name));\n  }, []);\n\n  const contextValue = useMemo(\n    () => ({\n      registerView,\n      unregisterView,\n      activeView,\n    }),\n    [registerView, unregisterView, activeView],\n  );\n\n  return (\n    <CameraViewManagerContext.Provider value={contextValue}>\n      {children}\n      {showLoading && <LoadingScreen />}\n    </CameraViewManagerContext.Provider>\n  );\n};\n\nexport const CameraView: React.FC<{\n  name: string;\n  makeDefault?: boolean;\n  children: ReactNode;\n}> = ({ name, makeDefault, children }) => {\n  const { registerView, unregisterView, activeView } =\n    useCameraViewManager();\n\n  useEffect(() => {\n    registerView(name, makeDefault);\n    return () => unregisterView(name);\n  }, [name, makeDefault, registerView, unregisterView]);\n\n  if (activeView !== name) return null;\n\n  return <>{children}</>;\n};\n",
    "functions": {},
    "types": {
      "CameraViewManagerContextType": "type CameraViewManagerContextType = {\n  registerView: (name: string, makeDefault?: boolean) => void;\n  unregisterView: (name: string) => void;\n  activeView?: string;\n};"
    },
    "variables": {
      "CameraViewManagerContext": "const CameraViewManagerContext =\n  createContext<CameraViewManagerContextType | null>(null);",
      "useCameraViewManager": "const useCameraViewManager = () => {\n  const ctx = useContext(CameraViewManagerContext);\n  if (!ctx) {\n    throw new Error(\n      'CameraView must be used within CameraViewManager',\n    );\n  }\n  return ctx;\n};",
      "CameraViewManager": "const CameraViewManager: React.FC<{ children: ReactNode }> = ({\n  children,\n}) => {\n  const [views, setViews] = useState<string[]>([]);\n  const [showLoading, setShowLoading] = useState(true);\n\n  const [{ activeView }, setCameraViews] = useControls(\n    'Camera Views',\n    () => ({\n      activeView: {\n        options: views,\n      },\n    }),\n    [views],\n  );\n\n  useEffect(() => {\n    const id = setTimeout(() => setShowLoading(false), 500);\n    return () => clearTimeout(id);\n  }, []);\n\n  const registerView = useCallback(\n    (name: string, makeDefault?: boolean) => {\n      setViews((prev) => [...prev, name]);\n      if (makeDefault)\n        setTimeout(() => setCameraViews({ activeView: name }), 50);\n    },\n    [setCameraViews],\n  );\n\n  const unregisterView = useCallback((name: string) => {\n    setViews((prev) => prev.filter((view) => view !== name));\n  }, []);\n\n  const contextValue = useMemo(\n    () => ({\n      registerView,\n      unregisterView,\n      activeView,\n    }),\n    [registerView, unregisterView, activeView],\n  );\n\n  return (\n    <CameraViewManagerContext.Provider value={contextValue}>\n      {children}\n      {showLoading && <LoadingScreen />}\n    </CameraViewManagerContext.Provider>\n  );\n};",
      "CameraView": "const CameraView: React.FC<{\n  name: string;\n  makeDefault?: boolean;\n  children: ReactNode;\n}> = ({ name, makeDefault, children }) => {\n  const { registerView, unregisterView, activeView } =\n    useCameraViewManager();\n\n  useEffect(() => {\n    registerView(name, makeDefault);\n    return () => unregisterView(name);\n  }, [name, makeDefault, registerView, unregisterView]);\n\n  if (activeView !== name) return null;\n\n  return <>{children}</>;\n};"
    }
  },
  "src/components/camera/OrthographicCameraControls.tsx": {
    "source": "import React from 'react';\nimport {\n  CameraControls,\n  CameraControlsImpl,\n} from '@react-three/drei';\nimport { CameraControlsProps } from '@react-three/drei/core/CameraControls';\n\nexport const OrthographicCameraControls = (\n  props: CameraControlsProps,\n) => {\n  return (\n    <CameraControls\n      mouseButtons={{\n        left: CameraControlsImpl.ACTION.NONE,\n        right: CameraControlsImpl.ACTION.TRUCK,\n        wheel: CameraControlsImpl.ACTION.ZOOM,\n        middle: CameraControlsImpl.ACTION.NONE,\n      }}\n      makeDefault\n      dollySpeed={0.4}\n      dollyToCursor={true}\n      draggingSmoothTime={0.03}\n      {...props}\n    />\n  );\n};\n",
    "functions": {},
    "types": {},
    "variables": {
      "OrthographicCameraControls": "const OrthographicCameraControls = (\n  props: CameraControlsProps,\n) => {\n  return (\n    <CameraControls\n      mouseButtons={{\n        left: CameraControlsImpl.ACTION.NONE,\n        right: CameraControlsImpl.ACTION.TRUCK,\n        wheel: CameraControlsImpl.ACTION.ZOOM,\n        middle: CameraControlsImpl.ACTION.NONE,\n      }}\n      makeDefault\n      dollySpeed={0.4}\n      dollyToCursor={true}\n      draggingSmoothTime={0.03}\n      {...props}\n    />\n  );\n};"
    }
  },
  "src/components/camera/PerspectiveCameraControls.tsx": {
    "source": "import React from 'react';\nimport {\n  CameraControls,\n  CameraControlsImpl,\n} from '@react-three/drei';\nimport { CameraControlsProps } from '@react-three/drei/core/CameraControls';\n\nexport const PerspectiveCameraControls = (\n  props: CameraControlsProps,\n) => {\n  return (\n    <CameraControls\n      dollyToCursor={true}\n      draggingSmoothTime={0.03}\n      dollySpeed={0.4}\n      infinityDolly={true}\n      dollyDragInverted={true}\n      minDistance={0}\n      maxDistance={Infinity}\n      mouseButtons={{\n        left: CameraControlsImpl.ACTION.ROTATE,\n        right: CameraControlsImpl.ACTION.TRUCK,\n        wheel: CameraControlsImpl.ACTION.DOLLY,\n        middle: CameraControlsImpl.ACTION.NONE,\n      }}\n      {...props}\n    />\n  );\n};\n",
    "functions": {},
    "types": {},
    "variables": {
      "PerspectiveCameraControls": "const PerspectiveCameraControls = (\n  props: CameraControlsProps,\n) => {\n  return (\n    <CameraControls\n      dollyToCursor={true}\n      draggingSmoothTime={0.03}\n      dollySpeed={0.4}\n      infinityDolly={true}\n      dollyDragInverted={true}\n      minDistance={0}\n      maxDistance={Infinity}\n      mouseButtons={{\n        left: CameraControlsImpl.ACTION.ROTATE,\n        right: CameraControlsImpl.ACTION.TRUCK,\n        wheel: CameraControlsImpl.ACTION.DOLLY,\n        middle: CameraControlsImpl.ACTION.NONE,\n      }}\n      {...props}\n    />\n  );\n};"
    }
  },
  "src/components/camera/TransformationMatrixCamera.tsx": {
    "source": "import React, { useMemo } from 'react';\nimport { PerspectiveCamera } from '@react-three/drei';\nimport { PerspectiveCameraProps } from '@react-three/drei/core/PerspectiveCamera';\nimport { MathUtils, Matrix4, Vector3 } from 'three';\n\nexport const TransformationMatrixCamera = ({\n  matrix = new Matrix4(),\n  translate = new Vector3(),\n  fov = 100,\n  ...props\n}: { translate?: Vector3; matrix: Matrix4 } & Omit<\n  PerspectiveCameraProps,\n  'matrixAutoUpdate' | 'matrix'\n>) => {\n  const perspectiveMatrix = useMemo(\n    () =>\n      matrix\n        .clone()\n        .multiply(\n          new Matrix4().makeRotationY(MathUtils.degToRad(180)),\n        )\n        .multiply(\n          new Matrix4().makeTranslation(\n            translate.x,\n            translate.y,\n            translate.z,\n          ),\n        ),\n    [matrix, translate.x, translate.y, translate.z],\n  );\n\n  return (\n    <PerspectiveCamera\n      fov={fov}\n      matrix={perspectiveMatrix}\n      matrixAutoUpdate={false}\n      {...props}\n    />\n  );\n};\n",
    "functions": {},
    "types": {},
    "variables": {
      "TransformationMatrixCamera": "const TransformationMatrixCamera = ({\n  matrix = new Matrix4(),\n  translate = new Vector3(),\n  fov = 100,\n  ...props\n}: { translate?: Vector3; matrix: Matrix4 } & Omit<\n  PerspectiveCameraProps,\n  'matrixAutoUpdate' | 'matrix'\n>) => {\n  const perspectiveMatrix = useMemo(\n    () =>\n      matrix\n        .clone()\n        .multiply(\n          new Matrix4().makeRotationY(MathUtils.degToRad(180)),\n        )\n        .multiply(\n          new Matrix4().makeTranslation(\n            translate.x,\n            translate.y,\n            translate.z,\n          ),\n        ),\n    [matrix, translate.x, translate.y, translate.z],\n  );\n\n  return (\n    <PerspectiveCamera\n      fov={fov}\n      matrix={perspectiveMatrix}\n      matrixAutoUpdate={false}\n      {...props}\n    />\n  );\n};"
    }
  },
  "src/components/curve/BezierCurve.tsx": {
    "source": "import React, { useMemo } from 'react';\nimport { Line } from '@react-three/drei';\nimport { Vector3 } from 'three';\n\nimport { bezierSplineCurve } from '../../maths/bezier';\nimport {\n  totalArcLength,\n  transformationAtArcLength,\n} from '../../maths/curve';\nimport { toPosition } from '../../maths/matrix4';\nimport { uniformSampleMap } from '../../helper/uniform-sample';\nimport { useColors } from '../../hooks/useColors';\n\nimport { ControlPoint } from './ControlPoint';\n\nexport const BezierCurve = (props: {\n  points: Vector3[];\n  resolution?: number;\n  uniform?: boolean;\n  showNodes?: boolean;\n  color?: number;\n}) => {\n  const {\n    points,\n    resolution = 20,\n    uniform = false,\n    showNodes = false,\n    color,\n  } = props;\n\n  const colors = useColors();\n\n  const nodes = useMemo(() => {\n    const curve = bezierSplineCurve(points, resolution);\n\n    const parametricNodes = curve.nodes.map((node) =>\n      toPosition(node.transformation),\n    );\n\n    const uniformNodes = uniformSampleMap(\n      0,\n      totalArcLength(curve),\n      resolution,\n      (at) => toPosition(transformationAtArcLength(curve, at)),\n    );\n\n    return uniform ? uniformNodes : parametricNodes;\n  }, [points, resolution, uniform]);\n\n  return (\n    <>\n      {showNodes &&\n        nodes.map((position, i) => (\n          <ControlPoint size=\"sm\" key={i} position={position} />\n        ))}\n\n      {!!nodes.length && (\n        <Line points={nodes} color={color || colors.secondary} />\n      )}\n    </>\n  );\n};\n",
    "functions": {},
    "types": {},
    "variables": {
      "BezierCurve": "const BezierCurve = (props: {\n  points: Vector3[];\n  resolution?: number;\n  uniform?: boolean;\n  showNodes?: boolean;\n  color?: number;\n}) => {\n  const {\n    points,\n    resolution = 20,\n    uniform = false,\n    showNodes = false,\n    color,\n  } = props;\n\n  const colors = useColors();\n\n  const nodes = useMemo(() => {\n    const curve = bezierSplineCurve(points, resolution);\n\n    const parametricNodes = curve.nodes.map((node) =>\n      toPosition(node.transformation),\n    );\n\n    const uniformNodes = uniformSampleMap(\n      0,\n      totalArcLength(curve),\n      resolution,\n      (at) => toPosition(transformationAtArcLength(curve, at)),\n    );\n\n    return uniform ? uniformNodes : parametricNodes;\n  }, [points, resolution, uniform]);\n\n  return (\n    <>\n      {showNodes &&\n        nodes.map((position, i) => (\n          <ControlPoint size=\"sm\" key={i} position={position} />\n        ))}\n\n      {!!nodes.length && (\n        <Line points={nodes} color={color || colors.secondary} />\n      )}\n    </>\n  );\n};"
    }
  },
  "src/components/curve/ControlPoint.tsx": {
    "source": "import React from 'react';\nimport { ThreeElements } from '@react-three/fiber';\n\nimport { useColors } from '../../hooks/useColors';\n\ntype Size = 'sm' | 'md';\n\nconst sizes: Record<Size, number> = {\n  sm: 0.1,\n  md: 0.2,\n};\n\nexport const ControlPoint = (\n  props: { size?: Size; color?: number } & ThreeElements['mesh'],\n) => {\n  const { size = 'md', color = undefined, ...restProps } = props;\n\n  const colors = useColors();\n\n  return (\n    <mesh {...restProps}>\n      <sphereGeometry args={[sizes[size], 6, 6]} />\n      <meshBasicMaterial color={color || colors.secondary} />\n    </mesh>\n  );\n};\n",
    "functions": {},
    "types": {
      "Size": "type Size = 'sm' | 'md';"
    },
    "variables": {
      "sizes": "const sizes: Record<Size, number> = {\n  sm: 0.1,\n  md: 0.2,\n};",
      "ControlPoint": "const ControlPoint = (\n  props: { size?: Size; color?: number } & ThreeElements['mesh'],\n) => {\n  const { size = 'md', color = undefined, ...restProps } = props;\n\n  const colors = useColors();\n\n  return (\n    <mesh {...restProps}>\n      <sphereGeometry args={[sizes[size], 6, 6]} />\n      <meshBasicMaterial color={color || colors.secondary} />\n    </mesh>\n  );\n};"
    }
  },
  "src/components/curve/CurveLine.tsx": {
    "source": "import React, { useMemo } from 'react';\nimport { Line } from '@react-three/drei';\nimport { LineProps } from '@react-three/drei/core/Line';\n\nimport { Curve, toPoints } from '../../maths/curve';\n\nexport const CurveLine = ({\n  curve,\n  ...props\n}: { curve: Curve } & Omit<LineProps, 'points'>) => {\n  const points = useMemo(() => toPoints(curve), [curve]);\n  return <Line {...props} points={points} />;\n};\n",
    "functions": {},
    "types": {},
    "variables": {
      "CurveLine": "const CurveLine = ({\n  curve,\n  ...props\n}: { curve: Curve } & Omit<LineProps, 'points'>) => {\n  const points = useMemo(() => toPoints(curve), [curve]);\n  return <Line {...props} points={points} />;\n};"
    }
  },
  "src/components/curve/CurveTrackMesh.tsx": {
    "source": "import React, { FunctionComponent, useMemo } from 'react';\nimport * as THREE from 'three';\nimport { MeshStandardMaterial, Vector2 } from 'three';\nimport { TDSLoader } from 'three/examples/jsm/loaders/TDSLoader';\n\nimport {\n  Curve,\n  totalArcLength,\n  transformationAtArcLength,\n} from '../../maths/curve';\nimport { sweep } from '../../maths/geometries';\nimport { makeCircleShape } from '../../maths/shapes';\nimport { bufferGeometriesFromObject3D } from '../../helper/three';\nimport { uniformSampleMap } from '../../helper/uniform-sample';\nimport { useColors } from '../../hooks/useColors';\n\nimport Tie from '../../experiments/tie.3ds';\n\nconst tieGeometries = bufferGeometriesFromObject3D(\n  await new TDSLoader().loadAsync(Tie),\n  new THREE.Matrix4()\n    .makeRotationX(-Math.PI / 2)\n    .multiply(new THREE.Matrix4().makeScale(0.0254, 0.0254, 0.0254)),\n);\n\nexport const CurveTrackMesh: FunctionComponent<{ curve: Curve }> = ({\n  curve,\n}) => {\n  const colors = useColors();\n\n  const rails = useMemo(\n    () =>\n      sweep(\n        [\n          makeCircleShape(0.07, 12, new Vector2(-0.45, 0)),\n          makeCircleShape(0.07, 12, new Vector2(0.45, 0)),\n          makeCircleShape(0.2, 8, new Vector2(0, -0.4)),\n        ],\n        curve,\n        0.1,\n      ),\n    [curve],\n  );\n\n  const tieMaterial = useMemo(\n    () => new MeshStandardMaterial({ color: colors.highlight }),\n    [colors.highlight],\n  );\n\n  const ties = useMemo(() => {\n    const matrices = uniformSampleMap(\n      0,\n      totalArcLength(curve),\n      1.25,\n      (at) => transformationAtArcLength(curve, at),\n    );\n\n    return tieGeometries.map((geometry, gi) => {\n      const instanced = new THREE.InstancedMesh(\n        geometry,\n        tieMaterial,\n        matrices.length,\n      );\n\n      matrices.forEach((matrix, i) => {\n        instanced.setMatrixAt(i, matrix.clone());\n      });\n\n      instanced.instanceMatrix.needsUpdate = true;\n\n      return (\n        <primitive\n          receiveShadow={true}\n          castShadow={true}\n          key={gi}\n          object={instanced}\n        />\n      );\n    });\n  }, [curve, tieMaterial]);\n\n  return (\n    <>\n      {ties}\n      <mesh receiveShadow={true} castShadow={true} geometry={rails}>\n        <meshStandardMaterial color={colors.highlight} />\n      </mesh>\n    </>\n  );\n};\n",
    "functions": {},
    "types": {},
    "variables": {
      "tieGeometries": "const tieGeometries = bufferGeometriesFromObject3D(\n  await new TDSLoader().loadAsync(Tie),\n  new THREE.Matrix4()\n    .makeRotationX(-Math.PI / 2)\n    .multiply(new THREE.Matrix4().makeScale(0.0254, 0.0254, 0.0254)),\n);",
      "CurveTrackMesh": "const CurveTrackMesh: FunctionComponent<{ curve: Curve }> = ({\n  curve,\n}) => {\n  const colors = useColors();\n\n  const rails = useMemo(\n    () =>\n      sweep(\n        [\n          makeCircleShape(0.07, 12, new Vector2(-0.45, 0)),\n          makeCircleShape(0.07, 12, new Vector2(0.45, 0)),\n          makeCircleShape(0.2, 8, new Vector2(0, -0.4)),\n        ],\n        curve,\n        0.1,\n      ),\n    [curve],\n  );\n\n  const tieMaterial = useMemo(\n    () => new MeshStandardMaterial({ color: colors.highlight }),\n    [colors.highlight],\n  );\n\n  const ties = useMemo(() => {\n    const matrices = uniformSampleMap(\n      0,\n      totalArcLength(curve),\n      1.25,\n      (at) => transformationAtArcLength(curve, at),\n    );\n\n    return tieGeometries.map((geometry, gi) => {\n      const instanced = new THREE.InstancedMesh(\n        geometry,\n        tieMaterial,\n        matrices.length,\n      );\n\n      matrices.forEach((matrix, i) => {\n        instanced.setMatrixAt(i, matrix.clone());\n      });\n\n      instanced.instanceMatrix.needsUpdate = true;\n\n      return (\n        <primitive\n          receiveShadow={true}\n          castShadow={true}\n          key={gi}\n          object={instanced}\n        />\n      );\n    });\n  }, [curve, tieMaterial]);\n\n  return (\n    <>\n      {ties}\n      <mesh receiveShadow={true} castShadow={true} geometry={rails}>\n        <meshStandardMaterial color={colors.highlight} />\n      </mesh>\n    </>\n  );\n};"
    }
  },
  "src/components/curve/CurveWireframe.tsx": {
    "source": "import React, { useMemo } from 'react';\nimport { Line } from '@react-three/drei';\nimport { LineProps } from '@react-three/drei/core/Line';\nimport { Vector3 } from 'three';\n\nimport {\n  Curve,\n  totalArcLength,\n  transformationAtArcLength,\n} from '../../maths/curve';\nimport { useColors } from '../../hooks/useColors';\n\nconst wireFrameParts = [\n  new Vector3(0.45, 0, 0),\n  new Vector3(0, -0.4, 0),\n  new Vector3(-0.45, 0, 0),\n];\n\nexport const CurveWireframe = ({\n  railSpacing = 0.25,\n  tieSpacing = 0.75,\n  loopTie = true,\n  tie = wireFrameParts,\n  rails = wireFrameParts,\n  curve,\n  ...props\n}: {\n  curve: Curve;\n  railSpacing?: number;\n  tieSpacing?: number;\n  tie?: Vector3[];\n  rails?: Vector3[];\n  loopTie?: boolean;\n  offset?: Vector3;\n} & Omit<LineProps, 'points'>) => {\n  const colors = useColors();\n\n  const points = useMemo(() => {\n    const curveLength = totalArcLength(curve);\n    const numNodes = Math.floor(curveLength / railSpacing);\n\n    const points: Vector3[] = [];\n    let tieDistance = 0;\n\n    for (let k = 0; k < numNodes - 1; k++) {\n      const currentArcLength: number =\n        (k / (numNodes - 1)) * curveLength;\n      const currentMatrixAtArcLength = transformationAtArcLength(\n        curve,\n        currentArcLength,\n      );\n\n      const nextArcLength: number =\n        ((k + 1) / (numNodes - 1)) * curveLength;\n      const nextMatrixAtArcLength = transformationAtArcLength(\n        curve,\n        nextArcLength,\n      );\n\n      for (let k = 0; k < rails.length; k++) {\n        const currentPos = rails[k]\n          .clone()\n          .applyMatrix4(currentMatrixAtArcLength);\n        const nextPos = rails[k]\n          .clone()\n          .applyMatrix4(nextMatrixAtArcLength);\n\n        points.push(\n          new Vector3(currentPos.x, currentPos.y, currentPos.z),\n        );\n        points.push(new Vector3(nextPos.x, nextPos.y, nextPos.z));\n      }\n\n      if (tieDistance > tieSpacing) {\n        for (\n          let k = 0;\n          k < (loopTie ? tie.length : tie.length - 1);\n          k++\n        ) {\n          const currentPos = tie[k % tie.length]\n            .clone()\n            .applyMatrix4(currentMatrixAtArcLength);\n\n          const nextPos = tie[(k + 1) % tie.length]\n            .clone()\n            .applyMatrix4(currentMatrixAtArcLength);\n\n          points.push(\n            new Vector3(currentPos.x, currentPos.y, currentPos.z),\n          );\n          points.push(new Vector3(nextPos.x, nextPos.y, nextPos.z));\n        }\n\n        tieDistance = 0;\n      }\n\n      tieDistance += nextArcLength - currentArcLength;\n    }\n\n    return points;\n  }, [curve, loopTie, railSpacing, rails, tie, tieSpacing]);\n\n  return (\n    <Line\n      points={points}\n      segments={true}\n      lineWidth={1}\n      color={colors.secondary}\n      {...props}\n    />\n  );\n};\n",
    "functions": {},
    "types": {},
    "variables": {
      "wireFrameParts": "const wireFrameParts = [\n  new Vector3(0.45, 0, 0),\n  new Vector3(0, -0.4, 0),\n  new Vector3(-0.45, 0, 0),\n];",
      "CurveWireframe": "const CurveWireframe = ({\n  railSpacing = 0.25,\n  tieSpacing = 0.75,\n  loopTie = true,\n  tie = wireFrameParts,\n  rails = wireFrameParts,\n  curve,\n  ...props\n}: {\n  curve: Curve;\n  railSpacing?: number;\n  tieSpacing?: number;\n  tie?: Vector3[];\n  rails?: Vector3[];\n  loopTie?: boolean;\n  offset?: Vector3;\n} & Omit<LineProps, 'points'>) => {\n  const colors = useColors();\n\n  const points = useMemo(() => {\n    const curveLength = totalArcLength(curve);\n    const numNodes = Math.floor(curveLength / railSpacing);\n\n    const points: Vector3[] = [];\n    let tieDistance = 0;\n\n    for (let k = 0; k < numNodes - 1; k++) {\n      const currentArcLength: number =\n        (k / (numNodes - 1)) * curveLength;\n      const currentMatrixAtArcLength = transformationAtArcLength(\n        curve,\n        currentArcLength,\n      );\n\n      const nextArcLength: number =\n        ((k + 1) / (numNodes - 1)) * curveLength;\n      const nextMatrixAtArcLength = transformationAtArcLength(\n        curve,\n        nextArcLength,\n      );\n\n      for (let k = 0; k < rails.length; k++) {\n        const currentPos = rails[k]\n          .clone()\n          .applyMatrix4(currentMatrixAtArcLength);\n        const nextPos = rails[k]\n          .clone()\n          .applyMatrix4(nextMatrixAtArcLength);\n\n        points.push(\n          new Vector3(currentPos.x, currentPos.y, currentPos.z),\n        );\n        points.push(new Vector3(nextPos.x, nextPos.y, nextPos.z));\n      }\n\n      if (tieDistance > tieSpacing) {\n        for (\n          let k = 0;\n          k < (loopTie ? tie.length : tie.length - 1);\n          k++\n        ) {\n          const currentPos = tie[k % tie.length]\n            .clone()\n            .applyMatrix4(currentMatrixAtArcLength);\n\n          const nextPos = tie[(k + 1) % tie.length]\n            .clone()\n            .applyMatrix4(currentMatrixAtArcLength);\n\n          points.push(\n            new Vector3(currentPos.x, currentPos.y, currentPos.z),\n          );\n          points.push(new Vector3(nextPos.x, nextPos.y, nextPos.z));\n        }\n\n        tieDistance = 0;\n      }\n\n      tieDistance += nextArcLength - currentArcLength;\n    }\n\n    return points;\n  }, [curve, loopTie, railSpacing, rails, tie, tieSpacing]);\n\n  return (\n    <Line\n      points={points}\n      segments={true}\n      lineWidth={1}\n      color={colors.secondary}\n      {...props}\n    />\n  );\n};"
    }
  },
  "src/components/curve/DragControlPoints.tsx": {
    "source": "import React, { memo, useState } from 'react';\nimport { DragControlsProps } from '@react-three/drei/web/DragControls';\nimport set from 'lodash/set';\nimport { Vector3 } from 'three';\n\nimport { useColors } from '../../hooks/useColors';\n\nimport { ControlPoint } from './ControlPoint';\nimport { DragControlPosition } from './DragControlPosition';\n\nexport const DragControlPoints = memo(\n  (\n    props: {\n      points: Vector3[];\n      setPoints: (points: Vector3[]) => void;\n    } & Omit<DragControlsProps, 'onDrag' | 'children'>,\n  ) => {\n    const { points, setPoints, ...rest } = props;\n\n    const colors = useColors();\n    const [hover, setHover] = useState<number>();\n\n    return (\n      <>\n        {points.map((point, index) => (\n          <DragControlPosition\n            key={index}\n            position={point}\n            onDrag={(position) =>\n              setPoints(set([...points], index, position))\n            }\n            {...rest}\n          >\n            <ControlPoint\n              color={\n                index === hover ? colors.highlight : colors.secondary\n              }\n              onPointerEnter={() => setHover(index)}\n              onPointerLeave={() => setHover(undefined)}\n            />\n          </DragControlPosition>\n        ))}\n      </>\n    );\n  },\n);\n",
    "functions": {},
    "types": {},
    "variables": {
      "DragControlPoints": "const DragControlPoints = memo(\n  (\n    props: {\n      points: Vector3[];\n      setPoints: (points: Vector3[]) => void;\n    } & Omit<DragControlsProps, 'onDrag' | 'children'>,\n  ) => {\n    const { points, setPoints, ...rest } = props;\n\n    const colors = useColors();\n    const [hover, setHover] = useState<number>();\n\n    return (\n      <>\n        {points.map((point, index) => (\n          <DragControlPosition\n            key={index}\n            position={point}\n            onDrag={(position) =>\n              setPoints(set([...points], index, position))\n            }\n            {...rest}\n          >\n            <ControlPoint\n              color={\n                index === hover ? colors.highlight : colors.secondary\n              }\n              onPointerEnter={() => setHover(index)}\n              onPointerLeave={() => setHover(undefined)}\n            />\n          </DragControlPosition>\n        ))}\n      </>\n    );\n  },\n);"
    }
  },
  "src/components/curve/DragControlPosition.tsx": {
    "source": "import React, { useMemo } from 'react';\nimport { DragControls } from '@react-three/drei';\nimport { DragControlsProps } from '@react-three/drei/web/DragControls';\nimport { Matrix4, Vector3 } from 'three';\n\nexport const DragControlPosition = (\n  props: {\n    position?: Vector3;\n    onDrag: (vec: Vector3) => void;\n  } & Omit<DragControlsProps, 'onDrag'>,\n) => {\n  const {\n    position = new Vector3(0, 0, 0),\n    onDrag = () => {},\n    children,\n    ...rest\n  } = props;\n\n  const startMatrix = useMemo(() => {\n    return new Matrix4().setPosition(position);\n  }, [position]);\n\n  return (\n    <DragControls\n      matrix={startMatrix}\n      onDrag={(localMatrix) => {\n        onDrag(new Vector3().setFromMatrixPosition(localMatrix));\n      }}\n      {...rest}\n    >\n      {children}\n    </DragControls>\n  );\n};\n",
    "functions": {},
    "types": {},
    "variables": {
      "DragControlPosition": "const DragControlPosition = (\n  props: {\n    position?: Vector3;\n    onDrag: (vec: Vector3) => void;\n  } & Omit<DragControlsProps, 'onDrag'>,\n) => {\n  const {\n    position = new Vector3(0, 0, 0),\n    onDrag = () => {},\n    children,\n    ...rest\n  } = props;\n\n  const startMatrix = useMemo(() => {\n    return new Matrix4().setPosition(position);\n  }, [position]);\n\n  return (\n    <DragControls\n      matrix={startMatrix}\n      onDrag={(localMatrix) => {\n        onDrag(new Vector3().setFromMatrixPosition(localMatrix));\n      }}\n      {...rest}\n    >\n      {children}\n    </DragControls>\n  );\n};"
    }
  },
  "src/components/editor/EditorGrid.tsx": {
    "source": "import React from 'react';\nimport { ThreeElements } from '@react-three/fiber';\n\nimport { useColors } from '../../hooks/useColors';\n\nexport const EditorGrid = ({\n  ...props\n}: { size?: number } & ThreeElements['group']) => {\n  const colors = useColors();\n\n  return (\n    <group {...props}>\n      <gridHelper args={[1000, 1000, colors.silent, colors.silent]} />\n      <gridHelper\n        args={[1000, 100, colors.secondary, colors.secondary]}\n      />\n      <gridHelper\n        args={[1000, 10, colors.secondary, colors.secondary]}\n      />\n    </group>\n  );\n};\n",
    "functions": {},
    "types": {},
    "variables": {
      "EditorGrid": "const EditorGrid = ({\n  ...props\n}: { size?: number } & ThreeElements['group']) => {\n  const colors = useColors();\n\n  return (\n    <group {...props}>\n      <gridHelper args={[1000, 1000, colors.silent, colors.silent]} />\n      <gridHelper\n        args={[1000, 100, colors.secondary, colors.secondary]}\n      />\n      <gridHelper\n        args={[1000, 10, colors.secondary, colors.secondary]}\n      />\n    </group>\n  );\n};"
    }
  },
  "src/components/editor/OrthographicEditor.tsx": {
    "source": "import React, { useMemo, useState } from 'react';\nimport { OrthographicCamera } from '@react-three/drei';\nimport { find } from 'lodash';\nimport { Euler, Vector3 } from 'three';\nimport * as THREE from 'three';\n\nimport { OrthographicCameraControls } from '../camera/OrthographicCameraControls';\nimport { EditorGrid } from './EditorGrid';\n\nconst views = [\n  {\n    name: 'front',\n    camera: {\n      position: new Vector3(0, 0, 500),\n      up: new Vector3(0, 0, 1),\n    },\n    grid: {\n      rotation: new Euler(Math.PI / 2, 0, 0),\n      position: new Vector3(0, 0, -500),\n    },\n  },\n  {\n    name: 'back',\n    camera: {\n      position: new Vector3(0, 0, -500),\n      up: new Vector3(0, 0, 1),\n    },\n    grid: {\n      rotation: new Euler(Math.PI / 2, 0, 0),\n      position: new Vector3(0, 0, 500),\n    },\n  },\n  {\n    name: 'top',\n    camera: {\n      position: new Vector3(0, 500, 0),\n      up: new Vector3(0, 1, 0),\n    },\n    grid: {\n      rotation: new Euler(0, Math.PI / 2, 0),\n      position: new Vector3(0, 0, 0),\n    },\n  },\n  {\n    name: 'bottom',\n    camera: {\n      position: new Vector3(0, -500, 0),\n      up: new Vector3(0, 1, 0),\n    },\n    grid: {\n      rotation: new Euler(0, Math.PI / 2, 0),\n      position: new Vector3(0, 0, 0),\n    },\n  },\n  {\n    name: 'left',\n    camera: {\n      position: new Vector3(500, 0, 0),\n      up: new Vector3(1, 0, 0),\n    },\n    grid: {\n      rotation: new Euler(0, 0, Math.PI / 2),\n      position: new Vector3(-500, 0, 0),\n    },\n  },\n  {\n    name: 'right',\n    camera: {\n      position: new Vector3(-500, 0, 0),\n      up: new Vector3(1, 0, 0),\n    },\n    grid: {\n      rotation: new Euler(0, 0, Math.PI / 2),\n      position: new Vector3(500, 0, 0),\n    },\n  },\n];\n\nexport const OrthographicEditor = ({\n  view = 'front',\n  showGrid = true,\n}: {\n  view?: 'front' | 'back' | 'left' | 'right' | 'top' | 'bottom';\n  showGrid?: boolean;\n}) => {\n  const [camera, setCamera] =\n    useState<THREE.OrthographicCamera | null>();\n\n  const activeView = useMemo(\n    () => find(views, { name: view }),\n    [view],\n  );\n  if (!activeView) return null;\n\n  return (\n    <>\n      <OrthographicCamera\n        ref={setCamera}\n        key={view}\n        makeDefault={true}\n        zoom={30}\n        {...activeView.camera}\n      />\n      {camera && <OrthographicCameraControls camera={camera} />}\n      {showGrid && <EditorGrid {...activeView.grid} />}\n    </>\n  );\n};\n",
    "functions": {},
    "types": {},
    "variables": {
      "views": "const views = [\n  {\n    name: 'front',\n    camera: {\n      position: new Vector3(0, 0, 500),\n      up: new Vector3(0, 0, 1),\n    },\n    grid: {\n      rotation: new Euler(Math.PI / 2, 0, 0),\n      position: new Vector3(0, 0, -500),\n    },\n  },\n  {\n    name: 'back',\n    camera: {\n      position: new Vector3(0, 0, -500),\n      up: new Vector3(0, 0, 1),\n    },\n    grid: {\n      rotation: new Euler(Math.PI / 2, 0, 0),\n      position: new Vector3(0, 0, 500),\n    },\n  },\n  {\n    name: 'top',\n    camera: {\n      position: new Vector3(0, 500, 0),\n      up: new Vector3(0, 1, 0),\n    },\n    grid: {\n      rotation: new Euler(0, Math.PI / 2, 0),\n      position: new Vector3(0, 0, 0),\n    },\n  },\n  {\n    name: 'bottom',\n    camera: {\n      position: new Vector3(0, -500, 0),\n      up: new Vector3(0, 1, 0),\n    },\n    grid: {\n      rotation: new Euler(0, Math.PI / 2, 0),\n      position: new Vector3(0, 0, 0),\n    },\n  },\n  {\n    name: 'left',\n    camera: {\n      position: new Vector3(500, 0, 0),\n      up: new Vector3(1, 0, 0),\n    },\n    grid: {\n      rotation: new Euler(0, 0, Math.PI / 2),\n      position: new Vector3(-500, 0, 0),\n    },\n  },\n  {\n    name: 'right',\n    camera: {\n      position: new Vector3(-500, 0, 0),\n      up: new Vector3(1, 0, 0),\n    },\n    grid: {\n      rotation: new Euler(0, 0, Math.PI / 2),\n      position: new Vector3(500, 0, 0),\n    },\n  },\n];",
      "OrthographicEditor": "const OrthographicEditor = ({\n  view = 'front',\n  showGrid = true,\n}: {\n  view?: 'front' | 'back' | 'left' | 'right' | 'top' | 'bottom';\n  showGrid?: boolean;\n}) => {\n  const [camera, setCamera] =\n    useState<THREE.OrthographicCamera | null>();\n\n  const activeView = useMemo(\n    () => find(views, { name: view }),\n    [view],\n  );\n  if (!activeView) return null;\n\n  return (\n    <>\n      <OrthographicCamera\n        ref={setCamera}\n        key={view}\n        makeDefault={true}\n        zoom={30}\n        {...activeView.camera}\n      />\n      {camera && <OrthographicCameraControls camera={camera} />}\n      {showGrid && <EditorGrid {...activeView.grid} />}\n    </>\n  );\n};"
    }
  },
  "src/components/editor/PerspectiveEditor.tsx": {
    "source": "import React, { useState } from 'react';\nimport { PerspectiveCamera } from '@react-three/drei';\nimport * as THREE from 'three';\n\nimport { PerspectiveCameraControls } from '../camera/PerspectiveCameraControls';\n\nexport const PerspectiveEditor = () => {\n  const [camera, setCamera] =\n    useState<THREE.PerspectiveCamera | null>();\n  return (\n    <>\n      <PerspectiveCamera\n        ref={setCamera}\n        makeDefault={true}\n        position={[10, 5, 10]}\n      />\n      {camera && <PerspectiveCameraControls camera={camera} />}\n    </>\n  );\n};\n",
    "functions": {},
    "types": {},
    "variables": {
      "PerspectiveEditor": "const PerspectiveEditor = () => {\n  const [camera, setCamera] =\n    useState<THREE.PerspectiveCamera | null>();\n  return (\n    <>\n      <PerspectiveCamera\n        ref={setCamera}\n        makeDefault={true}\n        position={[10, 5, 10]}\n      />\n      {camera && <PerspectiveCameraControls camera={camera} />}\n    </>\n  );\n};"
    }
  },
  "src/components/scenes/AtmosphericPerspectiveScene.tsx": {
    "source": "import React, { ReactNode } from 'react';\nimport { Sky } from '@react-three/drei';\nimport { Canvas } from '@react-three/fiber';\nimport { Vector3 } from 'three';\nimport { useDevicePixelRatio } from 'use-device-pixel-ratio';\n\nimport {\n  CameraView,\n  CameraViewManager,\n} from '../camera/CameraViewManager';\nimport { PerspectiveEditor } from '../editor/PerspectiveEditor';\n\nconst sunPosition = new Vector3(50, 50, 0);\n\nexport const AtmosphericPerspectiveScene = ({\n  children,\n}: {\n  children?: ReactNode;\n}) => {\n  const dpr = useDevicePixelRatio();\n  return (\n    <CameraViewManager>\n      <Canvas dpr={dpr} shadows={true}>\n        <Sky sunPosition={sunPosition} />\n        <ambientLight castShadow={true} intensity={1} />\n        <directionalLight\n          castShadow\n          position={sunPosition}\n          intensity={1}\n          shadow-mapSize-width={2048 * 4}\n          shadow-mapSize-height={2048 * 4}\n          shadow-camera-near={1}\n          shadow-camera-far={400}\n          shadow-camera-left={-400}\n          shadow-camera-right={400}\n          shadow-camera-top={400}\n          shadow-camera-bottom={-400}\n        />\n\n        <CameraView name=\"perspective\" makeDefault={true}>\n          <PerspectiveEditor />\n        </CameraView>\n        {children}\n      </Canvas>\n    </CameraViewManager>\n  );\n};\n",
    "functions": {},
    "types": {},
    "variables": {
      "sunPosition": "const sunPosition = new Vector3(50, 50, 0);",
      "AtmosphericPerspectiveScene": "const AtmosphericPerspectiveScene = ({\n  children,\n}: {\n  children?: ReactNode;\n}) => {\n  const dpr = useDevicePixelRatio();\n  return (\n    <CameraViewManager>\n      <Canvas dpr={dpr} shadows={true}>\n        <Sky sunPosition={sunPosition} />\n        <ambientLight castShadow={true} intensity={1} />\n        <directionalLight\n          castShadow\n          position={sunPosition}\n          intensity={1}\n          shadow-mapSize-width={2048 * 4}\n          shadow-mapSize-height={2048 * 4}\n          shadow-camera-near={1}\n          shadow-camera-far={400}\n          shadow-camera-left={-400}\n          shadow-camera-right={400}\n          shadow-camera-top={400}\n          shadow-camera-bottom={-400}\n        />\n\n        <CameraView name=\"perspective\" makeDefault={true}>\n          <PerspectiveEditor />\n        </CameraView>\n        {children}\n      </Canvas>\n    </CameraViewManager>\n  );\n};"
    }
  },
  "src/components/scenes/DefaultCanvas.tsx": {
    "source": "import React, { ReactNode } from 'react';\nimport { Canvas } from '@react-three/fiber';\nimport { EffectComposer } from '@react-three/postprocessing';\nimport { ACESFilmicToneMapping, Vector3 } from 'three';\nimport { useDevicePixelRatio } from 'use-device-pixel-ratio';\n\nimport { useColors } from '../../hooks/useColors';\n\nconst sunPosition = new Vector3(100, 100, -100);\n\nexport const DefaultCanvas = ({\n  children,\n}: {\n  children?: ReactNode;\n}) => {\n  const colors = useColors();\n  const dpr = useDevicePixelRatio();\n\n  return (\n    <Canvas\n      gl={{ toneMapping: ACESFilmicToneMapping }}\n      dpr={dpr}\n      shadows={true}\n    >\n      <ambientLight intensity={1.3} />\n      <directionalLight\n        castShadow\n        position={sunPosition}\n        intensity={1.5}\n        shadow-mapSize-width={2048 * 4}\n        shadow-mapSize-height={2048 * 4}\n        shadow-camera-near={1}\n        shadow-camera-far={200}\n        shadow-camera-left={-200}\n        shadow-camera-right={200}\n        shadow-camera-top={200}\n        shadow-camera-bottom={-200}\n      />\n\n      <color attach=\"background\" args={[colors.primary]} />\n\n      <EffectComposer>\n        <>{children}</>\n      </EffectComposer>\n    </Canvas>\n  );\n};\n",
    "functions": {},
    "types": {},
    "variables": {
      "sunPosition": "const sunPosition = new Vector3(100, 100, -100);",
      "DefaultCanvas": "const DefaultCanvas = ({\n  children,\n}: {\n  children?: ReactNode;\n}) => {\n  const colors = useColors();\n  const dpr = useDevicePixelRatio();\n\n  return (\n    <Canvas\n      gl={{ toneMapping: ACESFilmicToneMapping }}\n      dpr={dpr}\n      shadows={true}\n    >\n      <ambientLight intensity={1.3} />\n      <directionalLight\n        castShadow\n        position={sunPosition}\n        intensity={1.5}\n        shadow-mapSize-width={2048 * 4}\n        shadow-mapSize-height={2048 * 4}\n        shadow-camera-near={1}\n        shadow-camera-far={200}\n        shadow-camera-left={-200}\n        shadow-camera-right={200}\n        shadow-camera-top={200}\n        shadow-camera-bottom={-200}\n      />\n\n      <color attach=\"background\" args={[colors.primary]} />\n\n      <EffectComposer>\n        <>{children}</>\n      </EffectComposer>\n    </Canvas>\n  );\n};"
    }
  },
  "src/components/scenes/EditorScene.tsx": {
    "source": "import React, { ReactNode } from 'react';\nimport { CanvasProps } from '@react-three/fiber/dist/declarations/src/web/Canvas';\n\nimport {\n  CameraView,\n  CameraViewManager,\n} from '../camera/CameraViewManager';\nimport { OrthographicEditor } from '../editor/OrthographicEditor';\nimport { PerspectiveEditor } from '../editor/PerspectiveEditor';\nimport { DefaultCanvas } from './DefaultCanvas';\n\nexport const EditorScene = ({\n  children,\n}: {\n  children?: ReactNode;\n} & CanvasProps) => {\n  return (\n    <CameraViewManager>\n      <DefaultCanvas>\n        {['front', 'back', 'top', 'bottom', 'left', 'right'].map(\n          (view) => (\n            <CameraView\n              key={view}\n              name={view}\n              makeDefault={view === 'front'}\n            >\n              <OrthographicEditor view={view as any} />\n            </CameraView>\n          ),\n        )}\n        <CameraView name=\"perspective\">\n          <PerspectiveEditor />\n        </CameraView>\n        {children}\n      </DefaultCanvas>\n    </CameraViewManager>\n  );\n};\n",
    "functions": {},
    "types": {},
    "variables": {
      "EditorScene": "const EditorScene = ({\n  children,\n}: {\n  children?: ReactNode;\n} & CanvasProps) => {\n  return (\n    <CameraViewManager>\n      <DefaultCanvas>\n        {['front', 'back', 'top', 'bottom', 'left', 'right'].map(\n          (view) => (\n            <CameraView\n              key={view}\n              name={view}\n              makeDefault={view === 'front'}\n            >\n              <OrthographicEditor view={view as any} />\n            </CameraView>\n          ),\n        )}\n        <CameraView name=\"perspective\">\n          <PerspectiveEditor />\n        </CameraView>\n        {children}\n      </DefaultCanvas>\n    </CameraViewManager>\n  );\n};"
    }
  },
  "src/components/scenes/OrthographicScene.tsx": {
    "source": "import React, { ReactNode } from 'react';\nimport { OrthographicCamera } from '@react-three/drei';\nimport { CanvasProps } from '@react-three/fiber/dist/declarations/src/web/Canvas';\n\nimport { DefaultCanvas } from './DefaultCanvas';\n\nexport const OrthographicScene = ({\n  children,\n}: {\n  children?: ReactNode;\n} & CanvasProps) => {\n  return (\n    <DefaultCanvas>\n      <OrthographicCamera\n        makeDefault={true}\n        zoom={30}\n        position={[0, 0, 500]}\n        up={[0, 0, 0]}\n      />\n      {children}\n    </DefaultCanvas>\n  );\n};\n",
    "functions": {},
    "types": {},
    "variables": {
      "OrthographicScene": "const OrthographicScene = ({\n  children,\n}: {\n  children?: ReactNode;\n} & CanvasProps) => {\n  return (\n    <DefaultCanvas>\n      <OrthographicCamera\n        makeDefault={true}\n        zoom={30}\n        position={[0, 0, 500]}\n        up={[0, 0, 0]}\n      />\n      {children}\n    </DefaultCanvas>\n  );\n};"
    }
  },
  "src/components/scenes/PerspectiveScene.tsx": {
    "source": "import React, { ReactNode } from 'react';\n\nimport {\n  CameraView,\n  CameraViewManager,\n} from '../camera/CameraViewManager';\nimport { PerspectiveEditor } from '../editor/PerspectiveEditor';\nimport { DefaultCanvas } from './DefaultCanvas';\n\nexport const PerspectiveScene = ({\n  children,\n}: {\n  children?: ReactNode;\n}) => {\n  return (\n    <CameraViewManager>\n      <DefaultCanvas>\n        <CameraView name=\"perspective\" makeDefault={true}>\n          <PerspectiveEditor />\n        </CameraView>\n        {children}\n      </DefaultCanvas>\n    </CameraViewManager>\n  );\n};\n",
    "functions": {},
    "types": {},
    "variables": {
      "PerspectiveScene": "const PerspectiveScene = ({\n  children,\n}: {\n  children?: ReactNode;\n}) => {\n  return (\n    <CameraViewManager>\n      <DefaultCanvas>\n        <CameraView name=\"perspective\" makeDefault={true}>\n          <PerspectiveEditor />\n        </CameraView>\n        {children}\n      </DefaultCanvas>\n    </CameraViewManager>\n  );\n};"
    }
  },
  "src/helper/nl2park/info.ts": {
    "source": "import {\n  NoLimitsStream,\n  readBoolean,\n  readFloat,\n  readFloatVector2,\n  readFloatVector3,\n  readIntegerVector2,\n  readNull,\n  readString,\n  readUnsigned8,\n  writeBoolean,\n  writeFloat,\n  writeFloatVector2,\n  writeFloatVector3,\n  writeIntegerVector2,\n  writeNull,\n  writeString,\n  writeUnsigned8,\n} from './nolimits-stream';\n\nexport enum RideView {\n  ClosestCoasterFirstTrain = 0,\n  ClosestCoasterClosestTrain = 1,\n  FlyView = 2,\n  WalkView = 3,\n}\n\nexport type Info = ReturnType<typeof readInfo>;\n\nexport const readInfo = (stream: NoLimitsStream) => {\n  const version = {\n    major: readUnsigned8(stream),\n    minor: readUnsigned8(stream),\n    revision: readUnsigned8(stream),\n    build: readUnsigned8(stream),\n  };\n\n  readNull(stream, 27);\n\n  const weather = {\n    overwriteDefaultWeather: readBoolean(stream),\n    rainIntensity: readFloat(stream),\n    snowIntensity: readFloat(stream),\n    windIntensity: readFloat(stream),\n    fogIntensity: readFloat(stream),\n    cloudsIntensity: readFloat(stream),\n    overcastIntensity: readFloat(stream),\n    thunderIntensity: readFloat(stream),\n  };\n\n  readNull(stream, 6);\n\n  const author = readString(stream);\n  const description = readString(stream);\n  const preview = readString(stream);\n  const environment = readString(stream);\n\n  readNull(stream, 10);\n\n  const sky = {\n    overrideDefaultDateTime: readBoolean(stream),\n    currentDate: readIntegerVector2(stream),\n    currentTime: readIntegerVector2(stream),\n  };\n\n  const initial = {\n    initialPositionAndRotationEnabled: readBoolean(stream),\n    initialPosition: readFloatVector3(stream),\n    initialRotation: readFloatVector2(stream),\n    initialView: readUnsigned8(stream) as RideView,\n  };\n\n  readNull(stream, 21);\n\n  return {\n    version,\n    weather,\n    sky,\n    initial,\n\n    author,\n    description,\n    preview,\n    environment,\n  };\n};\n\nexport const writeInfo = (\n  stream: NoLimitsStream,\n  info: Info,\n): void => {\n  writeUnsigned8(stream, info.version.major);\n  writeUnsigned8(stream, info.version.minor);\n  writeUnsigned8(stream, info.version.revision);\n  writeUnsigned8(stream, info.version.build);\n\n  writeNull(stream, 27);\n\n  writeBoolean(stream, info.weather.overwriteDefaultWeather);\n  writeFloat(stream, info.weather.rainIntensity);\n  writeFloat(stream, info.weather.snowIntensity);\n  writeFloat(stream, info.weather.windIntensity);\n  writeFloat(stream, info.weather.fogIntensity);\n  writeFloat(stream, info.weather.cloudsIntensity);\n  writeFloat(stream, info.weather.overcastIntensity);\n  writeFloat(stream, info.weather.thunderIntensity);\n\n  writeNull(stream, 6);\n\n  writeString(stream, info.author);\n  writeString(stream, info.description);\n  writeString(stream, info.preview);\n  writeString(stream, info.environment);\n\n  writeNull(stream, 10);\n\n  writeBoolean(stream, info.sky.overrideDefaultDateTime);\n  writeIntegerVector2(stream, info.sky.currentDate);\n  writeIntegerVector2(stream, info.sky.currentTime);\n\n  writeBoolean(\n    stream,\n    info.initial.initialPositionAndRotationEnabled,\n  );\n  writeFloatVector3(stream, info.initial.initialPosition);\n  writeFloatVector2(stream, info.initial.initialRotation);\n  writeUnsigned8(stream, info.initial.initialView);\n\n  writeNull(stream, 21);\n};\n",
    "functions": {},
    "types": {
      "Info": "type Info = ReturnType<typeof readInfo>;"
    },
    "variables": {
      "readInfo": "const readInfo = (stream: NoLimitsStream) => {\n  const version = {\n    major: readUnsigned8(stream),\n    minor: readUnsigned8(stream),\n    revision: readUnsigned8(stream),\n    build: readUnsigned8(stream),\n  };\n\n  readNull(stream, 27);\n\n  const weather = {\n    overwriteDefaultWeather: readBoolean(stream),\n    rainIntensity: readFloat(stream),\n    snowIntensity: readFloat(stream),\n    windIntensity: readFloat(stream),\n    fogIntensity: readFloat(stream),\n    cloudsIntensity: readFloat(stream),\n    overcastIntensity: readFloat(stream),\n    thunderIntensity: readFloat(stream),\n  };\n\n  readNull(stream, 6);\n\n  const author = readString(stream);\n  const description = readString(stream);\n  const preview = readString(stream);\n  const environment = readString(stream);\n\n  readNull(stream, 10);\n\n  const sky = {\n    overrideDefaultDateTime: readBoolean(stream),\n    currentDate: readIntegerVector2(stream),\n    currentTime: readIntegerVector2(stream),\n  };\n\n  const initial = {\n    initialPositionAndRotationEnabled: readBoolean(stream),\n    initialPosition: readFloatVector3(stream),\n    initialRotation: readFloatVector2(stream),\n    initialView: readUnsigned8(stream) as RideView,\n  };\n\n  readNull(stream, 21);\n\n  return {\n    version,\n    weather,\n    sky,\n    initial,\n\n    author,\n    description,\n    preview,\n    environment,\n  };\n};",
      "writeInfo": "const writeInfo = (\n  stream: NoLimitsStream,\n  info: Info,\n): void => {\n  writeUnsigned8(stream, info.version.major);\n  writeUnsigned8(stream, info.version.minor);\n  writeUnsigned8(stream, info.version.revision);\n  writeUnsigned8(stream, info.version.build);\n\n  writeNull(stream, 27);\n\n  writeBoolean(stream, info.weather.overwriteDefaultWeather);\n  writeFloat(stream, info.weather.rainIntensity);\n  writeFloat(stream, info.weather.snowIntensity);\n  writeFloat(stream, info.weather.windIntensity);\n  writeFloat(stream, info.weather.fogIntensity);\n  writeFloat(stream, info.weather.cloudsIntensity);\n  writeFloat(stream, info.weather.overcastIntensity);\n  writeFloat(stream, info.weather.thunderIntensity);\n\n  writeNull(stream, 6);\n\n  writeString(stream, info.author);\n  writeString(stream, info.description);\n  writeString(stream, info.preview);\n  writeString(stream, info.environment);\n\n  writeNull(stream, 10);\n\n  writeBoolean(stream, info.sky.overrideDefaultDateTime);\n  writeIntegerVector2(stream, info.sky.currentDate);\n  writeIntegerVector2(stream, info.sky.currentTime);\n\n  writeBoolean(\n    stream,\n    info.initial.initialPositionAndRotationEnabled,\n  );\n  writeFloatVector3(stream, info.initial.initialPosition);\n  writeFloatVector2(stream, info.initial.initialRotation);\n  writeUnsigned8(stream, info.initial.initialView);\n\n  writeNull(stream, 21);\n};"
    }
  },
  "src/helper/nl2park/nl2park.ts": {
    "source": "import {\n  Coaster,\n  readCoaster,\n  writeCoaster,\n} from './coaster/coaster';\nimport { Info, readInfo, writeInfo } from './info';\nimport {\n  makeChunkReader,\n  NoLimitsStream,\n  fromArrayBuffer as noLimitsStreamFromArrayBuffer,\n  toArrayBuffer as noLimitsStreamToArrayBuffer,\n  readChunks,\n  writeChunk,\n} from './nolimits-stream';\n\nexport type NoLimitsPark = ReturnType<typeof readPark>;\n\nexport const fromURL = async (url: string) => {\n  const content = await fetch(url);\n  return fromArrayBuffer(await content.arrayBuffer());\n};\n\nexport const fromArrayBuffer = (content: ArrayBuffer) => {\n  return readPark(noLimitsStreamFromArrayBuffer(content));\n};\n\nexport const toArrayBuffer = (park: NoLimitsPark) => {\n  const stream = noLimitsStreamFromArrayBuffer(new ArrayBuffer(0));\n  writePark(stream, park);\n  return noLimitsStreamToArrayBuffer(stream);\n};\n\nexport const readPark = (stream: NoLimitsStream) => {\n  const coaster: Coaster[] = [];\n  let info: Info | undefined;\n\n  readChunks(\n    [\n      makeChunkReader(readInfo, 'INFO', (i) => {\n        info = i;\n      }),\n      makeChunkReader(readCoaster, 'COAS', (c) => {\n        coaster.push(c);\n      }),\n    ],\n    stream,\n  );\n\n  return {\n    info,\n    coaster,\n  };\n};\n\nexport const writePark = (\n  stream: NoLimitsStream,\n  park: NoLimitsPark,\n) => {\n  writeChunk(stream, 'INFO', (s) => {\n    if (!park.info) return;\n    writeInfo(s, park.info);\n  });\n\n  for (const c of park.coaster) {\n    writeChunk(stream, 'COAS', (s) => writeCoaster(s, c));\n  }\n};\n",
    "functions": {},
    "types": {
      "NoLimitsPark": "type NoLimitsPark = ReturnType<typeof readPark>;"
    },
    "variables": {
      "fromURL": "const fromURL = async (url: string) => {\n  const content = await fetch(url);\n  return fromArrayBuffer(await content.arrayBuffer());\n};",
      "fromArrayBuffer": "const fromArrayBuffer = (content: ArrayBuffer) => {\n  return readPark(noLimitsStreamFromArrayBuffer(content));\n};",
      "toArrayBuffer": "const toArrayBuffer = (park: NoLimitsPark) => {\n  const stream = noLimitsStreamFromArrayBuffer(new ArrayBuffer(0));\n  writePark(stream, park);\n  return noLimitsStreamToArrayBuffer(stream);\n};",
      "readPark": "const readPark = (stream: NoLimitsStream) => {\n  const coaster: Coaster[] = [];\n  let info: Info | undefined;\n\n  readChunks(\n    [\n      makeChunkReader(readInfo, 'INFO', (i) => {\n        info = i;\n      }),\n      makeChunkReader(readCoaster, 'COAS', (c) => {\n        coaster.push(c);\n      }),\n    ],\n    stream,\n  );\n\n  return {\n    info,\n    coaster,\n  };\n};",
      "writePark": "const writePark = (\n  stream: NoLimitsStream,\n  park: NoLimitsPark,\n) => {\n  writeChunk(stream, 'INFO', (s) => {\n    if (!park.info) return;\n    writeInfo(s, park.info);\n  });\n\n  for (const c of park.coaster) {\n    writeChunk(stream, 'COAS', (s) => writeCoaster(s, c));\n  }\n};"
    }
  },
  "src/helper/nl2park/nolimits-stream.ts": {
    "source": "import { Vector2, Vector3, Vector4 } from 'three';\n\nexport type NoLimitsStream = {\n  content: Uint8Array;\n  position: number;\n};\n\nexport const fromArrayBuffer = (\n  content: ArrayBuffer,\n  position: number = 0,\n) => fromUint8Array(new Uint8Array(content), position);\n\nexport const fromUint8Array = (\n  content: Uint8Array,\n  position: number = 0,\n) => ({\n  content,\n  position,\n});\n\nexport const toArrayBuffer = (stream: NoLimitsStream) =>\n  stream.content.buffer.slice(\n    stream.content.byteOffset,\n    stream.content.byteOffset + stream.content.byteLength,\n  );\n\nexport const fromChunk = (stream: NoLimitsStream) => {\n  const size = readInteger(stream);\n  const start = stream.position;\n  const end = start + size;\n  const chunk = fromUint8Array(stream.content.slice(start, end));\n\n  stream.position = end;\n  return chunk;\n};\n\nexport const readChunkName = (stream: NoLimitsStream) => {\n  const start = stream.position;\n  const slice = stream.content.slice(start, start + 4);\n\n  stream.position += 4;\n  return String.fromCharCode(...slice);\n};\n\nexport const makeChunkReader = <Name extends string, T>(\n  reader: (stream: NoLimitsStream) => T,\n  chunkName: Name,\n  handler: (result: T) => void,\n) => ({\n  reader: Object.assign(reader, { chunkName }),\n  handler,\n});\n\nexport const readChunks = (\n  readers: readonly {\n    reader: ((stream: NoLimitsStream) => any) & { chunkName: string };\n    handler: (result: any) => void;\n  }[],\n  baseStream: NoLimitsStream,\n) => {\n  for (let i = 0; i <= baseStream.content.length; i++) {\n    baseStream.position = i;\n\n    const name = readChunkName(baseStream).trim();\n    const reader = readers.find((e) => e.reader.chunkName === name);\n\n    if (reader) {\n      reader.handler(reader.reader(fromChunk(baseStream)));\n      i = baseStream.position - 1;\n    }\n  }\n};\n\nexport const readInteger = (stream: NoLimitsStream) => {\n  const dv = new DataView(\n    stream.content.buffer,\n    stream.content.byteOffset + stream.position,\n    4,\n  );\n\n  const value = dv.getInt32(0);\n  stream.position += 4;\n  return value;\n};\n\nexport const readUnsignedInteger = (stream: NoLimitsStream) => {\n  const dv = new DataView(\n    stream.content.buffer,\n    stream.content.byteOffset + stream.position,\n    4,\n  );\n\n  const value = dv.getUint32(0);\n  stream.position += 4;\n  return value;\n};\n\nexport const readFloat = (stream: NoLimitsStream) => {\n  const dv = new DataView(\n    stream.content.buffer,\n    stream.content.byteOffset + stream.position,\n    4,\n  );\n\n  const value = dv.getFloat32(0);\n  stream.position += 4;\n  return value;\n};\n\nexport const readDouble = (stream: NoLimitsStream) => {\n  const dv = new DataView(\n    stream.content.buffer,\n    stream.content.byteOffset + stream.position,\n    8,\n  );\n\n  const value = dv.getFloat64(0);\n  stream.position += 8;\n  return value;\n};\n\nexport const readUnsigned8 = (stream: NoLimitsStream) => {\n  const value = stream.content[stream.position];\n  stream.position += 1;\n  return value;\n};\n\nexport const readBoolean = (stream: NoLimitsStream) =>\n  !!readUnsigned8(stream);\n\nexport const readIntegerVector2 = (stream: NoLimitsStream) =>\n  new Vector2().fromArray([readInteger(stream), readInteger(stream)]);\n\nexport const readUnsigned8Vector2 = (stream: NoLimitsStream) =>\n  new Vector2().fromArray([\n    readUnsigned8(stream),\n    readUnsigned8(stream),\n  ]);\n\nexport const readUnsigned8Vector3 = (stream: NoLimitsStream) =>\n  new Vector3().fromArray([\n    readUnsigned8(stream),\n    readUnsigned8(stream),\n    readUnsigned8(stream),\n  ]);\n\nexport const readFloatVector2 = (stream: NoLimitsStream) =>\n  new Vector2().fromArray([readFloat(stream), readFloat(stream)]);\n\nexport const readFloatVector3 = (stream: NoLimitsStream) =>\n  new Vector3().fromArray([\n    readFloat(stream),\n    readFloat(stream),\n    readFloat(stream),\n  ]);\n\nexport const readDoubleVector2 = (stream: NoLimitsStream) =>\n  new Vector2().fromArray([readDouble(stream), readDouble(stream)]);\n\nexport const readDoubleVector3 = (stream: NoLimitsStream) =>\n  new Vector3().fromArray([\n    readDouble(stream),\n    readDouble(stream),\n    readDouble(stream),\n  ]);\n\nexport const readDoubleVector4 = (stream: NoLimitsStream) =>\n  new Vector4().fromArray([\n    readDouble(stream),\n    readDouble(stream),\n    readDouble(stream),\n    readDouble(stream),\n  ]);\n\nexport const readColor = (stream: NoLimitsStream) =>\n  readUnsigned8Vector3(stream);\n\nexport const readNull = (\n  stream: NoLimitsStream,\n  byteCount: number,\n) => {\n  stream.position += byteCount;\n};\n\nexport const readString = (stream: NoLimitsStream) => {\n  let result = '';\n\n  while (true) {\n    const charCode = stream.content[stream.position + 1];\n    stream.position += 2;\n\n    if (charCode === 0) break;\n    result += String.fromCharCode(charCode);\n  }\n\n  return result;\n};\n\nexport const writeDouble = (\n  stream: NoLimitsStream,\n  value: number,\n) => {\n  const buffer = new ArrayBuffer(8);\n  new DataView(buffer).setFloat64(0, value);\n  write(stream, buffer);\n};\n\nexport const writeFloat = (stream: NoLimitsStream, value: number) => {\n  const buffer = new ArrayBuffer(8);\n  new DataView(buffer).setFloat32(0, value);\n  write(stream, buffer);\n};\n\nexport const writeUnsignedInteger = (\n  stream: NoLimitsStream,\n  value: number,\n) => {\n  const buffer = new ArrayBuffer(4);\n  new DataView(buffer).setUint32(0, value);\n  write(stream, buffer);\n};\n\nexport const writeInteger = (\n  stream: NoLimitsStream,\n  value: number,\n) => {\n  const buffer = new ArrayBuffer(4);\n  new DataView(buffer).setInt32(0, value);\n  write(stream, buffer);\n};\n\nexport const writeBoolean = (\n  stream: NoLimitsStream,\n  value: boolean,\n) => {\n  const buffer = new ArrayBuffer(1);\n  new Uint8Array(buffer)[0] = value ? 1 : 0;\n  write(stream, buffer);\n};\n\nexport const write = (\n  stream: NoLimitsStream,\n  buffer: ArrayBuffer,\n) => {\n  const bytes = new Uint8Array(buffer);\n  const next = new Uint8Array(stream.content.length + bytes.length);\n\n  next.set(stream.content, 0);\n  next.set(bytes, stream.content.length);\n\n  stream.content = next;\n  stream.position += bytes.length;\n};\n\nexport const writeDoubleVector4 = (\n  stream: NoLimitsStream,\n  value: Vector4,\n) => {\n  writeDouble(stream, value.x);\n  writeDouble(stream, value.y);\n  writeDouble(stream, value.z);\n  writeDouble(stream, value.w);\n};\n\nexport const writeIntegerVector2 = (\n  stream: NoLimitsStream,\n  value: Vector2,\n) => {\n  writeInteger(stream, value.x);\n  writeInteger(stream, value.y);\n};\n\nexport const writeFloatVector2 = (\n  stream: NoLimitsStream,\n  value: Vector2,\n) => {\n  writeFloat(stream, value.x);\n  writeFloat(stream, value.y);\n};\n\nexport const writeFloatVector3 = (\n  stream: NoLimitsStream,\n  value: Vector3,\n) => {\n  writeFloat(stream, value.x);\n  writeFloat(stream, value.y);\n  writeFloat(stream, value.z);\n};\n\nexport const writeDoubleVector3 = (\n  stream: NoLimitsStream,\n  value: Vector3,\n) => {\n  writeDouble(stream, value.x);\n  writeDouble(stream, value.y);\n  writeDouble(stream, value.z);\n};\n\nexport const writeDoubleVector2 = (\n  stream: NoLimitsStream,\n  value: Vector2,\n) => {\n  writeDouble(stream, value.x);\n  writeDouble(stream, value.y);\n};\n\nexport const writeNull = (\n  stream: NoLimitsStream,\n  byteCount: number,\n) => {\n  write(stream, new ArrayBuffer(byteCount));\n};\n\nexport const writeUnsigned8 = (\n  stream: NoLimitsStream,\n  value: number,\n) => {\n  const buffer = new ArrayBuffer(1);\n  new Uint8Array(buffer)[0] = value & 0xff;\n  write(stream, buffer);\n};\n\nexport const writeString = (\n  stream: NoLimitsStream,\n  value: string,\n) => {\n  for (let i = 0; i < value.length; i++) {\n    writeNull(stream, 1);\n    writeUnsigned8(stream, value.charCodeAt(i));\n  }\n\n  writeNull(stream, 2);\n};\n\nexport const writeUnsigned8Vector3 = (\n  stream: NoLimitsStream,\n  value: Vector3,\n) => {\n  writeUnsigned8(stream, value.x);\n  writeUnsigned8(stream, value.y);\n  writeUnsigned8(stream, value.z);\n};\n\nexport const writeColor = (\n  stream: NoLimitsStream,\n  color: Vector3,\n) => {\n  writeUnsigned8Vector3(stream, color);\n};\n\nexport const writeChunkName = (\n  stream: NoLimitsStream,\n  name: string,\n) => {\n  for (let i = 0; i < 4; i++) {\n    writeUnsigned8(stream, name.charCodeAt(i) ?? 0);\n  }\n};\n\nexport const writeChunk = (\n  stream: NoLimitsStream,\n  chunkName: string,\n  handler: (stream: NoLimitsStream) => void,\n) => {\n  const chunkStream = fromArrayBuffer(new ArrayBuffer(0));\n  handler(chunkStream);\n\n  if (!chunkStream.content.length) return;\n\n  writeUnsignedInteger(stream, chunkStream.content.length);\n  writeChunkName(stream, chunkName);\n  write(stream, chunkStream.content);\n};\n",
    "functions": {},
    "types": {
      "NoLimitsStream": "type NoLimitsStream = {\n  content: Uint8Array;\n  position: number;\n};"
    },
    "variables": {
      "fromArrayBuffer": "const fromArrayBuffer = (\n  content: ArrayBuffer,\n  position: number = 0,\n) => fromUint8Array(new Uint8Array(content), position);",
      "fromUint8Array": "const fromUint8Array = (\n  content: Uint8Array,\n  position: number = 0,\n) => ({\n  content,\n  position,\n});",
      "toArrayBuffer": "const toArrayBuffer = (stream: NoLimitsStream) =>\n  stream.content.buffer.slice(\n    stream.content.byteOffset,\n    stream.content.byteOffset + stream.content.byteLength,\n  );",
      "fromChunk": "const fromChunk = (stream: NoLimitsStream) => {\n  const size = readInteger(stream);\n  const start = stream.position;\n  const end = start + size;\n  const chunk = fromUint8Array(stream.content.slice(start, end));\n\n  stream.position = end;\n  return chunk;\n};",
      "readChunkName": "const readChunkName = (stream: NoLimitsStream) => {\n  const start = stream.position;\n  const slice = stream.content.slice(start, start + 4);\n\n  stream.position += 4;\n  return String.fromCharCode(...slice);\n};",
      "makeChunkReader": "const makeChunkReader = <Name extends string, T>(\n  reader: (stream: NoLimitsStream) => T,\n  chunkName: Name,\n  handler: (result: T) => void,\n) => ({\n  reader: Object.assign(reader, { chunkName }),\n  handler,\n});",
      "readChunks": "const readChunks = (\n  readers: readonly {\n    reader: ((stream: NoLimitsStream) => any) & { chunkName: string };\n    handler: (result: any) => void;\n  }[],\n  baseStream: NoLimitsStream,\n) => {\n  for (let i = 0; i <= baseStream.content.length; i++) {\n    baseStream.position = i;\n\n    const name = readChunkName(baseStream).trim();\n    const reader = readers.find((e) => e.reader.chunkName === name);\n\n    if (reader) {\n      reader.handler(reader.reader(fromChunk(baseStream)));\n      i = baseStream.position - 1;\n    }\n  }\n};",
      "readInteger": "const readInteger = (stream: NoLimitsStream) => {\n  const dv = new DataView(\n    stream.content.buffer,\n    stream.content.byteOffset + stream.position,\n    4,\n  );\n\n  const value = dv.getInt32(0);\n  stream.position += 4;\n  return value;\n};",
      "readUnsignedInteger": "const readUnsignedInteger = (stream: NoLimitsStream) => {\n  const dv = new DataView(\n    stream.content.buffer,\n    stream.content.byteOffset + stream.position,\n    4,\n  );\n\n  const value = dv.getUint32(0);\n  stream.position += 4;\n  return value;\n};",
      "readFloat": "const readFloat = (stream: NoLimitsStream) => {\n  const dv = new DataView(\n    stream.content.buffer,\n    stream.content.byteOffset + stream.position,\n    4,\n  );\n\n  const value = dv.getFloat32(0);\n  stream.position += 4;\n  return value;\n};",
      "readDouble": "const readDouble = (stream: NoLimitsStream) => {\n  const dv = new DataView(\n    stream.content.buffer,\n    stream.content.byteOffset + stream.position,\n    8,\n  );\n\n  const value = dv.getFloat64(0);\n  stream.position += 8;\n  return value;\n};",
      "readUnsigned8": "const readUnsigned8 = (stream: NoLimitsStream) => {\n  const value = stream.content[stream.position];\n  stream.position += 1;\n  return value;\n};",
      "readBoolean": "const readBoolean = (stream: NoLimitsStream) =>\n  !!readUnsigned8(stream);",
      "readIntegerVector2": "const readIntegerVector2 = (stream: NoLimitsStream) =>\n  new Vector2().fromArray([readInteger(stream), readInteger(stream)]);",
      "readUnsigned8Vector2": "const readUnsigned8Vector2 = (stream: NoLimitsStream) =>\n  new Vector2().fromArray([\n    readUnsigned8(stream),\n    readUnsigned8(stream),\n  ]);",
      "readUnsigned8Vector3": "const readUnsigned8Vector3 = (stream: NoLimitsStream) =>\n  new Vector3().fromArray([\n    readUnsigned8(stream),\n    readUnsigned8(stream),\n    readUnsigned8(stream),\n  ]);",
      "readFloatVector2": "const readFloatVector2 = (stream: NoLimitsStream) =>\n  new Vector2().fromArray([readFloat(stream), readFloat(stream)]);",
      "readFloatVector3": "const readFloatVector3 = (stream: NoLimitsStream) =>\n  new Vector3().fromArray([\n    readFloat(stream),\n    readFloat(stream),\n    readFloat(stream),\n  ]);",
      "readDoubleVector2": "const readDoubleVector2 = (stream: NoLimitsStream) =>\n  new Vector2().fromArray([readDouble(stream), readDouble(stream)]);",
      "readDoubleVector3": "const readDoubleVector3 = (stream: NoLimitsStream) =>\n  new Vector3().fromArray([\n    readDouble(stream),\n    readDouble(stream),\n    readDouble(stream),\n  ]);",
      "readDoubleVector4": "const readDoubleVector4 = (stream: NoLimitsStream) =>\n  new Vector4().fromArray([\n    readDouble(stream),\n    readDouble(stream),\n    readDouble(stream),\n    readDouble(stream),\n  ]);",
      "readColor": "const readColor = (stream: NoLimitsStream) =>\n  readUnsigned8Vector3(stream);",
      "readNull": "const readNull = (\n  stream: NoLimitsStream,\n  byteCount: number,\n) => {\n  stream.position += byteCount;\n};",
      "readString": "const readString = (stream: NoLimitsStream) => {\n  let result = '';\n\n  while (true) {\n    const charCode = stream.content[stream.position + 1];\n    stream.position += 2;\n\n    if (charCode === 0) break;\n    result += String.fromCharCode(charCode);\n  }\n\n  return result;\n};",
      "writeDouble": "const writeDouble = (\n  stream: NoLimitsStream,\n  value: number,\n) => {\n  const buffer = new ArrayBuffer(8);\n  new DataView(buffer).setFloat64(0, value);\n  write(stream, buffer);\n};",
      "writeFloat": "const writeFloat = (stream: NoLimitsStream, value: number) => {\n  const buffer = new ArrayBuffer(8);\n  new DataView(buffer).setFloat32(0, value);\n  write(stream, buffer);\n};",
      "writeUnsignedInteger": "const writeUnsignedInteger = (\n  stream: NoLimitsStream,\n  value: number,\n) => {\n  const buffer = new ArrayBuffer(4);\n  new DataView(buffer).setUint32(0, value);\n  write(stream, buffer);\n};",
      "writeInteger": "const writeInteger = (\n  stream: NoLimitsStream,\n  value: number,\n) => {\n  const buffer = new ArrayBuffer(4);\n  new DataView(buffer).setInt32(0, value);\n  write(stream, buffer);\n};",
      "writeBoolean": "const writeBoolean = (\n  stream: NoLimitsStream,\n  value: boolean,\n) => {\n  const buffer = new ArrayBuffer(1);\n  new Uint8Array(buffer)[0] = value ? 1 : 0;\n  write(stream, buffer);\n};",
      "write": "const write = (\n  stream: NoLimitsStream,\n  buffer: ArrayBuffer,\n) => {\n  const bytes = new Uint8Array(buffer);\n  const next = new Uint8Array(stream.content.length + bytes.length);\n\n  next.set(stream.content, 0);\n  next.set(bytes, stream.content.length);\n\n  stream.content = next;\n  stream.position += bytes.length;\n};",
      "writeDoubleVector4": "const writeDoubleVector4 = (\n  stream: NoLimitsStream,\n  value: Vector4,\n) => {\n  writeDouble(stream, value.x);\n  writeDouble(stream, value.y);\n  writeDouble(stream, value.z);\n  writeDouble(stream, value.w);\n};",
      "writeIntegerVector2": "const writeIntegerVector2 = (\n  stream: NoLimitsStream,\n  value: Vector2,\n) => {\n  writeInteger(stream, value.x);\n  writeInteger(stream, value.y);\n};",
      "writeFloatVector2": "const writeFloatVector2 = (\n  stream: NoLimitsStream,\n  value: Vector2,\n) => {\n  writeFloat(stream, value.x);\n  writeFloat(stream, value.y);\n};",
      "writeFloatVector3": "const writeFloatVector3 = (\n  stream: NoLimitsStream,\n  value: Vector3,\n) => {\n  writeFloat(stream, value.x);\n  writeFloat(stream, value.y);\n  writeFloat(stream, value.z);\n};",
      "writeDoubleVector3": "const writeDoubleVector3 = (\n  stream: NoLimitsStream,\n  value: Vector3,\n) => {\n  writeDouble(stream, value.x);\n  writeDouble(stream, value.y);\n  writeDouble(stream, value.z);\n};",
      "writeDoubleVector2": "const writeDoubleVector2 = (\n  stream: NoLimitsStream,\n  value: Vector2,\n) => {\n  writeDouble(stream, value.x);\n  writeDouble(stream, value.y);\n};",
      "writeNull": "const writeNull = (\n  stream: NoLimitsStream,\n  byteCount: number,\n) => {\n  write(stream, new ArrayBuffer(byteCount));\n};",
      "writeUnsigned8": "const writeUnsigned8 = (\n  stream: NoLimitsStream,\n  value: number,\n) => {\n  const buffer = new ArrayBuffer(1);\n  new Uint8Array(buffer)[0] = value & 0xff;\n  write(stream, buffer);\n};",
      "writeString": "const writeString = (\n  stream: NoLimitsStream,\n  value: string,\n) => {\n  for (let i = 0; i < value.length; i++) {\n    writeNull(stream, 1);\n    writeUnsigned8(stream, value.charCodeAt(i));\n  }\n\n  writeNull(stream, 2);\n};",
      "writeUnsigned8Vector3": "const writeUnsigned8Vector3 = (\n  stream: NoLimitsStream,\n  value: Vector3,\n) => {\n  writeUnsigned8(stream, value.x);\n  writeUnsigned8(stream, value.y);\n  writeUnsigned8(stream, value.z);\n};",
      "writeColor": "const writeColor = (\n  stream: NoLimitsStream,\n  color: Vector3,\n) => {\n  writeUnsigned8Vector3(stream, color);\n};",
      "writeChunkName": "const writeChunkName = (\n  stream: NoLimitsStream,\n  name: string,\n) => {\n  for (let i = 0; i < 4; i++) {\n    writeUnsigned8(stream, name.charCodeAt(i) ?? 0);\n  }\n};",
      "writeChunk": "const writeChunk = (\n  stream: NoLimitsStream,\n  chunkName: string,\n  handler: (stream: NoLimitsStream) => void,\n) => {\n  const chunkStream = fromArrayBuffer(new ArrayBuffer(0));\n  handler(chunkStream);\n\n  if (!chunkStream.content.length) return;\n\n  writeUnsignedInteger(stream, chunkStream.content.length);\n  writeChunkName(stream, chunkName);\n  write(stream, chunkStream.content);\n};"
    }
  },
  "src/libs/calculation/index.ts": {
    "source": "import glue from './glue.wasm';\n\nconst module = await WebAssembly.compileStreaming(fetch(glue));\n\nconst instance = await WebAssembly.instantiate(module, {\n  wasi_snapshot_preview1: {\n    environ_get: () => {},\n    environ_sizes_get: () => {},\n    fd_close: () => {},\n    fd_fdstat_get: () => {},\n    fd_read: () => {},\n    fd_write: () => {},\n    proc_exit: () => {},\n    fd_seek: () => {},\n    fd_fdstat_set_flags: () => {},\n    fd_prestat_get: () => {},\n    fd_prestat_dir_name: () => {},\n    path_open: () => {},\n  },\n});\n\nexport const bezierTotalArcLength = (bezierPointer: number) => {\n  const { bezierTotalArcLength: func } = instance.exports as any;\n  return func(bezierPointer);\n};\n\nexport const bezierPositionAtArcLength = (\n  bezierPointer: number,\n  at: number,\n) => {\n  const { bezierPositionAtArcLength: func, memory } =\n    instance.exports as any;\n  const positionPointer = func(bezierPointer, at);\n  return new Float32Array(memory.buffer, positionPointer, 3);\n};\n\nexport const bezierFromPoints = (\n  p0: number[],\n  p1: number[],\n  p2: number[],\n  p3: number[],\n) => {\n  const {\n    bezierFromPoints: func,\n    malloc,\n    memory,\n  } = instance.exports as any;\n\n  const pointers = [p0, p1, p2, p3].map((point) => {\n    const pointer = malloc(3 * 4); // (x, y, z) * 4 bytes\n    new Float32Array(memory.buffer, pointer, 3).set(point);\n    return pointer;\n  });\n\n  return func(pointers[0], pointers[1], pointers[2], pointers[3]);\n};\n",
    "functions": {},
    "types": {},
    "variables": {
      "module": "const module = await WebAssembly.compileStreaming(fetch(glue));",
      "instance": "const instance = await WebAssembly.instantiate(module, {\n  wasi_snapshot_preview1: {\n    environ_get: () => {},\n    environ_sizes_get: () => {},\n    fd_close: () => {},\n    fd_fdstat_get: () => {},\n    fd_read: () => {},\n    fd_write: () => {},\n    proc_exit: () => {},\n    fd_seek: () => {},\n    fd_fdstat_set_flags: () => {},\n    fd_prestat_get: () => {},\n    fd_prestat_dir_name: () => {},\n    path_open: () => {},\n  },\n});",
      "bezierTotalArcLength": "const bezierTotalArcLength = (bezierPointer: number) => {\n  const { bezierTotalArcLength: func } = instance.exports as any;\n  return func(bezierPointer);\n};",
      "bezierPositionAtArcLength": "const bezierPositionAtArcLength = (\n  bezierPointer: number,\n  at: number,\n) => {\n  const { bezierPositionAtArcLength: func, memory } =\n    instance.exports as any;\n  const positionPointer = func(bezierPointer, at);\n  return new Float32Array(memory.buffer, positionPointer, 3);\n};",
      "bezierFromPoints": "const bezierFromPoints = (\n  p0: number[],\n  p1: number[],\n  p2: number[],\n  p3: number[],\n) => {\n  const {\n    bezierFromPoints: func,\n    malloc,\n    memory,\n  } = instance.exports as any;\n\n  const pointers = [p0, p1, p2, p3].map((point) => {\n    const pointer = malloc(3 * 4); // (x, y, z) * 4 bytes\n    new Float32Array(memory.buffer, pointer, 3).set(point);\n    return pointer;\n  });\n\n  return func(pointers[0], pointers[1], pointers[2], pointers[3]);\n};"
    }
  },
  "src/helper/nl2park/coaster/car.ts": {
    "source": "import {\n  makeChunkReader,\n  NoLimitsStream,\n  readChunks,\n  readUnsignedInteger,\n  writeChunk,\n  writeUnsignedInteger,\n} from '../nolimits-stream';\nimport {\n  IndividualColor,\n  readIndividualColor,\n  writeIndividualColor,\n} from './individual-color';\n\nexport type Car = ReturnType<typeof readCar>;\n\nexport const readCar = (stream: NoLimitsStream) => {\n  let individualColor: IndividualColor | undefined;\n\n  const internalCarIndex = readUnsignedInteger(stream);\n\n  readChunks(\n    [\n      makeChunkReader(\n        readIndividualColor,\n        'INDC',\n        (color) => (individualColor = color),\n      ),\n    ],\n    stream,\n  );\n\n  return {\n    internalCarIndex,\n    individualColor,\n  };\n};\n\nexport const writeCar = (stream: NoLimitsStream, car: Car): void => {\n  writeUnsignedInteger(stream, car.internalCarIndex);\n  writeChunk(stream, 'INDC', (s) => {\n    if (!car.individualColor) return;\n    writeIndividualColor(s, car.individualColor);\n  });\n};\n",
    "functions": {},
    "types": {
      "Car": "type Car = ReturnType<typeof readCar>;"
    },
    "variables": {
      "readCar": "const readCar = (stream: NoLimitsStream) => {\n  let individualColor: IndividualColor | undefined;\n\n  const internalCarIndex = readUnsignedInteger(stream);\n\n  readChunks(\n    [\n      makeChunkReader(\n        readIndividualColor,\n        'INDC',\n        (color) => (individualColor = color),\n      ),\n    ],\n    stream,\n  );\n\n  return {\n    internalCarIndex,\n    individualColor,\n  };\n};",
      "writeCar": "const writeCar = (stream: NoLimitsStream, car: Car): void => {\n  writeUnsignedInteger(stream, car.internalCarIndex);\n  writeChunk(stream, 'INDC', (s) => {\n    if (!car.individualColor) return;\n    writeIndividualColor(s, car.individualColor);\n  });\n};"
    }
  },
  "src/helper/nl2park/coaster/coaster.ts": {
    "source": "import { compact } from 'lodash';\n\nimport {\n  makeChunkReader,\n  NoLimitsStream,\n  readBoolean,\n  readChunks,\n  readColor,\n  readDoubleVector2,\n  readNull,\n  readString,\n  readUnsigned8,\n  writeBoolean,\n  writeChunk,\n  writeColor,\n  writeDoubleVector2,\n  writeNull,\n  writeString,\n  writeUnsigned8,\n} from '../nolimits-stream';\nimport {\n  CustomTrack,\n  readCustomTrack,\n  writeCustomTrack,\n} from '../track/custom-track';\nimport {\n  CustomFriction,\n  readCustomFriction,\n  writeCustomFriction,\n} from './custom-friction';\nimport { readFileScript, writeFileScript } from './file-script';\nimport { readScript, Script, writeScript } from './script';\nimport { readTrain, Train, writeTrain } from './train';\n\nexport type Coaster = ReturnType<typeof readCoaster>;\n\nexport const readCoaster = (stream: NoLimitsStream) => {\n  const name = readString(stream);\n\n  const colorsWireframeTrack = readColor(stream);\n\n  const modeSplinePosition = readUnsigned8(stream);\n  const modeSplinePositionOffset = readDoubleVector2(stream);\n\n  const description = readString(stream);\n\n  readNull(stream, 3);\n\n  const styleStyleType = readUnsigned8(stream);\n\n  const colorsRails = readColor(stream);\n  const colorsCrossTies = readColor(stream);\n  const colorsMainSpine = readColor(stream);\n  const colorsCar = readColor(stream);\n  const colorsSeat = readColor(stream);\n  const colorsHarness = readColor(stream);\n  const colorsBogie = readColor(stream);\n\n  const frozen = readBoolean(stream);\n\n  const colorsSpineColorScheme = readUnsigned8(stream);\n  const colorsSupports = readColor(stream);\n  const colorsTunnel = readColor(stream);\n\n  const styleWornType = readUnsigned8(stream);\n  const colorsChassis = readColor(stream);\n\n  const modeOperationMode = readUnsigned8(stream);\n  const styleRailType = readUnsigned8(stream);\n\n  const colorsHandrails = readColor(stream);\n  const colorsCatwalks = readColor(stream);\n\n  const modePhysicsModel = readUnsigned8(stream);\n  const hideWireframe = readBoolean(stream);\n\n  readNull(stream, 1);\n\n  const tracks: CustomTrack[] = [];\n  const trains: Train[] = [];\n  const scripts: Array<\n    | ({\n        scriptType: 'script';\n      } & Script)\n    | {\n        scriptType: 'file-script';\n        path: string;\n      }\n  > = [];\n  let customFriction: CustomFriction | undefined;\n\n  readChunks(\n    [\n      makeChunkReader(readCustomTrack, 'CUTK', (customTrack) =>\n        tracks.push(customTrack),\n      ),\n      makeChunkReader(readTrain, 'TRAI', (train) =>\n        trains.push(train),\n      ),\n      makeChunkReader(\n        readCustomFriction,\n        'CUFR',\n        (chunkCustomFriction) =>\n          (customFriction = chunkCustomFriction),\n      ),\n      makeChunkReader(readScript, 'SCRT', (script) =>\n        scripts.push({\n          scriptType: 'script',\n          ...script,\n        }),\n      ),\n      makeChunkReader(readFileScript, 'FSCR', (fileScripts) =>\n        fileScripts.paths.forEach((path) =>\n          scripts.push({\n            scriptType: 'file-script',\n            path,\n          }),\n        ),\n      ),\n    ],\n    stream,\n  );\n\n  return {\n    name,\n    description,\n    hideWireframe,\n    frozen,\n    tracks,\n    trains,\n    scripts,\n    customFriction,\n    mode: {\n      splinePosition: modeSplinePosition,\n      splinePositionOffset: modeSplinePositionOffset,\n      operationMode: modeOperationMode,\n      physicsModel: modePhysicsModel,\n    },\n    style: {\n      styleType: styleStyleType,\n      wornType: styleWornType,\n      railType: styleRailType,\n    },\n    colors: {\n      wireframeTrack: colorsWireframeTrack,\n      rails: colorsRails,\n      crossTies: colorsCrossTies,\n      mainSpine: colorsMainSpine,\n      car: colorsCar,\n      seat: colorsSeat,\n      harness: colorsHarness,\n      bogie: colorsBogie,\n      spineColorScheme: colorsSpineColorScheme,\n      supports: colorsSupports,\n      tunnel: colorsTunnel,\n      chassis: colorsChassis,\n      handrails: colorsHandrails,\n      catwalks: colorsCatwalks,\n    },\n  };\n};\n\nexport const writeCoaster = (\n  stream: NoLimitsStream,\n  coaster: Coaster,\n): void => {\n  writeString(stream, coaster.name);\n\n  writeColor(stream, coaster.colors.wireframeTrack);\n\n  writeUnsigned8(stream, coaster.mode.splinePosition);\n  writeDoubleVector2(stream, coaster.mode.splinePositionOffset);\n\n  writeString(stream, coaster.description);\n\n  writeNull(stream, 3);\n\n  writeUnsigned8(stream, coaster.style.styleType);\n\n  writeColor(stream, coaster.colors.rails);\n  writeColor(stream, coaster.colors.crossTies);\n  writeColor(stream, coaster.colors.mainSpine);\n  writeColor(stream, coaster.colors.car);\n  writeColor(stream, coaster.colors.seat);\n  writeColor(stream, coaster.colors.harness);\n  writeColor(stream, coaster.colors.bogie);\n\n  writeBoolean(stream, coaster.frozen);\n\n  writeUnsigned8(stream, coaster.colors.spineColorScheme);\n  writeColor(stream, coaster.colors.supports);\n  writeColor(stream, coaster.colors.tunnel);\n\n  writeUnsigned8(stream, coaster.style.wornType);\n  writeColor(stream, coaster.colors.chassis);\n\n  writeUnsigned8(stream, coaster.mode.operationMode);\n  writeUnsigned8(stream, coaster.style.railType);\n\n  writeColor(stream, coaster.colors.handrails);\n  writeColor(stream, coaster.colors.catwalks);\n\n  writeUnsigned8(stream, coaster.mode.physicsModel);\n  writeBoolean(stream, coaster.hideWireframe);\n\n  writeNull(stream, 1);\n\n  // chunks\n  for (const track of coaster.tracks) {\n    writeChunk(stream, 'CUTK', (s) => writeCustomTrack(s, track));\n  }\n\n  for (const train of coaster.trains) {\n    writeChunk(stream, 'TRAI', (s) => writeTrain(s, train));\n  }\n\n  writeChunk(stream, 'CUFR', (s) => {\n    if (!coaster.customFriction) return;\n    writeCustomFriction(s, coaster.customFriction);\n  });\n\n  coaster.scripts\n    .filter((s) => s.scriptType === 'script')\n    .forEach((script) =>\n      writeChunk(stream, 'SCRT', (s) =>\n        writeScript(s, script as Script),\n      ),\n    );\n\n  const fileScripts = compact(\n    coaster.scripts.map((s) =>\n      s.scriptType === 'file-script' ? s.path : undefined,\n    ),\n  );\n\n  if (fileScripts.length)\n    writeChunk(stream, 'FSCR', (s) => {\n      writeFileScript(s, {\n        paths: fileScripts,\n      });\n    });\n};\n",
    "functions": {},
    "types": {
      "Coaster": "type Coaster = ReturnType<typeof readCoaster>;"
    },
    "variables": {
      "readCoaster": "const readCoaster = (stream: NoLimitsStream) => {\n  const name = readString(stream);\n\n  const colorsWireframeTrack = readColor(stream);\n\n  const modeSplinePosition = readUnsigned8(stream);\n  const modeSplinePositionOffset = readDoubleVector2(stream);\n\n  const description = readString(stream);\n\n  readNull(stream, 3);\n\n  const styleStyleType = readUnsigned8(stream);\n\n  const colorsRails = readColor(stream);\n  const colorsCrossTies = readColor(stream);\n  const colorsMainSpine = readColor(stream);\n  const colorsCar = readColor(stream);\n  const colorsSeat = readColor(stream);\n  const colorsHarness = readColor(stream);\n  const colorsBogie = readColor(stream);\n\n  const frozen = readBoolean(stream);\n\n  const colorsSpineColorScheme = readUnsigned8(stream);\n  const colorsSupports = readColor(stream);\n  const colorsTunnel = readColor(stream);\n\n  const styleWornType = readUnsigned8(stream);\n  const colorsChassis = readColor(stream);\n\n  const modeOperationMode = readUnsigned8(stream);\n  const styleRailType = readUnsigned8(stream);\n\n  const colorsHandrails = readColor(stream);\n  const colorsCatwalks = readColor(stream);\n\n  const modePhysicsModel = readUnsigned8(stream);\n  const hideWireframe = readBoolean(stream);\n\n  readNull(stream, 1);\n\n  const tracks: CustomTrack[] = [];\n  const trains: Train[] = [];\n  const scripts: Array<\n    | ({\n        scriptType: 'script';\n      } & Script)\n    | {\n        scriptType: 'file-script';\n        path: string;\n      }\n  > = [];\n  let customFriction: CustomFriction | undefined;\n\n  readChunks(\n    [\n      makeChunkReader(readCustomTrack, 'CUTK', (customTrack) =>\n        tracks.push(customTrack),\n      ),\n      makeChunkReader(readTrain, 'TRAI', (train) =>\n        trains.push(train),\n      ),\n      makeChunkReader(\n        readCustomFriction,\n        'CUFR',\n        (chunkCustomFriction) =>\n          (customFriction = chunkCustomFriction),\n      ),\n      makeChunkReader(readScript, 'SCRT', (script) =>\n        scripts.push({\n          scriptType: 'script',\n          ...script,\n        }),\n      ),\n      makeChunkReader(readFileScript, 'FSCR', (fileScripts) =>\n        fileScripts.paths.forEach((path) =>\n          scripts.push({\n            scriptType: 'file-script',\n            path,\n          }),\n        ),\n      ),\n    ],\n    stream,\n  );\n\n  return {\n    name,\n    description,\n    hideWireframe,\n    frozen,\n    tracks,\n    trains,\n    scripts,\n    customFriction,\n    mode: {\n      splinePosition: modeSplinePosition,\n      splinePositionOffset: modeSplinePositionOffset,\n      operationMode: modeOperationMode,\n      physicsModel: modePhysicsModel,\n    },\n    style: {\n      styleType: styleStyleType,\n      wornType: styleWornType,\n      railType: styleRailType,\n    },\n    colors: {\n      wireframeTrack: colorsWireframeTrack,\n      rails: colorsRails,\n      crossTies: colorsCrossTies,\n      mainSpine: colorsMainSpine,\n      car: colorsCar,\n      seat: colorsSeat,\n      harness: colorsHarness,\n      bogie: colorsBogie,\n      spineColorScheme: colorsSpineColorScheme,\n      supports: colorsSupports,\n      tunnel: colorsTunnel,\n      chassis: colorsChassis,\n      handrails: colorsHandrails,\n      catwalks: colorsCatwalks,\n    },\n  };\n};",
      "writeCoaster": "const writeCoaster = (\n  stream: NoLimitsStream,\n  coaster: Coaster,\n): void => {\n  writeString(stream, coaster.name);\n\n  writeColor(stream, coaster.colors.wireframeTrack);\n\n  writeUnsigned8(stream, coaster.mode.splinePosition);\n  writeDoubleVector2(stream, coaster.mode.splinePositionOffset);\n\n  writeString(stream, coaster.description);\n\n  writeNull(stream, 3);\n\n  writeUnsigned8(stream, coaster.style.styleType);\n\n  writeColor(stream, coaster.colors.rails);\n  writeColor(stream, coaster.colors.crossTies);\n  writeColor(stream, coaster.colors.mainSpine);\n  writeColor(stream, coaster.colors.car);\n  writeColor(stream, coaster.colors.seat);\n  writeColor(stream, coaster.colors.harness);\n  writeColor(stream, coaster.colors.bogie);\n\n  writeBoolean(stream, coaster.frozen);\n\n  writeUnsigned8(stream, coaster.colors.spineColorScheme);\n  writeColor(stream, coaster.colors.supports);\n  writeColor(stream, coaster.colors.tunnel);\n\n  writeUnsigned8(stream, coaster.style.wornType);\n  writeColor(stream, coaster.colors.chassis);\n\n  writeUnsigned8(stream, coaster.mode.operationMode);\n  writeUnsigned8(stream, coaster.style.railType);\n\n  writeColor(stream, coaster.colors.handrails);\n  writeColor(stream, coaster.colors.catwalks);\n\n  writeUnsigned8(stream, coaster.mode.physicsModel);\n  writeBoolean(stream, coaster.hideWireframe);\n\n  writeNull(stream, 1);\n\n  // chunks\n  for (const track of coaster.tracks) {\n    writeChunk(stream, 'CUTK', (s) => writeCustomTrack(s, track));\n  }\n\n  for (const train of coaster.trains) {\n    writeChunk(stream, 'TRAI', (s) => writeTrain(s, train));\n  }\n\n  writeChunk(stream, 'CUFR', (s) => {\n    if (!coaster.customFriction) return;\n    writeCustomFriction(s, coaster.customFriction);\n  });\n\n  coaster.scripts\n    .filter((s) => s.scriptType === 'script')\n    .forEach((script) =>\n      writeChunk(stream, 'SCRT', (s) =>\n        writeScript(s, script as Script),\n      ),\n    );\n\n  const fileScripts = compact(\n    coaster.scripts.map((s) =>\n      s.scriptType === 'file-script' ? s.path : undefined,\n    ),\n  );\n\n  if (fileScripts.length)\n    writeChunk(stream, 'FSCR', (s) => {\n      writeFileScript(s, {\n        paths: fileScripts,\n      });\n    });\n};"
    }
  },
  "src/helper/nl2park/coaster/custom-friction.ts": {
    "source": "import {\n  NoLimitsStream,\n  readDouble,\n  readNull,\n  writeDouble,\n  writeNull,\n} from '../nolimits-stream';\n\nexport type CustomFriction = ReturnType<typeof readCustomFriction>;\n\nexport const readCustomFriction = (stream: NoLimitsStream) => {\n  const constFrictionParameter = readDouble(stream);\n  const airResistanceParameter = readDouble(stream);\n\n  readNull(stream, 32);\n\n  return {\n    constFrictionParameter,\n    airResistanceParameter,\n  };\n};\n\nexport const writeCustomFriction = (\n  stream: NoLimitsStream,\n  friction: CustomFriction,\n): void => {\n  writeDouble(stream, friction.constFrictionParameter);\n  writeDouble(stream, friction.airResistanceParameter);\n\n  writeNull(stream, 32);\n};\n",
    "functions": {},
    "types": {
      "CustomFriction": "type CustomFriction = ReturnType<typeof readCustomFriction>;"
    },
    "variables": {
      "readCustomFriction": "const readCustomFriction = (stream: NoLimitsStream) => {\n  const constFrictionParameter = readDouble(stream);\n  const airResistanceParameter = readDouble(stream);\n\n  readNull(stream, 32);\n\n  return {\n    constFrictionParameter,\n    airResistanceParameter,\n  };\n};",
      "writeCustomFriction": "const writeCustomFriction = (\n  stream: NoLimitsStream,\n  friction: CustomFriction,\n): void => {\n  writeDouble(stream, friction.constFrictionParameter);\n  writeDouble(stream, friction.airResistanceParameter);\n\n  writeNull(stream, 32);\n};"
    }
  },
  "src/helper/nl2park/coaster/file-script.ts": {
    "source": "import {\n  NoLimitsStream,\n  readNull,\n  readString,\n  readUnsignedInteger,\n  writeNull,\n  writeString,\n  writeUnsignedInteger,\n} from '../nolimits-stream';\n\nexport type FileScript = ReturnType<typeof readFileScript>;\n\nexport const readFileScript = (stream: NoLimitsStream) => {\n  const paths: string[] = [];\n\n  const numberOfFileScripts = readUnsignedInteger(stream);\n  for (let i = 0; i < numberOfFileScripts; i++) {\n    paths.push(readString(stream));\n    readNull(stream, 8);\n  }\n\n  readNull(stream, 8);\n\n  return {\n    paths,\n  };\n};\n\nexport const writeFileScript = (\n  stream: NoLimitsStream,\n  fileScript: FileScript,\n): void => {\n  writeUnsignedInteger(stream, fileScript.paths.length);\n  for (const path of fileScript.paths) {\n    writeString(stream, path);\n    writeNull(stream, 8);\n  }\n\n  writeNull(stream, 8);\n};\n",
    "functions": {},
    "types": {
      "FileScript": "type FileScript = ReturnType<typeof readFileScript>;"
    },
    "variables": {
      "readFileScript": "const readFileScript = (stream: NoLimitsStream) => {\n  const paths: string[] = [];\n\n  const numberOfFileScripts = readUnsignedInteger(stream);\n  for (let i = 0; i < numberOfFileScripts; i++) {\n    paths.push(readString(stream));\n    readNull(stream, 8);\n  }\n\n  readNull(stream, 8);\n\n  return {\n    paths,\n  };\n};",
      "writeFileScript": "const writeFileScript = (\n  stream: NoLimitsStream,\n  fileScript: FileScript,\n): void => {\n  writeUnsignedInteger(stream, fileScript.paths.length);\n  for (const path of fileScript.paths) {\n    writeString(stream, path);\n    writeNull(stream, 8);\n  }\n\n  writeNull(stream, 8);\n};"
    }
  },
  "src/helper/nl2park/coaster/individual-color.ts": {
    "source": "import {\n  NoLimitsStream,\n  readBoolean,\n  readColor,\n  readNull,\n  readString,\n  readUnsignedInteger,\n  writeBoolean,\n  writeColor,\n  writeNull,\n  writeString,\n  writeUnsignedInteger,\n} from '../nolimits-stream';\n\nexport type IndividualColor = ReturnType<typeof readIndividualColor>;\n\nexport const readIndividualColor = (stream: NoLimitsStream) => {\n  const hasIndividualColor = readBoolean(stream);\n\n  const carColor = readColor(stream);\n  const seatColor = readColor(stream);\n  const harnessColor = readColor(stream);\n  const bogieColor = readColor(stream);\n  const chassisColor = readColor(stream);\n\n  readNull(stream, 16);\n\n  const carTextures: string[] = [];\n\n  const numberOfTextures = readUnsignedInteger(stream);\n  for (let i = 0; i < numberOfTextures; i++) {\n    readNull(stream, 4);\n    carTextures.push(readString(stream));\n    readNull(stream, 8);\n  }\n\n  return {\n    hasIndividualColor,\n    carColor,\n    seatColor,\n    harnessColor,\n    bogieColor,\n    chassisColor,\n    carTextures,\n  };\n};\n\nexport const writeIndividualColor = (\n  stream: NoLimitsStream,\n  color: IndividualColor,\n): void => {\n  writeBoolean(stream, color.hasIndividualColor);\n\n  writeColor(stream, color.carColor);\n  writeColor(stream, color.seatColor);\n  writeColor(stream, color.harnessColor);\n  writeColor(stream, color.bogieColor);\n  writeColor(stream, color.chassisColor);\n\n  writeNull(stream, 16);\n\n  writeUnsignedInteger(stream, color.carTextures.length);\n  for (const texture of color.carTextures) {\n    writeNull(stream, 4);\n    writeString(stream, texture);\n    writeNull(stream, 8);\n  }\n};\n",
    "functions": {},
    "types": {
      "IndividualColor": "type IndividualColor = ReturnType<typeof readIndividualColor>;"
    },
    "variables": {
      "readIndividualColor": "const readIndividualColor = (stream: NoLimitsStream) => {\n  const hasIndividualColor = readBoolean(stream);\n\n  const carColor = readColor(stream);\n  const seatColor = readColor(stream);\n  const harnessColor = readColor(stream);\n  const bogieColor = readColor(stream);\n  const chassisColor = readColor(stream);\n\n  readNull(stream, 16);\n\n  const carTextures: string[] = [];\n\n  const numberOfTextures = readUnsignedInteger(stream);\n  for (let i = 0; i < numberOfTextures; i++) {\n    readNull(stream, 4);\n    carTextures.push(readString(stream));\n    readNull(stream, 8);\n  }\n\n  return {\n    hasIndividualColor,\n    carColor,\n    seatColor,\n    harnessColor,\n    bogieColor,\n    chassisColor,\n    carTextures,\n  };\n};",
      "writeIndividualColor": "const writeIndividualColor = (\n  stream: NoLimitsStream,\n  color: IndividualColor,\n): void => {\n  writeBoolean(stream, color.hasIndividualColor);\n\n  writeColor(stream, color.carColor);\n  writeColor(stream, color.seatColor);\n  writeColor(stream, color.harnessColor);\n  writeColor(stream, color.bogieColor);\n  writeColor(stream, color.chassisColor);\n\n  writeNull(stream, 16);\n\n  writeUnsignedInteger(stream, color.carTextures.length);\n  for (const texture of color.carTextures) {\n    writeNull(stream, 4);\n    writeString(stream, texture);\n    writeNull(stream, 8);\n  }\n};"
    }
  },
  "src/helper/nl2park/coaster/script.ts": {
    "source": "import {\n  NoLimitsStream,\n  readBoolean,\n  readNull,\n  readString,\n  readUnsignedInteger,\n  writeBoolean,\n  writeNull,\n  writeString,\n  writeUnsignedInteger,\n} from '../nolimits-stream';\n\nexport type Script = ReturnType<typeof readScript>;\n\nexport const readScript = (stream: NoLimitsStream) => {\n  const resourceFiles: Array<{\n    id: string;\n    path: string;\n  }> = [];\n\n  readNull(stream, 4);\n\n  const classPath = readString(stream);\n  const scriptClass = readString(stream);\n\n  const numberOfResourceFiles = readUnsignedInteger(stream);\n  for (let i = 0; i < numberOfResourceFiles; i++) {\n    resourceFiles.push({\n      id: readString(stream),\n      path: readString(stream),\n    });\n  }\n\n  const privateVirtualMachine = !readBoolean(stream);\n\n  readNull(stream, 7);\n\n  return {\n    classPath,\n    scriptClass,\n    resourceFiles,\n    privateVirtualMachine,\n  };\n};\n\nexport const writeScript = (\n  stream: NoLimitsStream,\n  script: Script,\n): void => {\n  writeNull(stream, 4);\n\n  writeString(stream, script.classPath);\n  writeString(stream, script.scriptClass);\n\n  writeUnsignedInteger(stream, script.resourceFiles.length);\n  for (const res of script.resourceFiles) {\n    writeString(stream, res.id);\n    writeString(stream, res.path);\n  }\n\n  writeBoolean(stream, !script.privateVirtualMachine);\n\n  writeNull(stream, 7);\n};\n",
    "functions": {},
    "types": {
      "Script": "type Script = ReturnType<typeof readScript>;"
    },
    "variables": {
      "readScript": "const readScript = (stream: NoLimitsStream) => {\n  const resourceFiles: Array<{\n    id: string;\n    path: string;\n  }> = [];\n\n  readNull(stream, 4);\n\n  const classPath = readString(stream);\n  const scriptClass = readString(stream);\n\n  const numberOfResourceFiles = readUnsignedInteger(stream);\n  for (let i = 0; i < numberOfResourceFiles; i++) {\n    resourceFiles.push({\n      id: readString(stream),\n      path: readString(stream),\n    });\n  }\n\n  const privateVirtualMachine = !readBoolean(stream);\n\n  readNull(stream, 7);\n\n  return {\n    classPath,\n    scriptClass,\n    resourceFiles,\n    privateVirtualMachine,\n  };\n};",
      "writeScript": "const writeScript = (\n  stream: NoLimitsStream,\n  script: Script,\n): void => {\n  writeNull(stream, 4);\n\n  writeString(stream, script.classPath);\n  writeString(stream, script.scriptClass);\n\n  writeUnsignedInteger(stream, script.resourceFiles.length);\n  for (const res of script.resourceFiles) {\n    writeString(stream, res.id);\n    writeString(stream, res.path);\n  }\n\n  writeBoolean(stream, !script.privateVirtualMachine);\n\n  writeNull(stream, 7);\n};"
    }
  },
  "src/helper/nl2park/coaster/train.ts": {
    "source": "import {\n  makeChunkReader,\n  NoLimitsStream,\n  readBoolean,\n  readChunks,\n  readNull,\n  readString,\n  readUnsignedInteger,\n  writeBoolean,\n  writeChunk,\n  writeNull,\n  writeString,\n  writeUnsignedInteger,\n} from '../nolimits-stream';\nimport { readCar, writeCar } from './car';\nimport {\n  IndividualColor,\n  readIndividualColor,\n  writeIndividualColor,\n} from './individual-color';\n\nexport type Train = ReturnType<typeof readTrain>;\n\nexport const readTrain = (stream: NoLimitsStream) => {\n  const cars: ReturnType<typeof readCar>[] = [];\n\n  let individualColor: IndividualColor | undefined;\n  const startBlock = readString(stream);\n\n  readUnsignedInteger(stream); // number of cars (ignored, cars are read via CAR chunks)\n  readNull(stream, 4);\n\n  const runBackward = readBoolean(stream);\n  const removedFromTrack = readBoolean(stream);\n\n  readNull(stream, 31);\n\n  readChunks(\n    [\n      makeChunkReader(readCar, 'CAR', (car) => cars.push(car)),\n      makeChunkReader(\n        readIndividualColor,\n        'INDC',\n        (color) => (individualColor = color),\n      ),\n    ],\n    stream,\n  );\n\n  return {\n    startBlock,\n    runBackward,\n    removedFromTrack,\n    cars,\n    individualColor,\n  };\n};\n\nexport const writeTrain = (\n  stream: NoLimitsStream,\n  train: Train,\n): void => {\n  writeString(stream, train.startBlock);\n\n  writeUnsignedInteger(stream, train.cars.length);\n\n  writeNull(stream, 4);\n\n  writeBoolean(stream, train.runBackward);\n  writeBoolean(stream, train.removedFromTrack);\n\n  writeNull(stream, 31);\n\n  for (const car of train.cars) {\n    writeChunk(stream, 'CAR', (s) => writeCar(s, car));\n  }\n\n  writeChunk(stream, 'INDC', (s) => {\n    if (!train.individualColor) return;\n    writeIndividualColor(s, train.individualColor);\n  });\n};\n",
    "functions": {},
    "types": {
      "Train": "type Train = ReturnType<typeof readTrain>;"
    },
    "variables": {
      "readTrain": "const readTrain = (stream: NoLimitsStream) => {\n  const cars: ReturnType<typeof readCar>[] = [];\n\n  let individualColor: IndividualColor | undefined;\n  const startBlock = readString(stream);\n\n  readUnsignedInteger(stream); // number of cars (ignored, cars are read via CAR chunks)\n  readNull(stream, 4);\n\n  const runBackward = readBoolean(stream);\n  const removedFromTrack = readBoolean(stream);\n\n  readNull(stream, 31);\n\n  readChunks(\n    [\n      makeChunkReader(readCar, 'CAR', (car) => cars.push(car)),\n      makeChunkReader(\n        readIndividualColor,\n        'INDC',\n        (color) => (individualColor = color),\n      ),\n    ],\n    stream,\n  );\n\n  return {\n    startBlock,\n    runBackward,\n    removedFromTrack,\n    cars,\n    individualColor,\n  };\n};",
      "writeTrain": "const writeTrain = (\n  stream: NoLimitsStream,\n  train: Train,\n): void => {\n  writeString(stream, train.startBlock);\n\n  writeUnsignedInteger(stream, train.cars.length);\n\n  writeNull(stream, 4);\n\n  writeBoolean(stream, train.runBackward);\n  writeBoolean(stream, train.removedFromTrack);\n\n  writeNull(stream, 31);\n\n  for (const car of train.cars) {\n    writeChunk(stream, 'CAR', (s) => writeCar(s, car));\n  }\n\n  writeChunk(stream, 'INDC', (s) => {\n    if (!train.individualColor) return;\n    writeIndividualColor(s, train.individualColor);\n  });\n};"
    }
  },
  "src/helper/nl2park/section/brake-section.ts": {
    "source": "import {\n  NoLimitsStream,\n  readBoolean,\n  readDouble,\n  readNull,\n  readUnsigned8,\n  writeBoolean,\n  writeDouble,\n  writeNull,\n  writeUnsigned8,\n} from '../nolimits-stream';\n\nexport type BrakeSection = ReturnType<typeof readBrakeSection>;\n\nexport const readBrakeSection = (stream: NoLimitsStream) => {\n  const mode = readUnsigned8(stream); // Brake::BrakeMode\n  const brakeType = readUnsigned8(stream); // Brake::BrakeType\n  const deceleration = readDouble(stream);\n  const speedLimit = readDouble(stream);\n  const hysteresis = readDouble(stream);\n\n  const positionOnTrain = readUnsigned8(stream); // Brake::Position\n  const positionOnSection = readDouble(stream);\n\n  const completeStop = readBoolean(stream);\n  const waitTime = readDouble(stream);\n\n  readNull(stream, 23);\n\n  const enableTransport = readBoolean(stream);\n\n  const transportType = readUnsigned8(stream); // Transport::TransportType\n  const transportSpeed = readDouble(stream);\n  const transportAcceleration = readDouble(stream);\n  const transportDeceleration = readDouble(stream);\n  const transportLaunch = readBoolean(stream);\n  const transportLaunchAcceleration = readDouble(stream);\n  const transportLaunchMaxSpeed = readDouble(stream);\n\n  const extraBlockLength = readDouble(stream);\n\n  readNull(stream, 75);\n\n  const transportDevice = {\n    transportType,\n    speed: transportSpeed,\n    acceleration: transportAcceleration,\n    deceleration: transportDeceleration,\n    launch: transportLaunch,\n    launchAcceleration: transportLaunchAcceleration,\n    launchMaxSpeed: transportLaunchMaxSpeed,\n  };\n\n  return {\n    mode,\n    brakeType,\n    deceleration,\n    speedLimit,\n    hysteresis,\n    positionOnTrain,\n    positionOnSection,\n    completeStop,\n    waitTime,\n    enableTransport,\n    transportDevice,\n    extraBlockLength,\n  };\n};\n\nexport const writeBrakeSection = (\n  stream: NoLimitsStream,\n  brake: BrakeSection,\n): void => {\n  writeUnsigned8(stream, brake.mode);\n  writeUnsigned8(stream, brake.brakeType);\n  writeDouble(stream, brake.deceleration);\n  writeDouble(stream, brake.speedLimit);\n  writeDouble(stream, brake.hysteresis);\n\n  writeUnsigned8(stream, brake.positionOnTrain);\n  writeDouble(stream, brake.positionOnSection);\n\n  writeBoolean(stream, brake.completeStop);\n  writeDouble(stream, brake.waitTime);\n\n  writeNull(stream, 23);\n\n  writeBoolean(stream, brake.enableTransport);\n\n  writeUnsigned8(stream, brake.transportDevice.transportType);\n  writeDouble(stream, brake.transportDevice.speed);\n  writeDouble(stream, brake.transportDevice.acceleration);\n  writeDouble(stream, brake.transportDevice.deceleration);\n  writeBoolean(stream, brake.transportDevice.launch);\n  writeDouble(stream, brake.transportDevice.launchAcceleration);\n  writeDouble(stream, brake.transportDevice.launchMaxSpeed);\n\n  writeDouble(stream, brake.extraBlockLength);\n\n  writeNull(stream, 75);\n};\n",
    "functions": {},
    "types": {
      "BrakeSection": "type BrakeSection = ReturnType<typeof readBrakeSection>;"
    },
    "variables": {
      "readBrakeSection": "const readBrakeSection = (stream: NoLimitsStream) => {\n  const mode = readUnsigned8(stream); // Brake::BrakeMode\n  const brakeType = readUnsigned8(stream); // Brake::BrakeType\n  const deceleration = readDouble(stream);\n  const speedLimit = readDouble(stream);\n  const hysteresis = readDouble(stream);\n\n  const positionOnTrain = readUnsigned8(stream); // Brake::Position\n  const positionOnSection = readDouble(stream);\n\n  const completeStop = readBoolean(stream);\n  const waitTime = readDouble(stream);\n\n  readNull(stream, 23);\n\n  const enableTransport = readBoolean(stream);\n\n  const transportType = readUnsigned8(stream); // Transport::TransportType\n  const transportSpeed = readDouble(stream);\n  const transportAcceleration = readDouble(stream);\n  const transportDeceleration = readDouble(stream);\n  const transportLaunch = readBoolean(stream);\n  const transportLaunchAcceleration = readDouble(stream);\n  const transportLaunchMaxSpeed = readDouble(stream);\n\n  const extraBlockLength = readDouble(stream);\n\n  readNull(stream, 75);\n\n  const transportDevice = {\n    transportType,\n    speed: transportSpeed,\n    acceleration: transportAcceleration,\n    deceleration: transportDeceleration,\n    launch: transportLaunch,\n    launchAcceleration: transportLaunchAcceleration,\n    launchMaxSpeed: transportLaunchMaxSpeed,\n  };\n\n  return {\n    mode,\n    brakeType,\n    deceleration,\n    speedLimit,\n    hysteresis,\n    positionOnTrain,\n    positionOnSection,\n    completeStop,\n    waitTime,\n    enableTransport,\n    transportDevice,\n    extraBlockLength,\n  };\n};",
      "writeBrakeSection": "const writeBrakeSection = (\n  stream: NoLimitsStream,\n  brake: BrakeSection,\n): void => {\n  writeUnsigned8(stream, brake.mode);\n  writeUnsigned8(stream, brake.brakeType);\n  writeDouble(stream, brake.deceleration);\n  writeDouble(stream, brake.speedLimit);\n  writeDouble(stream, brake.hysteresis);\n\n  writeUnsigned8(stream, brake.positionOnTrain);\n  writeDouble(stream, brake.positionOnSection);\n\n  writeBoolean(stream, brake.completeStop);\n  writeDouble(stream, brake.waitTime);\n\n  writeNull(stream, 23);\n\n  writeBoolean(stream, brake.enableTransport);\n\n  writeUnsigned8(stream, brake.transportDevice.transportType);\n  writeDouble(stream, brake.transportDevice.speed);\n  writeDouble(stream, brake.transportDevice.acceleration);\n  writeDouble(stream, brake.transportDevice.deceleration);\n  writeBoolean(stream, brake.transportDevice.launch);\n  writeDouble(stream, brake.transportDevice.launchAcceleration);\n  writeDouble(stream, brake.transportDevice.launchMaxSpeed);\n\n  writeDouble(stream, brake.extraBlockLength);\n\n  writeNull(stream, 75);\n};"
    }
  },
  "src/helper/nl2park/section/lift-section.ts": {
    "source": "import {\n  NoLimitsStream,\n  readBoolean,\n  readDouble,\n  readNull,\n  readUnsigned8,\n  writeBoolean,\n  writeDouble,\n  writeNull,\n  writeUnsigned8,\n} from '../nolimits-stream';\n\nexport type LiftSection = ReturnType<typeof readLiftSection>;\n\nexport const readLiftSection = (stream: NoLimitsStream) => {\n  readNull(stream, 3);\n  const liftType = readUnsigned8(stream);\n  readNull(stream, 3);\n\n  const motorLocation = readUnsigned8(stream);\n  const speed = readDouble(stream);\n  const acceleration = readDouble(stream);\n  const deceleration = readDouble(stream);\n\n  const hasAntiRollbackDevice = readBoolean(stream);\n  const shuttleModeGentle2ndPassRelease = readBoolean(stream);\n  const extraBlockLength = readDouble(stream);\n\n  const diveCoasterDropReleaseMode = readBoolean(stream);\n\n  readNull(stream, 29);\n\n  return {\n    liftType,\n    motorLocation,\n    speed,\n    acceleration,\n    deceleration,\n    hasAntiRollbackDevice,\n    shuttleModeGentle2ndPassRelease,\n    extraBlockLength,\n    diveCoasterDropReleaseMode,\n  };\n};\n\nexport const writeLiftSection = (\n  stream: NoLimitsStream,\n  lift: LiftSection,\n): void => {\n  writeNull(stream, 3);\n  writeUnsigned8(stream, lift.liftType);\n  writeNull(stream, 3);\n\n  writeUnsigned8(stream, lift.motorLocation);\n  writeDouble(stream, lift.speed);\n  writeDouble(stream, lift.acceleration);\n  writeDouble(stream, lift.deceleration);\n\n  writeBoolean(stream, lift.hasAntiRollbackDevice);\n  writeBoolean(stream, lift.shuttleModeGentle2ndPassRelease);\n  writeDouble(stream, lift.extraBlockLength);\n\n  writeBoolean(stream, lift.diveCoasterDropReleaseMode);\n\n  writeNull(stream, 29);\n};\n",
    "functions": {},
    "types": {
      "LiftSection": "type LiftSection = ReturnType<typeof readLiftSection>;"
    },
    "variables": {
      "readLiftSection": "const readLiftSection = (stream: NoLimitsStream) => {\n  readNull(stream, 3);\n  const liftType = readUnsigned8(stream);\n  readNull(stream, 3);\n\n  const motorLocation = readUnsigned8(stream);\n  const speed = readDouble(stream);\n  const acceleration = readDouble(stream);\n  const deceleration = readDouble(stream);\n\n  const hasAntiRollbackDevice = readBoolean(stream);\n  const shuttleModeGentle2ndPassRelease = readBoolean(stream);\n  const extraBlockLength = readDouble(stream);\n\n  const diveCoasterDropReleaseMode = readBoolean(stream);\n\n  readNull(stream, 29);\n\n  return {\n    liftType,\n    motorLocation,\n    speed,\n    acceleration,\n    deceleration,\n    hasAntiRollbackDevice,\n    shuttleModeGentle2ndPassRelease,\n    extraBlockLength,\n    diveCoasterDropReleaseMode,\n  };\n};",
      "writeLiftSection": "const writeLiftSection = (\n  stream: NoLimitsStream,\n  lift: LiftSection,\n): void => {\n  writeNull(stream, 3);\n  writeUnsigned8(stream, lift.liftType);\n  writeNull(stream, 3);\n\n  writeUnsigned8(stream, lift.motorLocation);\n  writeDouble(stream, lift.speed);\n  writeDouble(stream, lift.acceleration);\n  writeDouble(stream, lift.deceleration);\n\n  writeBoolean(stream, lift.hasAntiRollbackDevice);\n  writeBoolean(stream, lift.shuttleModeGentle2ndPassRelease);\n  writeDouble(stream, lift.extraBlockLength);\n\n  writeBoolean(stream, lift.diveCoasterDropReleaseMode);\n\n  writeNull(stream, 29);\n};"
    }
  },
  "src/helper/nl2park/section/section.ts": {
    "source": "import {\n  makeChunkReader,\n  NoLimitsStream,\n  readChunks,\n  readNull,\n  readString,\n  readUnsignedInteger,\n  writeChunk,\n  writeNull,\n  writeString,\n  writeUnsignedInteger,\n} from '../nolimits-stream';\nimport {\n  BrakeSection,\n  readBrakeSection,\n  writeBrakeSection,\n} from './brake-section';\nimport {\n  LiftSection,\n  readLiftSection,\n  writeLiftSection,\n} from './lift-section';\nimport {\n  readStationSection,\n  StationSection,\n  writeStationSection,\n} from './station-section';\nimport {\n  readStorageSection,\n  StorageSection,\n  writeStorageSection,\n} from './storage-section';\nimport {\n  readTransportSection,\n  TransportSection,\n  writeTransportSection,\n} from './transport-section';\n\nexport type Section = {\n  name: string;\n} & (\n  | ({\n      sectionType: SectionType.Lift;\n    } & LiftSection)\n  | ({\n      sectionType: SectionType.Transport;\n    } & TransportSection)\n  | ({\n      sectionType: SectionType.Brake;\n    } & BrakeSection)\n  | ({\n      sectionType: SectionType.Station;\n    } & StationSection)\n  | ({\n      sectionType: SectionType.Storage;\n    } & StorageSection)\n  | {\n      sectionType: SectionType.Track;\n    }\n);\n\nexport enum SectionType {\n  Track = 0,\n  Station = 1,\n  Lift = 2,\n  Transport = 3,\n  Brake = 4,\n  Storage = 5,\n}\n\nexport const readSection = (stream: NoLimitsStream) => {\n  readUnsignedInteger(stream); // section type\n  const name = readString(stream);\n  readNull(stream, 26);\n\n  let section:\n    | ({\n        sectionType: SectionType.Lift;\n      } & LiftSection)\n    | ({\n        sectionType: SectionType.Transport;\n      } & TransportSection)\n    | ({\n        sectionType: SectionType.Brake;\n      } & BrakeSection)\n    | ({\n        sectionType: SectionType.Station;\n      } & StationSection)\n    | ({\n        sectionType: SectionType.Storage;\n      } & StorageSection)\n    | {\n        sectionType: SectionType.Track;\n      } = { sectionType: SectionType.Track };\n\n  readChunks(\n    [\n      makeChunkReader(readLiftSection, 'LIFT', (lift) => {\n        section = {\n          sectionType: SectionType.Lift,\n          ...lift,\n        };\n      }),\n      makeChunkReader(readTransportSection, 'TRNS', (transport) => {\n        section = {\n          sectionType: SectionType.Transport,\n          ...transport,\n        };\n      }),\n      makeChunkReader(readBrakeSection, 'BRKE', (brake) => {\n        section = {\n          sectionType: SectionType.Brake,\n          ...brake,\n        };\n      }),\n      makeChunkReader(readStationSection, 'STTN', (station) => {\n        section = {\n          sectionType: SectionType.Station,\n          ...station,\n        };\n      }),\n      makeChunkReader(readStorageSection, 'STOR', (storage) => {\n        section = {\n          sectionType: SectionType.Storage,\n          ...storage,\n        };\n      }),\n    ],\n    stream,\n  );\n\n  return {\n    name,\n    ...section,\n  };\n};\n\nexport const writeSection = (\n  stream: NoLimitsStream,\n  section: Section,\n): void => {\n  writeUnsignedInteger(stream, section.sectionType);\n  writeString(stream, section.name);\n  writeNull(stream, 26);\n\n  switch (section.sectionType) {\n    case SectionType.Lift:\n      writeChunk(stream, 'LIFT', (s) => writeLiftSection(s, section));\n      break;\n\n    case SectionType.Transport:\n      writeChunk(stream, 'TRNS', (s) =>\n        writeTransportSection(s, section),\n      );\n      break;\n\n    case SectionType.Brake:\n      writeChunk(stream, 'BRKE', (s) =>\n        writeBrakeSection(s, section),\n      );\n      break;\n\n    case SectionType.Station:\n      writeChunk(stream, 'STTN', (s) =>\n        writeStationSection(s, section),\n      );\n      break;\n\n    case SectionType.Storage:\n      writeChunk(stream, 'STOR', (s) =>\n        writeStorageSection(s, section),\n      );\n      break;\n  }\n};\n",
    "functions": {},
    "types": {
      "Section": "type Section = {\n  name: string;\n} & (\n  | ({\n      sectionType: SectionType.Lift;\n    } & LiftSection)\n  | ({\n      sectionType: SectionType.Transport;\n    } & TransportSection)\n  | ({\n      sectionType: SectionType.Brake;\n    } & BrakeSection)\n  | ({\n      sectionType: SectionType.Station;\n    } & StationSection)\n  | ({\n      sectionType: SectionType.Storage;\n    } & StorageSection)\n  | {\n      sectionType: SectionType.Track;\n    }\n);"
    },
    "variables": {
      "readSection": "const readSection = (stream: NoLimitsStream) => {\n  readUnsignedInteger(stream); // section type\n  const name = readString(stream);\n  readNull(stream, 26);\n\n  let section:\n    | ({\n        sectionType: SectionType.Lift;\n      } & LiftSection)\n    | ({\n        sectionType: SectionType.Transport;\n      } & TransportSection)\n    | ({\n        sectionType: SectionType.Brake;\n      } & BrakeSection)\n    | ({\n        sectionType: SectionType.Station;\n      } & StationSection)\n    | ({\n        sectionType: SectionType.Storage;\n      } & StorageSection)\n    | {\n        sectionType: SectionType.Track;\n      } = { sectionType: SectionType.Track };\n\n  readChunks(\n    [\n      makeChunkReader(readLiftSection, 'LIFT', (lift) => {\n        section = {\n          sectionType: SectionType.Lift,\n          ...lift,\n        };\n      }),\n      makeChunkReader(readTransportSection, 'TRNS', (transport) => {\n        section = {\n          sectionType: SectionType.Transport,\n          ...transport,\n        };\n      }),\n      makeChunkReader(readBrakeSection, 'BRKE', (brake) => {\n        section = {\n          sectionType: SectionType.Brake,\n          ...brake,\n        };\n      }),\n      makeChunkReader(readStationSection, 'STTN', (station) => {\n        section = {\n          sectionType: SectionType.Station,\n          ...station,\n        };\n      }),\n      makeChunkReader(readStorageSection, 'STOR', (storage) => {\n        section = {\n          sectionType: SectionType.Storage,\n          ...storage,\n        };\n      }),\n    ],\n    stream,\n  );\n\n  return {\n    name,\n    ...section,\n  };\n};",
      "writeSection": "const writeSection = (\n  stream: NoLimitsStream,\n  section: Section,\n): void => {\n  writeUnsignedInteger(stream, section.sectionType);\n  writeString(stream, section.name);\n  writeNull(stream, 26);\n\n  switch (section.sectionType) {\n    case SectionType.Lift:\n      writeChunk(stream, 'LIFT', (s) => writeLiftSection(s, section));\n      break;\n\n    case SectionType.Transport:\n      writeChunk(stream, 'TRNS', (s) =>\n        writeTransportSection(s, section),\n      );\n      break;\n\n    case SectionType.Brake:\n      writeChunk(stream, 'BRKE', (s) =>\n        writeBrakeSection(s, section),\n      );\n      break;\n\n    case SectionType.Station:\n      writeChunk(stream, 'STTN', (s) =>\n        writeStationSection(s, section),\n      );\n      break;\n\n    case SectionType.Storage:\n      writeChunk(stream, 'STOR', (s) =>\n        writeStorageSection(s, section),\n      );\n      break;\n  }\n};"
    }
  },
  "src/helper/nl2park/section/station-section.ts": {
    "source": "import {\n  NoLimitsStream,\n  readBoolean,\n  readColor,\n  readDouble,\n  readNull,\n  readUnsigned8,\n  readUnsignedInteger,\n  writeBoolean,\n  writeColor,\n  writeDouble,\n  writeNull,\n  writeUnsigned8,\n  writeUnsignedInteger,\n} from '../nolimits-stream';\n\nexport type StationSection = ReturnType<typeof readStationSection>;\n\nexport const readStationSection = (stream: NoLimitsStream) => {\n  const useTransportDevice = readBoolean(stream);\n\n  const transportTransportType = readUnsigned8(stream); // Transport::TransportType\n  const transportSpeed = readDouble(stream);\n  const transportAcceleration = readDouble(stream);\n  const transportDeceleration = readDouble(stream);\n\n  const brakeDeceleration = readDouble(stream);\n\n  const waitTimeAverage = readDouble(stream);\n  const waitTimeMinimum = readDouble(stream);\n  const waitTimeMaximum = readDouble(stream);\n  const waitTimeDeviation = readDouble(stream);\n\n  const transportLaunch = readBoolean(stream);\n  const transportLaunchAcceleration = readDouble(stream);\n  const transportLaunchMaxSpeed = readDouble(stream);\n\n  const unloadingOnly = readBoolean(stream);\n\n  readNull(stream, 3);\n\n  const passes = readUnsigned8(stream);\n  const shuttleBackwardsStart = readBoolean(stream);\n  const stationNumber = readUnsignedInteger(stream);\n\n  readNull(stream, 3);\n\n  const numSynchronizeDispatchWith = readUnsigned8(stream);\n  const synchronizeDispatchWith: number[] = [];\n\n  for (let i = 0; i < numSynchronizeDispatchWith; i++) {\n    synchronizeDispatchWith.push(readUnsignedInteger(stream));\n  }\n\n  const extraBlockLength = readDouble(stream);\n\n  const brakeType = readUnsigned8(stream); // Brake::BrakeType\n  const gateDirection = readUnsigned8(stream); // Station::GateDirection\n  const display = readUnsigned8(stream); // Station::Display\n  const entranceStairs = readUnsigned8(stream); // Station::Stairs\n  const exitStairs = readUnsigned8(stream); // Station::Stairs\n\n  readNull(stream, 1);\n\n  const gatesColor = readColor(stream);\n  const railingsColor = readColor(stream);\n  const structureColor = readColor(stream);\n\n  readNull(stream, 142);\n\n  return {\n    useTransportDevice,\n    transportDevice: {\n      transportType: transportTransportType,\n      speed: transportSpeed,\n      acceleration: transportAcceleration,\n      deceleration: transportDeceleration,\n      launch: transportLaunch,\n      launchAcceleration: transportLaunchAcceleration,\n      launchMaxSpeed: transportLaunchMaxSpeed,\n    },\n    brakeDevice: {\n      deceleration: brakeDeceleration,\n      brakeType,\n    },\n    waitTime: {\n      average: waitTimeAverage,\n      minimum: waitTimeMinimum,\n      maximum: waitTimeMaximum,\n      deviation: waitTimeDeviation,\n      synchronizeDispatchWith,\n    },\n    unloadingOnly,\n    passes,\n    shuttleBackwardsStart,\n    stationNumber,\n    extraBlockLength,\n    gateDirection,\n    display,\n    entranceStairs,\n    exitStairs,\n    gatesColor,\n    railingsColor,\n    structureColor,\n  };\n};\n\nexport const writeStationSection = (\n  stream: NoLimitsStream,\n  station: StationSection,\n): void => {\n  writeBoolean(stream, station.useTransportDevice);\n\n  writeUnsigned8(stream, station.transportDevice.transportType);\n  writeDouble(stream, station.transportDevice.speed);\n  writeDouble(stream, station.transportDevice.acceleration);\n  writeDouble(stream, station.transportDevice.deceleration);\n\n  writeDouble(stream, station.brakeDevice.deceleration);\n\n  writeDouble(stream, station.waitTime.average);\n  writeDouble(stream, station.waitTime.minimum);\n  writeDouble(stream, station.waitTime.maximum);\n  writeDouble(stream, station.waitTime.deviation);\n\n  writeBoolean(stream, station.transportDevice.launch);\n  writeDouble(stream, station.transportDevice.launchAcceleration);\n  writeDouble(stream, station.transportDevice.launchMaxSpeed);\n\n  writeBoolean(stream, station.unloadingOnly);\n\n  writeNull(stream, 3);\n\n  writeUnsigned8(stream, station.passes);\n  writeBoolean(stream, station.shuttleBackwardsStart);\n  writeUnsignedInteger(stream, station.stationNumber);\n\n  writeNull(stream, 3);\n\n  writeUnsigned8(\n    stream,\n    station.waitTime.synchronizeDispatchWith.length,\n  );\n  for (const id of station.waitTime.synchronizeDispatchWith) {\n    writeUnsignedInteger(stream, id);\n  }\n\n  writeDouble(stream, station.extraBlockLength);\n\n  writeUnsigned8(stream, station.brakeDevice.brakeType);\n  writeUnsigned8(stream, station.gateDirection);\n  writeUnsigned8(stream, station.display);\n  writeUnsigned8(stream, station.entranceStairs);\n  writeUnsigned8(stream, station.exitStairs);\n\n  writeNull(stream, 1);\n\n  writeColor(stream, station.gatesColor);\n  writeColor(stream, station.railingsColor);\n  writeColor(stream, station.structureColor);\n\n  writeNull(stream, 142);\n};\n",
    "functions": {},
    "types": {
      "StationSection": "type StationSection = ReturnType<typeof readStationSection>;"
    },
    "variables": {
      "readStationSection": "const readStationSection = (stream: NoLimitsStream) => {\n  const useTransportDevice = readBoolean(stream);\n\n  const transportTransportType = readUnsigned8(stream); // Transport::TransportType\n  const transportSpeed = readDouble(stream);\n  const transportAcceleration = readDouble(stream);\n  const transportDeceleration = readDouble(stream);\n\n  const brakeDeceleration = readDouble(stream);\n\n  const waitTimeAverage = readDouble(stream);\n  const waitTimeMinimum = readDouble(stream);\n  const waitTimeMaximum = readDouble(stream);\n  const waitTimeDeviation = readDouble(stream);\n\n  const transportLaunch = readBoolean(stream);\n  const transportLaunchAcceleration = readDouble(stream);\n  const transportLaunchMaxSpeed = readDouble(stream);\n\n  const unloadingOnly = readBoolean(stream);\n\n  readNull(stream, 3);\n\n  const passes = readUnsigned8(stream);\n  const shuttleBackwardsStart = readBoolean(stream);\n  const stationNumber = readUnsignedInteger(stream);\n\n  readNull(stream, 3);\n\n  const numSynchronizeDispatchWith = readUnsigned8(stream);\n  const synchronizeDispatchWith: number[] = [];\n\n  for (let i = 0; i < numSynchronizeDispatchWith; i++) {\n    synchronizeDispatchWith.push(readUnsignedInteger(stream));\n  }\n\n  const extraBlockLength = readDouble(stream);\n\n  const brakeType = readUnsigned8(stream); // Brake::BrakeType\n  const gateDirection = readUnsigned8(stream); // Station::GateDirection\n  const display = readUnsigned8(stream); // Station::Display\n  const entranceStairs = readUnsigned8(stream); // Station::Stairs\n  const exitStairs = readUnsigned8(stream); // Station::Stairs\n\n  readNull(stream, 1);\n\n  const gatesColor = readColor(stream);\n  const railingsColor = readColor(stream);\n  const structureColor = readColor(stream);\n\n  readNull(stream, 142);\n\n  return {\n    useTransportDevice,\n    transportDevice: {\n      transportType: transportTransportType,\n      speed: transportSpeed,\n      acceleration: transportAcceleration,\n      deceleration: transportDeceleration,\n      launch: transportLaunch,\n      launchAcceleration: transportLaunchAcceleration,\n      launchMaxSpeed: transportLaunchMaxSpeed,\n    },\n    brakeDevice: {\n      deceleration: brakeDeceleration,\n      brakeType,\n    },\n    waitTime: {\n      average: waitTimeAverage,\n      minimum: waitTimeMinimum,\n      maximum: waitTimeMaximum,\n      deviation: waitTimeDeviation,\n      synchronizeDispatchWith,\n    },\n    unloadingOnly,\n    passes,\n    shuttleBackwardsStart,\n    stationNumber,\n    extraBlockLength,\n    gateDirection,\n    display,\n    entranceStairs,\n    exitStairs,\n    gatesColor,\n    railingsColor,\n    structureColor,\n  };\n};",
      "writeStationSection": "const writeStationSection = (\n  stream: NoLimitsStream,\n  station: StationSection,\n): void => {\n  writeBoolean(stream, station.useTransportDevice);\n\n  writeUnsigned8(stream, station.transportDevice.transportType);\n  writeDouble(stream, station.transportDevice.speed);\n  writeDouble(stream, station.transportDevice.acceleration);\n  writeDouble(stream, station.transportDevice.deceleration);\n\n  writeDouble(stream, station.brakeDevice.deceleration);\n\n  writeDouble(stream, station.waitTime.average);\n  writeDouble(stream, station.waitTime.minimum);\n  writeDouble(stream, station.waitTime.maximum);\n  writeDouble(stream, station.waitTime.deviation);\n\n  writeBoolean(stream, station.transportDevice.launch);\n  writeDouble(stream, station.transportDevice.launchAcceleration);\n  writeDouble(stream, station.transportDevice.launchMaxSpeed);\n\n  writeBoolean(stream, station.unloadingOnly);\n\n  writeNull(stream, 3);\n\n  writeUnsigned8(stream, station.passes);\n  writeBoolean(stream, station.shuttleBackwardsStart);\n  writeUnsignedInteger(stream, station.stationNumber);\n\n  writeNull(stream, 3);\n\n  writeUnsigned8(\n    stream,\n    station.waitTime.synchronizeDispatchWith.length,\n  );\n  for (const id of station.waitTime.synchronizeDispatchWith) {\n    writeUnsignedInteger(stream, id);\n  }\n\n  writeDouble(stream, station.extraBlockLength);\n\n  writeUnsigned8(stream, station.brakeDevice.brakeType);\n  writeUnsigned8(stream, station.gateDirection);\n  writeUnsigned8(stream, station.display);\n  writeUnsigned8(stream, station.entranceStairs);\n  writeUnsigned8(stream, station.exitStairs);\n\n  writeNull(stream, 1);\n\n  writeColor(stream, station.gatesColor);\n  writeColor(stream, station.railingsColor);\n  writeColor(stream, station.structureColor);\n\n  writeNull(stream, 142);\n};"
    }
  },
  "src/helper/nl2park/section/storage-section.ts": {
    "source": "import {\n  NoLimitsStream,\n  readBoolean,\n  readColor,\n  readNull,\n  readUnsigned8,\n  writeBoolean,\n  writeColor,\n  writeNull,\n  writeUnsigned8,\n} from '../nolimits-stream';\n\nexport type StorageSection = ReturnType<typeof readStorageSection>;\n\nexport const readStorageSection = (stream: NoLimitsStream) => {\n  const enableTransportDevice = readBoolean(stream);\n  const transportType = readUnsigned8(stream); // Transport::TransportType\n  const building = readUnsigned8(stream); // Storage::Building\n\n  const roofColor = readColor(stream);\n  const sideColor = readColor(stream);\n  const frameColor = readColor(stream);\n\n  readNull(stream, 20);\n\n  return {\n    enableTransportDevice,\n    transportType,\n    building,\n    roofColor,\n    sideColor,\n    frameColor,\n  };\n};\n\nexport const writeStorageSection = (\n  stream: NoLimitsStream,\n  storage: StorageSection,\n): void => {\n  writeBoolean(stream, storage.enableTransportDevice);\n  writeUnsigned8(stream, storage.transportType);\n  writeUnsigned8(stream, storage.building);\n\n  writeColor(stream, storage.roofColor);\n  writeColor(stream, storage.sideColor);\n  writeColor(stream, storage.frameColor);\n\n  writeNull(stream, 20);\n};\n",
    "functions": {},
    "types": {
      "StorageSection": "type StorageSection = ReturnType<typeof readStorageSection>;"
    },
    "variables": {
      "readStorageSection": "const readStorageSection = (stream: NoLimitsStream) => {\n  const enableTransportDevice = readBoolean(stream);\n  const transportType = readUnsigned8(stream); // Transport::TransportType\n  const building = readUnsigned8(stream); // Storage::Building\n\n  const roofColor = readColor(stream);\n  const sideColor = readColor(stream);\n  const frameColor = readColor(stream);\n\n  readNull(stream, 20);\n\n  return {\n    enableTransportDevice,\n    transportType,\n    building,\n    roofColor,\n    sideColor,\n    frameColor,\n  };\n};",
      "writeStorageSection": "const writeStorageSection = (\n  stream: NoLimitsStream,\n  storage: StorageSection,\n): void => {\n  writeBoolean(stream, storage.enableTransportDevice);\n  writeUnsigned8(stream, storage.transportType);\n  writeUnsigned8(stream, storage.building);\n\n  writeColor(stream, storage.roofColor);\n  writeColor(stream, storage.sideColor);\n  writeColor(stream, storage.frameColor);\n\n  writeNull(stream, 20);\n};"
    }
  },
  "src/helper/nl2park/section/transport-section.ts": {
    "source": "import {\n  NoLimitsStream,\n  readBoolean,\n  readDouble,\n  readNull,\n  readUnsigned8,\n  readUnsignedInteger,\n  writeBoolean,\n  writeDouble,\n  writeNull,\n  writeUnsigned8,\n  writeUnsignedInteger,\n} from '../nolimits-stream';\n\nexport type TransportSection = ReturnType<\n  typeof readTransportSection\n>;\n\nexport const readTransportSection = (stream: NoLimitsStream) => {\n  const transportType = readUnsigned8(stream); // Transport::TransportType\n  const speed = readDouble(stream);\n  const acceleration = readDouble(stream);\n  const deceleration = readDouble(stream);\n  const speedingUpPasses = readUnsignedInteger(stream);\n  const speedingDown = readBoolean(stream);\n  const minSpeed = readDouble(stream);\n\n  readNull(stream, 26);\n\n  return {\n    transportType,\n    speed,\n    acceleration,\n    deceleration,\n    speedingUpPasses,\n    speedingDown,\n    minSpeed,\n  };\n};\n\nexport const writeTransportSection = (\n  stream: NoLimitsStream,\n  transport: TransportSection,\n): void => {\n  writeUnsigned8(stream, transport.transportType);\n  writeDouble(stream, transport.speed);\n  writeDouble(stream, transport.acceleration);\n  writeDouble(stream, transport.deceleration);\n  writeUnsignedInteger(stream, transport.speedingUpPasses);\n  writeBoolean(stream, transport.speedingDown);\n  writeDouble(stream, transport.minSpeed);\n\n  writeNull(stream, 26);\n};\n",
    "functions": {},
    "types": {
      "TransportSection": "type TransportSection = ReturnType<\n  typeof readTransportSection\n>;"
    },
    "variables": {
      "readTransportSection": "const readTransportSection = (stream: NoLimitsStream) => {\n  const transportType = readUnsigned8(stream); // Transport::TransportType\n  const speed = readDouble(stream);\n  const acceleration = readDouble(stream);\n  const deceleration = readDouble(stream);\n  const speedingUpPasses = readUnsignedInteger(stream);\n  const speedingDown = readBoolean(stream);\n  const minSpeed = readDouble(stream);\n\n  readNull(stream, 26);\n\n  return {\n    transportType,\n    speed,\n    acceleration,\n    deceleration,\n    speedingUpPasses,\n    speedingDown,\n    minSpeed,\n  };\n};",
      "writeTransportSection": "const writeTransportSection = (\n  stream: NoLimitsStream,\n  transport: TransportSection,\n): void => {\n  writeUnsigned8(stream, transport.transportType);\n  writeDouble(stream, transport.speed);\n  writeDouble(stream, transport.acceleration);\n  writeDouble(stream, transport.deceleration);\n  writeUnsignedInteger(stream, transport.speedingUpPasses);\n  writeBoolean(stream, transport.speedingDown);\n  writeDouble(stream, transport.minSpeed);\n\n  writeNull(stream, 26);\n};"
    }
  },
  "src/helper/nl2park/track/custom-track.ts": {
    "source": "import { sortBy } from 'lodash';\n\nimport {\n  makeChunkReader,\n  NoLimitsStream,\n  readBoolean,\n  readChunks,\n  readDouble,\n  readDoubleVector4,\n  readInteger,\n  readNull,\n  writeBoolean,\n  writeChunk,\n  writeDouble,\n  writeDoubleVector4,\n  writeNull,\n  writeUnsignedInteger,\n} from '../nolimits-stream';\nimport {\n  readSection,\n  Section,\n  writeSection,\n} from '../section/section';\nimport {\n  Parameter4dPoint,\n  readParameter4DPoint,\n  writeParameter4DPoint,\n} from './parameter-4d-point';\nimport {\n  readRollPoint,\n  RollPoint,\n  writeRollPoint,\n} from './roll-point';\nimport { readSegment, Segment, writeSegment } from './segment';\nimport {\n  readSeparatorPoint,\n  writeSeparatorPoint,\n} from './separator-point';\nimport {\n  readTriggerPoint,\n  TriggerPoint,\n  writeTriggerPoint,\n} from './trigger-point';\nimport { Vertex } from './vertex';\n\nexport type TrackPoint =\n  | RollPoint\n  | TriggerPoint\n  | ReturnType<typeof readSeparatorPoint>\n  | Parameter4dPoint\n  | { pointType: 'none'; position: number };\n\nexport type CustomTrack = ReturnType<typeof readCustomTrack>;\n\nexport const readCustomTrack = (stream: NoLimitsStream) => {\n  const closed = readBoolean(stream);\n  const startRoll = {\n    roll: readDouble(stream),\n    vertical: readBoolean(stream),\n  };\n  const endRoll = {\n    roll: readDouble(stream),\n    vertical: readBoolean(stream),\n  };\n\n  readNull(stream, 53);\n\n  const numberOfControlPoints = readInteger(stream);\n\n  let points: Array<TrackPoint> = [];\n\n  let segment: Segment | undefined;\n  let section: Section | undefined;\n  const vertices: Array<Vertex> = [];\n\n  for (let i = 0; i < numberOfControlPoints; i++) {\n    vertices.push({\n      position: readDoubleVector4(stream),\n      locked: readBoolean(stream),\n      strict: readBoolean(stream),\n    });\n    readNull(stream, 22);\n  }\n\n  readNull(stream, 60);\n\n  readChunks(\n    [\n      makeChunkReader(readRollPoint, 'ROLL', (r) => points.push(r)),\n      makeChunkReader(readTriggerPoint, 'TTRG', (t) =>\n        points.push(t),\n      ),\n      makeChunkReader(readSeparatorPoint, 'SEPA', (s) =>\n        points.push(s),\n      ),\n      makeChunkReader(readParameter4DPoint, '4DPM', (p) =>\n        points.push(p),\n      ),\n      makeChunkReader(readSegment, 'SEGM', (s) => (segment = s)),\n      makeChunkReader(readSection, 'SECT', (s) => (section = s)),\n    ],\n    stream,\n  );\n\n  return {\n    closed,\n    vertices,\n    segment,\n    section,\n    points,\n    startRoll,\n    endRoll,\n  };\n};\n\nexport const writeCustomTrack = (\n  stream: NoLimitsStream,\n  track: CustomTrack,\n): void => {\n  writeBoolean(stream, track.closed);\n\n  writeDouble(stream, track.startRoll.roll);\n  writeBoolean(stream, track.startRoll.vertical);\n\n  writeDouble(stream, track.endRoll.roll);\n  writeBoolean(stream, track.endRoll.vertical);\n\n  writeNull(stream, 53);\n\n  writeUnsignedInteger(stream, track.vertices.length);\n\n  for (const v of track.vertices) {\n    writeDoubleVector4(stream, v.position);\n    writeBoolean(stream, v.locked);\n    writeBoolean(stream, v.strict);\n    writeNull(stream, 22);\n  }\n\n  writeNull(stream, 60);\n\n  for (const p of sortBy(track.points, 'pointType')) {\n    switch (p.pointType) {\n      case 'roll':\n        writeChunk(stream, 'ROLL', (s) => writeRollPoint(s, p));\n        break;\n\n      case 'trigger':\n        writeChunk(stream, 'TTRG', (s) => writeTriggerPoint(s, p));\n        break;\n\n      case 'separator':\n        writeChunk(stream, 'SEPA', (s) => writeSeparatorPoint(s, p));\n        break;\n\n      case 'parameter4D':\n        writeChunk(stream, '4DPM', (s) =>\n          writeParameter4DPoint(s, p),\n        );\n        break;\n    }\n  }\n\n  writeChunk(stream, 'SEGM', (s) => {\n    if (!track.segment) return;\n    writeSegment(s, track.segment);\n  });\n\n  writeChunk(stream, 'SECT', (s) => {\n    if (!track.section) return;\n    writeSection(s, track.section);\n  });\n};\n",
    "functions": {},
    "types": {
      "TrackPoint": "type TrackPoint =\n  | RollPoint\n  | TriggerPoint\n  | ReturnType<typeof readSeparatorPoint>\n  | Parameter4dPoint\n  | { pointType: 'none'; position: number };",
      "CustomTrack": "type CustomTrack = ReturnType<typeof readCustomTrack>;"
    },
    "variables": {
      "readCustomTrack": "const readCustomTrack = (stream: NoLimitsStream) => {\n  const closed = readBoolean(stream);\n  const startRoll = {\n    roll: readDouble(stream),\n    vertical: readBoolean(stream),\n  };\n  const endRoll = {\n    roll: readDouble(stream),\n    vertical: readBoolean(stream),\n  };\n\n  readNull(stream, 53);\n\n  const numberOfControlPoints = readInteger(stream);\n\n  let points: Array<TrackPoint> = [];\n\n  let segment: Segment | undefined;\n  let section: Section | undefined;\n  const vertices: Array<Vertex> = [];\n\n  for (let i = 0; i < numberOfControlPoints; i++) {\n    vertices.push({\n      position: readDoubleVector4(stream),\n      locked: readBoolean(stream),\n      strict: readBoolean(stream),\n    });\n    readNull(stream, 22);\n  }\n\n  readNull(stream, 60);\n\n  readChunks(\n    [\n      makeChunkReader(readRollPoint, 'ROLL', (r) => points.push(r)),\n      makeChunkReader(readTriggerPoint, 'TTRG', (t) =>\n        points.push(t),\n      ),\n      makeChunkReader(readSeparatorPoint, 'SEPA', (s) =>\n        points.push(s),\n      ),\n      makeChunkReader(readParameter4DPoint, '4DPM', (p) =>\n        points.push(p),\n      ),\n      makeChunkReader(readSegment, 'SEGM', (s) => (segment = s)),\n      makeChunkReader(readSection, 'SECT', (s) => (section = s)),\n    ],\n    stream,\n  );\n\n  return {\n    closed,\n    vertices,\n    segment,\n    section,\n    points,\n    startRoll,\n    endRoll,\n  };\n};",
      "writeCustomTrack": "const writeCustomTrack = (\n  stream: NoLimitsStream,\n  track: CustomTrack,\n): void => {\n  writeBoolean(stream, track.closed);\n\n  writeDouble(stream, track.startRoll.roll);\n  writeBoolean(stream, track.startRoll.vertical);\n\n  writeDouble(stream, track.endRoll.roll);\n  writeBoolean(stream, track.endRoll.vertical);\n\n  writeNull(stream, 53);\n\n  writeUnsignedInteger(stream, track.vertices.length);\n\n  for (const v of track.vertices) {\n    writeDoubleVector4(stream, v.position);\n    writeBoolean(stream, v.locked);\n    writeBoolean(stream, v.strict);\n    writeNull(stream, 22);\n  }\n\n  writeNull(stream, 60);\n\n  for (const p of sortBy(track.points, 'pointType')) {\n    switch (p.pointType) {\n      case 'roll':\n        writeChunk(stream, 'ROLL', (s) => writeRollPoint(s, p));\n        break;\n\n      case 'trigger':\n        writeChunk(stream, 'TTRG', (s) => writeTriggerPoint(s, p));\n        break;\n\n      case 'separator':\n        writeChunk(stream, 'SEPA', (s) => writeSeparatorPoint(s, p));\n        break;\n\n      case 'parameter4D':\n        writeChunk(stream, '4DPM', (s) =>\n          writeParameter4DPoint(s, p),\n        );\n        break;\n    }\n  }\n\n  writeChunk(stream, 'SEGM', (s) => {\n    if (!track.segment) return;\n    writeSegment(s, track.segment);\n  });\n\n  writeChunk(stream, 'SECT', (s) => {\n    if (!track.section) return;\n    writeSection(s, track.section);\n  });\n};"
    }
  },
  "src/helper/nl2park/track/parameter-4d-point.ts": {
    "source": "import {\n  NoLimitsStream,\n  readDouble,\n  readNull,\n  writeDouble,\n  writeNull,\n} from '../nolimits-stream';\n\nexport type Parameter4dPoint = ReturnType<\n  typeof readParameter4DPoint\n>;\n\nexport const readParameter4DPoint = (stream: NoLimitsStream) => {\n  const position = readDouble(stream);\n  const angle = readDouble(stream);\n\n  readNull(stream, 20);\n\n  return {\n    pointType: 'parameter4D' as const,\n    position,\n    angle,\n  };\n};\n\nexport const writeParameter4DPoint = (\n  stream: NoLimitsStream,\n  parameter: Parameter4dPoint,\n): void => {\n  writeDouble(stream, parameter.position);\n  writeDouble(stream, parameter.angle);\n\n  writeNull(stream, 20);\n};\n",
    "functions": {},
    "types": {
      "Parameter4dPoint": "type Parameter4dPoint = ReturnType<\n  typeof readParameter4DPoint\n>;"
    },
    "variables": {
      "readParameter4DPoint": "const readParameter4DPoint = (stream: NoLimitsStream) => {\n  const position = readDouble(stream);\n  const angle = readDouble(stream);\n\n  readNull(stream, 20);\n\n  return {\n    pointType: 'parameter4D' as const,\n    position,\n    angle,\n  };\n};",
      "writeParameter4DPoint": "const writeParameter4DPoint = (\n  stream: NoLimitsStream,\n  parameter: Parameter4dPoint,\n): void => {\n  writeDouble(stream, parameter.position);\n  writeDouble(stream, parameter.angle);\n\n  writeNull(stream, 20);\n};"
    }
  },
  "src/helper/nl2park/track/roll-point.ts": {
    "source": "import {\n  NoLimitsStream,\n  readBoolean,\n  readDouble,\n  writeBoolean,\n  writeDouble,\n} from '../nolimits-stream';\nimport { TrackPoint } from './custom-track';\n\nexport type RollPoint = ReturnType<typeof readRollPoint>;\n\nexport const readRollPoint = (stream: NoLimitsStream) => {\n  return {\n    pointType: 'roll' as const,\n    position: readDouble(stream),\n    roll: readDouble(stream),\n    vertical: readBoolean(stream),\n    strict: readBoolean(stream),\n  };\n};\n\nexport const writeRollPoint = (\n  stream: NoLimitsStream,\n  point: RollPoint,\n): void => {\n  writeDouble(stream, point.position);\n  writeDouble(stream, point.roll);\n  writeBoolean(stream, point.vertical);\n  writeBoolean(stream, point.strict);\n};\n\nexport const isRollPoint = (p: TrackPoint): p is RollPoint => {\n  return p.pointType === 'roll';\n};\n",
    "functions": {},
    "types": {
      "RollPoint": "type RollPoint = ReturnType<typeof readRollPoint>;"
    },
    "variables": {
      "readRollPoint": "const readRollPoint = (stream: NoLimitsStream) => {\n  return {\n    pointType: 'roll' as const,\n    position: readDouble(stream),\n    roll: readDouble(stream),\n    vertical: readBoolean(stream),\n    strict: readBoolean(stream),\n  };\n};",
      "writeRollPoint": "const writeRollPoint = (\n  stream: NoLimitsStream,\n  point: RollPoint,\n): void => {\n  writeDouble(stream, point.position);\n  writeDouble(stream, point.roll);\n  writeBoolean(stream, point.vertical);\n  writeBoolean(stream, point.strict);\n};",
      "isRollPoint": "const isRollPoint = (p: TrackPoint): p is RollPoint => {\n  return p.pointType === 'roll';\n};"
    }
  },
  "src/helper/nl2park/track/segment.ts": {
    "source": "import {\n  NoLimitsStream,\n  readBoolean,\n  readColor,\n  readNull,\n  readUnsigned8,\n  writeBoolean,\n  writeColor,\n  writeNull,\n  writeUnsigned8,\n} from '../nolimits-stream';\n\nexport enum Tunnel {\n  None = 0,\n  Steel = 1,\n  Wooden = 2,\n  RoundConcrete = 3,\n  RectangularConcrete = 4,\n  Virtual = 5,\n}\n\nexport enum TieSpacing {\n  LowestStress = 0,\n  LowerStress = 1,\n  LowStress = 2,\n  Normal = 3,\n  HighStress = 4,\n  HighestStress = 5,\n}\n\nexport type Segment = ReturnType<typeof readSegment>;\n\nexport const readSegment = (stream: NoLimitsStream) => {\n  const useMainSpineColor = readBoolean(stream);\n  const railColor = readColor(stream);\n  const crossTiesColor = readColor(stream);\n  const mainSpineColor = readColor(stream);\n\n  const tunnel = readUnsigned8(stream) as Tunnel;\n\n  const leftRailingAndCatwalk = readBoolean(stream);\n  const rightRailingAndCatwalk = readBoolean(stream);\n\n  const spineType = readUnsigned8(stream);\n  const spineColorScheme = readUnsigned8(stream);\n  const invisibleSegment = readBoolean(stream);\n\n  readNull(stream, 2);\n\n  const woodenSupportFlag1 = readUnsigned8(stream);\n  const woodenSupportFlag2 = readUnsigned8(stream);\n\n  const handrailsColor = readColor(stream);\n  const catwalksColor = readColor(stream);\n\n  const transparentCatwalks = readBoolean(stream);\n  const useRailsColor = readBoolean(stream);\n  const useCrossTiesColor = readBoolean(stream);\n  const useHandrailsColor = readBoolean(stream);\n  const useCatwalksColor = readBoolean(stream);\n  const useSpineColorScheme = readBoolean(stream);\n\n  const leftRailingLights = readBoolean(stream);\n  const leftRailingLightsColor = readColor(stream);\n\n  const rightRailingLights = readBoolean(stream);\n  const rightRailingLightsColor = readColor(stream);\n\n  readNull(stream, 45);\n\n  return {\n    useMainSpineColor,\n    railColor,\n    crossTiesColor,\n    mainSpineColor,\n    tunnel,\n    leftRailingAndCatwalk,\n    rightRailingAndCatwalk,\n    spineType,\n    spineColorScheme,\n    invisibleSegment,\n    woodenSupport: {\n      flag1: woodenSupportFlag1,\n      flag2: woodenSupportFlag2,\n    },\n    handrailsColor,\n    catwalksColor,\n    transparentCatwalks,\n    useRailsColor,\n    useCrossTiesColor,\n    useHandrailsColor,\n    useCatwalksColor,\n    useSpineColorScheme,\n    leftRailingLights,\n    leftRailingLightsColor,\n    rightRailingLights,\n    rightRailingLightsColor,\n  };\n};\n\nexport const writeSegment = (\n  stream: NoLimitsStream,\n  segment: Segment,\n): void => {\n  writeBoolean(stream, segment.useMainSpineColor);\n  writeColor(stream, segment.railColor);\n  writeColor(stream, segment.crossTiesColor);\n  writeColor(stream, segment.mainSpineColor);\n\n  writeUnsigned8(stream, segment.tunnel);\n\n  writeBoolean(stream, segment.leftRailingAndCatwalk);\n  writeBoolean(stream, segment.rightRailingAndCatwalk);\n\n  writeUnsigned8(stream, segment.spineType);\n  writeUnsigned8(stream, segment.spineColorScheme);\n  writeBoolean(stream, segment.invisibleSegment);\n\n  writeNull(stream, 2);\n\n  writeUnsigned8(stream, segment.woodenSupport.flag1);\n  writeUnsigned8(stream, segment.woodenSupport.flag2);\n\n  writeColor(stream, segment.handrailsColor);\n  writeColor(stream, segment.catwalksColor);\n\n  writeBoolean(stream, segment.transparentCatwalks);\n  writeBoolean(stream, segment.useRailsColor);\n  writeBoolean(stream, segment.useCrossTiesColor);\n  writeBoolean(stream, segment.useHandrailsColor);\n  writeBoolean(stream, segment.useCatwalksColor);\n  writeBoolean(stream, segment.useSpineColorScheme);\n\n  writeBoolean(stream, segment.leftRailingLights);\n  writeColor(stream, segment.leftRailingLightsColor);\n\n  writeBoolean(stream, segment.rightRailingLights);\n  writeColor(stream, segment.rightRailingLightsColor);\n\n  writeNull(stream, 45);\n};\n",
    "functions": {},
    "types": {
      "Segment": "type Segment = ReturnType<typeof readSegment>;"
    },
    "variables": {
      "readSegment": "const readSegment = (stream: NoLimitsStream) => {\n  const useMainSpineColor = readBoolean(stream);\n  const railColor = readColor(stream);\n  const crossTiesColor = readColor(stream);\n  const mainSpineColor = readColor(stream);\n\n  const tunnel = readUnsigned8(stream) as Tunnel;\n\n  const leftRailingAndCatwalk = readBoolean(stream);\n  const rightRailingAndCatwalk = readBoolean(stream);\n\n  const spineType = readUnsigned8(stream);\n  const spineColorScheme = readUnsigned8(stream);\n  const invisibleSegment = readBoolean(stream);\n\n  readNull(stream, 2);\n\n  const woodenSupportFlag1 = readUnsigned8(stream);\n  const woodenSupportFlag2 = readUnsigned8(stream);\n\n  const handrailsColor = readColor(stream);\n  const catwalksColor = readColor(stream);\n\n  const transparentCatwalks = readBoolean(stream);\n  const useRailsColor = readBoolean(stream);\n  const useCrossTiesColor = readBoolean(stream);\n  const useHandrailsColor = readBoolean(stream);\n  const useCatwalksColor = readBoolean(stream);\n  const useSpineColorScheme = readBoolean(stream);\n\n  const leftRailingLights = readBoolean(stream);\n  const leftRailingLightsColor = readColor(stream);\n\n  const rightRailingLights = readBoolean(stream);\n  const rightRailingLightsColor = readColor(stream);\n\n  readNull(stream, 45);\n\n  return {\n    useMainSpineColor,\n    railColor,\n    crossTiesColor,\n    mainSpineColor,\n    tunnel,\n    leftRailingAndCatwalk,\n    rightRailingAndCatwalk,\n    spineType,\n    spineColorScheme,\n    invisibleSegment,\n    woodenSupport: {\n      flag1: woodenSupportFlag1,\n      flag2: woodenSupportFlag2,\n    },\n    handrailsColor,\n    catwalksColor,\n    transparentCatwalks,\n    useRailsColor,\n    useCrossTiesColor,\n    useHandrailsColor,\n    useCatwalksColor,\n    useSpineColorScheme,\n    leftRailingLights,\n    leftRailingLightsColor,\n    rightRailingLights,\n    rightRailingLightsColor,\n  };\n};",
      "writeSegment": "const writeSegment = (\n  stream: NoLimitsStream,\n  segment: Segment,\n): void => {\n  writeBoolean(stream, segment.useMainSpineColor);\n  writeColor(stream, segment.railColor);\n  writeColor(stream, segment.crossTiesColor);\n  writeColor(stream, segment.mainSpineColor);\n\n  writeUnsigned8(stream, segment.tunnel);\n\n  writeBoolean(stream, segment.leftRailingAndCatwalk);\n  writeBoolean(stream, segment.rightRailingAndCatwalk);\n\n  writeUnsigned8(stream, segment.spineType);\n  writeUnsigned8(stream, segment.spineColorScheme);\n  writeBoolean(stream, segment.invisibleSegment);\n\n  writeNull(stream, 2);\n\n  writeUnsigned8(stream, segment.woodenSupport.flag1);\n  writeUnsigned8(stream, segment.woodenSupport.flag2);\n\n  writeColor(stream, segment.handrailsColor);\n  writeColor(stream, segment.catwalksColor);\n\n  writeBoolean(stream, segment.transparentCatwalks);\n  writeBoolean(stream, segment.useRailsColor);\n  writeBoolean(stream, segment.useCrossTiesColor);\n  writeBoolean(stream, segment.useHandrailsColor);\n  writeBoolean(stream, segment.useCatwalksColor);\n  writeBoolean(stream, segment.useSpineColorScheme);\n\n  writeBoolean(stream, segment.leftRailingLights);\n  writeColor(stream, segment.leftRailingLightsColor);\n\n  writeBoolean(stream, segment.rightRailingLights);\n  writeColor(stream, segment.rightRailingLightsColor);\n\n  writeNull(stream, 45);\n};"
    }
  },
  "src/helper/nl2park/track/separator-point.ts": {
    "source": "import {\n  makeChunkReader,\n  NoLimitsStream,\n  readChunks,\n  readDouble,\n  writeChunk,\n  writeDouble,\n} from '../nolimits-stream';\nimport {\n  readSection,\n  Section,\n  writeSection,\n} from '../section/section';\nimport { TrackPoint } from './custom-track';\nimport { readSegment, Segment, writeSegment } from './segment';\n\nexport type SeparatorPoint = ReturnType<typeof readSeparatorPoint>;\n\nexport const readSeparatorPoint = (stream: NoLimitsStream) => {\n  const position = readDouble(stream);\n\n  let segment: Segment | undefined;\n  let section: Section | undefined;\n\n  readChunks(\n    [\n      makeChunkReader(readSegment, 'SEGM', (s) => {\n        segment = s;\n      }),\n      makeChunkReader(readSection, 'SECT', (s) => (section = s)),\n    ],\n    stream,\n  );\n\n  return {\n    pointType: 'separator' as const,\n    position,\n    segment,\n    section,\n  };\n};\n\nexport const writeSeparatorPoint = (\n  stream: NoLimitsStream,\n  separator: SeparatorPoint,\n): void => {\n  writeDouble(stream, separator.position);\n\n  writeChunk(stream, 'SEGM', (s) => {\n    if (!separator.segment) return;\n    writeSegment(s, separator.segment);\n  });\n\n  writeChunk(stream, 'SECT', (s) => {\n    if (!separator.section) return;\n    writeSection(s, separator.section);\n  });\n};\n\nexport const isSeparatorPoint = (\n  p: TrackPoint,\n): p is SeparatorPoint => {\n  return p.pointType === 'separator';\n};\n",
    "functions": {},
    "types": {
      "SeparatorPoint": "type SeparatorPoint = ReturnType<typeof readSeparatorPoint>;"
    },
    "variables": {
      "readSeparatorPoint": "const readSeparatorPoint = (stream: NoLimitsStream) => {\n  const position = readDouble(stream);\n\n  let segment: Segment | undefined;\n  let section: Section | undefined;\n\n  readChunks(\n    [\n      makeChunkReader(readSegment, 'SEGM', (s) => {\n        segment = s;\n      }),\n      makeChunkReader(readSection, 'SECT', (s) => (section = s)),\n    ],\n    stream,\n  );\n\n  return {\n    pointType: 'separator' as const,\n    position,\n    segment,\n    section,\n  };\n};",
      "writeSeparatorPoint": "const writeSeparatorPoint = (\n  stream: NoLimitsStream,\n  separator: SeparatorPoint,\n): void => {\n  writeDouble(stream, separator.position);\n\n  writeChunk(stream, 'SEGM', (s) => {\n    if (!separator.segment) return;\n    writeSegment(s, separator.segment);\n  });\n\n  writeChunk(stream, 'SECT', (s) => {\n    if (!separator.section) return;\n    writeSection(s, separator.section);\n  });\n};",
      "isSeparatorPoint": "const isSeparatorPoint = (\n  p: TrackPoint,\n): p is SeparatorPoint => {\n  return p.pointType === 'separator';\n};"
    }
  },
  "src/helper/nl2park/track/trigger-point.ts": {
    "source": "import {\n  NoLimitsStream,\n  readDouble,\n  readNull,\n  readString,\n  readUnsigned8,\n  writeDouble,\n  writeNull,\n  writeString,\n  writeUnsigned8,\n} from '../nolimits-stream';\n\nexport enum TriggerTrainEvent {\n  None = 0,\n  UnlockSpinning = 1,\n  LockSpinning = 2,\n  UnlockSwinging = 3,\n  LockSwinging = 4,\n}\n\nexport type TriggerPoint = ReturnType<typeof readTriggerPoint>;\n\nexport const readTriggerPoint = (stream: NoLimitsStream) => {\n  const position = readDouble(stream);\n  const name = readString(stream);\n\n  readNull(stream, 3);\n\n  const trainEvent = readUnsigned8(stream) as TriggerTrainEvent;\n\n  readNull(stream, 26);\n\n  return {\n    pointType: 'trigger' as const,\n    position,\n    name,\n    trainEvent,\n  };\n};\n\nexport const writeTriggerPoint = (\n  stream: NoLimitsStream,\n  trigger: TriggerPoint,\n): void => {\n  writeDouble(stream, trigger.position);\n  writeString(stream, trigger.name);\n  writeNull(stream, 3);\n  writeUnsigned8(stream, trigger.trainEvent);\n  writeNull(stream, 26);\n};\n",
    "functions": {},
    "types": {
      "TriggerPoint": "type TriggerPoint = ReturnType<typeof readTriggerPoint>;"
    },
    "variables": {
      "readTriggerPoint": "const readTriggerPoint = (stream: NoLimitsStream) => {\n  const position = readDouble(stream);\n  const name = readString(stream);\n\n  readNull(stream, 3);\n\n  const trainEvent = readUnsigned8(stream) as TriggerTrainEvent;\n\n  readNull(stream, 26);\n\n  return {\n    pointType: 'trigger' as const,\n    position,\n    name,\n    trainEvent,\n  };\n};",
      "writeTriggerPoint": "const writeTriggerPoint = (\n  stream: NoLimitsStream,\n  trigger: TriggerPoint,\n): void => {\n  writeDouble(stream, trigger.position);\n  writeString(stream, trigger.name);\n  writeNull(stream, 3);\n  writeUnsigned8(stream, trigger.trainEvent);\n  writeNull(stream, 26);\n};"
    }
  },
  "src/helper/nl2park/track/vertex.ts": {
    "source": "import {\n  NoLimitsStream,\n  readBoolean,\n  readDoubleVector4,\n  readNull,\n  writeBoolean,\n  writeDoubleVector4,\n  writeNull,\n} from '../nolimits-stream';\n\nexport type Vertex = ReturnType<typeof readVertex>;\n\nexport const readVertex = (stream: NoLimitsStream) => {\n  const vertex = {\n    position: readDoubleVector4(stream),\n    locked: readBoolean(stream),\n    strict: readBoolean(stream),\n  };\n  readNull(stream, 22);\n  return vertex;\n};\n\nexport const writeVertex = (\n  stream: NoLimitsStream,\n  vertex: Vertex,\n): void => {\n  writeDoubleVector4(stream, vertex.position);\n  writeBoolean(stream, vertex.locked);\n  writeBoolean(stream, vertex.strict);\n  writeNull(stream, 22);\n};\n",
    "functions": {},
    "types": {
      "Vertex": "type Vertex = ReturnType<typeof readVertex>;"
    },
    "variables": {
      "readVertex": "const readVertex = (stream: NoLimitsStream) => {\n  const vertex = {\n    position: readDoubleVector4(stream),\n    locked: readBoolean(stream),\n    strict: readBoolean(stream),\n  };\n  readNull(stream, 22);\n  return vertex;\n};",
      "writeVertex": "const writeVertex = (\n  stream: NoLimitsStream,\n  vertex: Vertex,\n): void => {\n  writeDoubleVector4(stream, vertex.position);\n  writeBoolean(stream, vertex.locked);\n  writeBoolean(stream, vertex.strict);\n  writeNull(stream, 22);\n};"
    }
  },
  "src/content/posts/roller-coaster-simulation/nurbs-roll-physics-in-action/NurbsRollPhysicsInActionDemoScene.tsx": {
    "source": "import React from 'react';\nimport { Stats } from '@react-three/drei';\nimport { Vector3 } from 'three';\n\nimport { toLocalTransformed } from '../../../../maths/curve';\nimport { fromURL } from '../../../../helper/nl2park/nl2park';\nimport { curveFromCustomTrack } from '../../../../helper/nolimits';\n\nimport { CurveTrackMesh } from '../../../../components/curve/CurveTrackMesh';\nimport { Ground } from '../../../../components/Ground';\nimport { PerspectiveScene } from '../../../../components/scenes/PerspectiveScene';\nimport { TrainWithPhysics } from '../../../../components/TrainWithPhysics';\n\nimport Park from './Example.nl2park';\n\nconst exampleCoaster = (await fromURL(Park)).coaster[0];\nconst exampleTrack = exampleCoaster?.tracks[2];\n\nconst exampleTrackCurve = toLocalTransformed(\n  curveFromCustomTrack(exampleTrack),\n  new Vector3(0, -1.2, 0),\n);\n\nexport const NurbsRollPhysicsInActionDemoScene = () => {\n  return (\n    <>\n      <PerspectiveScene>\n        <Stats />\n        <Ground position={[0, 0, 0]} />\n        <CurveTrackMesh curve={exampleTrackCurve} />\n        <TrainWithPhysics\n          curve={exampleTrackCurve}\n          sections={[\n            {\n              acceleration: 0.5 * 9.81665,\n              fromArcLength: 0,\n              toArcLength: 15.38,\n              maxVelocity: 8 / 3.6,\n            },\n            {\n              acceleration: 0.5 * 9.81665,\n              fromArcLength: 15.38,\n              toArcLength: 18.92,\n              maxVelocity: 9.654 / 3.6,\n            },\n            {\n              acceleration: 0.5 * 9.81665,\n              fromArcLength: 44.43,\n              toArcLength: 60.16,\n              maxVelocity: 12.872 / 3.6,\n            },\n            {\n              acceleration: 0.8 * 9.81665,\n              fromArcLength: 60.16,\n              toArcLength: 113.83,\n              maxVelocity: 85.277 / 3.6,\n            },\n            {\n              acceleration: -1 * 9.81665,\n              fromArcLength: 715.1,\n              toArcLength: 735.54,\n              minVelocity: 12.872 / 3.6,\n            },\n          ]}\n          init={{\n            velocity: 0,\n            distanceTraveled: 13,\n            friction: 0.026,\n            airResistance: 2e-5,\n          }}\n          activateCamera={true}\n          resetWhenReachedLimit={false}\n        />\n      </PerspectiveScene>\n    </>\n  );\n};\n",
    "functions": {},
    "types": {},
    "variables": {
      "exampleCoaster": "const exampleCoaster = (await fromURL(Park)).coaster[0];",
      "exampleTrack": "const exampleTrack = exampleCoaster?.tracks[2];",
      "exampleTrackCurve": "const exampleTrackCurve = toLocalTransformed(\n  curveFromCustomTrack(exampleTrack),\n  new Vector3(0, -1.2, 0),\n);",
      "NurbsRollPhysicsInActionDemoScene": "const NurbsRollPhysicsInActionDemoScene = () => {\n  return (\n    <>\n      <PerspectiveScene>\n        <Stats />\n        <Ground position={[0, 0, 0]} />\n        <CurveTrackMesh curve={exampleTrackCurve} />\n        <TrainWithPhysics\n          curve={exampleTrackCurve}\n          sections={[\n            {\n              acceleration: 0.5 * 9.81665,\n              fromArcLength: 0,\n              toArcLength: 15.38,\n              maxVelocity: 8 / 3.6,\n            },\n            {\n              acceleration: 0.5 * 9.81665,\n              fromArcLength: 15.38,\n              toArcLength: 18.92,\n              maxVelocity: 9.654 / 3.6,\n            },\n            {\n              acceleration: 0.5 * 9.81665,\n              fromArcLength: 44.43,\n              toArcLength: 60.16,\n              maxVelocity: 12.872 / 3.6,\n            },\n            {\n              acceleration: 0.8 * 9.81665,\n              fromArcLength: 60.16,\n              toArcLength: 113.83,\n              maxVelocity: 85.277 / 3.6,\n            },\n            {\n              acceleration: -1 * 9.81665,\n              fromArcLength: 715.1,\n              toArcLength: 735.54,\n              minVelocity: 12.872 / 3.6,\n            },\n          ]}\n          init={{\n            velocity: 0,\n            distanceTraveled: 13,\n            friction: 0.026,\n            airResistance: 2e-5,\n          }}\n          activateCamera={true}\n          resetWhenReachedLimit={false}\n        />\n      </PerspectiveScene>\n    </>\n  );\n};"
    }
  },
  "src/content/posts/wasi/implementing-library-functions/BezierNodesExampleScene.tsx": {
    "source": "import React, { useMemo, useState } from 'react';\nimport { Line } from '@react-three/drei';\nimport { useFrame } from '@react-three/fiber';\nimport { Easing, Group, Tween } from '@tweenjs/tween.js';\nimport { Vector3 } from 'three';\n\nimport { useColors } from '../../../../hooks/useColors';\n\nimport { BezierCurve } from '../../../../components/curve/BezierCurve';\nimport { DragControlPoints } from '../../../../components/curve/DragControlPoints';\nimport { OrthographicScene } from '../../../../components/scenes/OrthographicScene';\n\nconst Example = () => {\n  const colors = useColors();\n\n  const [points, setPoints] = useState([\n    new Vector3(0, 0, 0),\n    new Vector3(6, 0, 0),\n    new Vector3(0, 6, 0),\n    new Vector3(6, 6, 0),\n  ]);\n\n  const [motion, setMotion] = useState({\n    resolution: 0.5,\n    uniform: 0,\n  });\n\n  const group = useMemo(() => {\n    const group = new Group();\n\n    const animation = {\n      resolution: 0.5,\n      uniform: 0,\n    };\n\n    const denseBezierTween = new Tween(animation, group)\n      .to({ resolution: 2.5 }, 1000)\n      .easing(Easing.Linear.None)\n      .onUpdate(() => setMotion({ ...animation }));\n\n    const uniformBezierTween = new Tween(animation, group)\n      .delay(3000)\n      .to({ uniform: 1 }, 500)\n      .onUpdate(() => setMotion({ ...animation }));\n\n    const looseTween = new Tween(animation, group)\n      .delay(2000)\n      .to({ resolution: 0.5 }, 1000)\n      .onUpdate(() => setMotion({ ...animation }));\n\n    const resetTween = new Tween(animation, group)\n      .delay(1000)\n      .to({ uniform: 0 }, 500)\n      .onUpdate(() => setMotion({ ...animation }))\n      .onComplete(() => denseBezierTween.start());\n\n    denseBezierTween.chain(\n      uniformBezierTween.chain(looseTween.chain(resetTween)),\n    );\n\n    denseBezierTween.start();\n\n    return group;\n  }, []);\n\n  useFrame((state) => {\n    group.update(state.clock.getElapsedTime() * 1000);\n  });\n\n  return (\n    <group position={[-3, -2, 0]}>\n      <Line\n        points={points}\n        color={colors.highlight}\n        segments={true}\n      />\n      <DragControlPoints\n        axisLock=\"z\"\n        points={points}\n        setPoints={setPoints}\n      />\n      <BezierCurve\n        points={points}\n        resolution={motion.resolution}\n        uniform={!!Math.round(motion.uniform)}\n        showNodes={true}\n      />\n    </group>\n  );\n};\n\nexport const BezierNodesExampleScene = () => {\n  return (\n    <OrthographicScene>\n      <Example />\n    </OrthographicScene>\n  );\n};\n",
    "functions": {},
    "types": {},
    "variables": {
      "Example": "const Example = () => {\n  const colors = useColors();\n\n  const [points, setPoints] = useState([\n    new Vector3(0, 0, 0),\n    new Vector3(6, 0, 0),\n    new Vector3(0, 6, 0),\n    new Vector3(6, 6, 0),\n  ]);\n\n  const [motion, setMotion] = useState({\n    resolution: 0.5,\n    uniform: 0,\n  });\n\n  const group = useMemo(() => {\n    const group = new Group();\n\n    const animation = {\n      resolution: 0.5,\n      uniform: 0,\n    };\n\n    const denseBezierTween = new Tween(animation, group)\n      .to({ resolution: 2.5 }, 1000)\n      .easing(Easing.Linear.None)\n      .onUpdate(() => setMotion({ ...animation }));\n\n    const uniformBezierTween = new Tween(animation, group)\n      .delay(3000)\n      .to({ uniform: 1 }, 500)\n      .onUpdate(() => setMotion({ ...animation }));\n\n    const looseTween = new Tween(animation, group)\n      .delay(2000)\n      .to({ resolution: 0.5 }, 1000)\n      .onUpdate(() => setMotion({ ...animation }));\n\n    const resetTween = new Tween(animation, group)\n      .delay(1000)\n      .to({ uniform: 0 }, 500)\n      .onUpdate(() => setMotion({ ...animation }))\n      .onComplete(() => denseBezierTween.start());\n\n    denseBezierTween.chain(\n      uniformBezierTween.chain(looseTween.chain(resetTween)),\n    );\n\n    denseBezierTween.start();\n\n    return group;\n  }, []);\n\n  useFrame((state) => {\n    group.update(state.clock.getElapsedTime() * 1000);\n  });\n\n  return (\n    <group position={[-3, -2, 0]}>\n      <Line\n        points={points}\n        color={colors.highlight}\n        segments={true}\n      />\n      <DragControlPoints\n        axisLock=\"z\"\n        points={points}\n        setPoints={setPoints}\n      />\n      <BezierCurve\n        points={points}\n        resolution={motion.resolution}\n        uniform={!!Math.round(motion.uniform)}\n        showNodes={true}\n      />\n    </group>\n  );\n};",
      "BezierNodesExampleScene": "const BezierNodesExampleScene = () => {\n  return (\n    <OrthographicScene>\n      <Example />\n    </OrthographicScene>\n  );\n};"
    }
  },
  "src/content/posts/wasi/javascript-module/WasiLibraryExampleScene.tsx": {
    "source": "import React, { useMemo } from 'react';\nimport { Line } from '@react-three/drei';\nimport { Vector3 } from 'three';\n\nimport { uniformSampleMap } from '../../../../helper/uniform-sample';\nimport { useColors } from '../../../../hooks/useColors';\n\nimport { DragControlPoints } from '../../../../components/curve/DragControlPoints';\nimport { OrthographicScene } from '../../../../components/scenes/OrthographicScene';\n\nimport {\n  bezierFromPoints,\n  bezierPositionAtArcLength,\n  bezierTotalArcLength,\n} from '../../../../libs/calculation';\n\nexport const WasiLibraryExampleScene = () => {\n  const colors = useColors();\n\n  const [points, setPoints] = React.useState([\n    new Vector3(-3, -3, 0),\n    new Vector3(3, -3, 0),\n    new Vector3(-3, 3, 0),\n    new Vector3(3, 3, 0),\n  ]);\n\n  const nodes = useMemo(() => {\n    const bezier = bezierFromPoints(\n      points[0].toArray(),\n      points[1].toArray(),\n      points[2].toArray(),\n      points[3].toArray(),\n    );\n\n    return uniformSampleMap(\n      0,\n      bezierTotalArcLength(bezier),\n      5,\n      (at) =>\n        new Vector3().fromArray(\n          bezierPositionAtArcLength(bezier, at),\n        ),\n    );\n  }, [points]);\n\n  return (\n    <OrthographicScene>\n      <DragControlPoints points={points} setPoints={setPoints} />\n      <Line\n        color={colors.highlight}\n        points={points}\n        segments={true}\n      />\n      <Line color={colors.secondary} points={nodes} />\n    </OrthographicScene>\n  );\n};\n",
    "functions": {},
    "types": {},
    "variables": {
      "WasiLibraryExampleScene": "const WasiLibraryExampleScene = () => {\n  const colors = useColors();\n\n  const [points, setPoints] = React.useState([\n    new Vector3(-3, -3, 0),\n    new Vector3(3, -3, 0),\n    new Vector3(-3, 3, 0),\n    new Vector3(3, 3, 0),\n  ]);\n\n  const nodes = useMemo(() => {\n    const bezier = bezierFromPoints(\n      points[0].toArray(),\n      points[1].toArray(),\n      points[2].toArray(),\n      points[3].toArray(),\n    );\n\n    return uniformSampleMap(\n      0,\n      bezierTotalArcLength(bezier),\n      5,\n      (at) =>\n        new Vector3().fromArray(\n          bezierPositionAtArcLength(bezier, at),\n        ),\n    );\n  }, [points]);\n\n  return (\n    <OrthographicScene>\n      <DragControlPoints points={points} setPoints={setPoints} />\n      <Line\n        color={colors.highlight}\n        points={points}\n        segments={true}\n      />\n      <Line color={colors.secondary} points={nodes} />\n    </OrthographicScene>\n  );\n};"
    }
  },
  "src/content/posts/writing-a-roller-coaster-simulation/b-spline-curve/BSplineCurveDemoScene.tsx": {
    "source": "import React, { useMemo, useState } from 'react';\nimport { Line } from '@react-three/drei';\nimport { useControls } from 'leva';\nimport { Vector3, Vector4 } from 'three';\n\nimport { useColors } from '../../../../hooks/useColors';\n\nimport { CurveTrackMesh } from '../../../../components/curve/CurveTrackMesh';\nimport { DragControlPoints } from '../../../../components/curve/DragControlPoints';\nimport { Ground } from '../../../../components/Ground';\nimport { EditorScene } from '../../../../components/scenes/EditorScene';\nimport { TrainWithPhysics } from '../../../../components/TrainWithPhysics';\n\nimport { fromPoints } from '../../../../coaster/b-spline-track';\n\nexport const BSplineCurveDemoScene = () => {\n  const colors = useColors();\n\n  const [{ closed }] = useControls(() => ({ closed: false }));\n\n  const [points, setPoints] = useState([\n    new Vector3(-10, 8, 0),\n    new Vector3(-6, -8, 0),\n    new Vector3(1, -6, 0),\n    new Vector3(6, -8, 0),\n    new Vector3(10, -7, 0),\n  ]);\n\n  const curve = useMemo(\n    () =>\n      fromPoints(\n        points.map((p) => new Vector4(p.x, p.y, p.z)),\n        closed,\n      ),\n    [points, closed],\n  );\n\n  return (\n    <EditorScene>\n      <Line points={points} color={colors.highlight} />\n      <DragControlPoints points={points} setPoints={setPoints} />\n      <Ground position={[0, -10, 0]} />\n      <CurveTrackMesh curve={curve} />\n      <TrainWithPhysics\n        curve={curve}\n        resetWhenReachedLimit={!closed}\n      />\n    </EditorScene>\n  );\n};\n",
    "functions": {},
    "types": {},
    "variables": {
      "BSplineCurveDemoScene": "const BSplineCurveDemoScene = () => {\n  const colors = useColors();\n\n  const [{ closed }] = useControls(() => ({ closed: false }));\n\n  const [points, setPoints] = useState([\n    new Vector3(-10, 8, 0),\n    new Vector3(-6, -8, 0),\n    new Vector3(1, -6, 0),\n    new Vector3(6, -8, 0),\n    new Vector3(10, -7, 0),\n  ]);\n\n  const curve = useMemo(\n    () =>\n      fromPoints(\n        points.map((p) => new Vector4(p.x, p.y, p.z)),\n        closed,\n      ),\n    [points, closed],\n  );\n\n  return (\n    <EditorScene>\n      <Line points={points} color={colors.highlight} />\n      <DragControlPoints points={points} setPoints={setPoints} />\n      <Ground position={[0, -10, 0]} />\n      <CurveTrackMesh curve={curve} />\n      <TrainWithPhysics\n        curve={curve}\n        resetWhenReachedLimit={!closed}\n      />\n    </EditorScene>\n  );\n};"
    }
  },
  "src/content/posts/writing-a-roller-coaster-simulation/bezier-curve/BezierCurveDemoScene.tsx": {
    "source": "import React, { useMemo, useState } from 'react';\nimport { Line } from '@react-three/drei';\nimport { Vector3 } from 'three';\n\nimport { bezierSplineCurve } from '../../../../maths/bezier';\nimport { useColors } from '../../../../hooks/useColors';\n\nimport { CurveTrackMesh } from '../../../../components/curve/CurveTrackMesh';\nimport { DragControlPoints } from '../../../../components/curve/DragControlPoints';\nimport { Ground } from '../../../../components/Ground';\nimport { EditorScene } from '../../../../components/scenes/EditorScene';\nimport { TrainWithPhysics } from '../../../../components/TrainWithPhysics';\n\nexport const BezierCurveDemoScene = () => {\n  const colors = useColors();\n\n  const [points, setPoints] = useState([\n    new Vector3(-11.3, 3.9, 0),\n    new Vector3(-6.6, 2.7, 0),\n    new Vector3(-5.8, -3.8, 0),\n    new Vector3(0, -2.4, 0),\n  ]);\n\n  const curve = useMemo(() => bezierSplineCurve(points), [points]);\n\n  return (\n    <EditorScene>\n      <Line\n        points={points}\n        color={colors.highlight}\n        segments={true}\n      />\n      <DragControlPoints\n        axisLock=\"z\"\n        points={points}\n        setPoints={setPoints}\n      />\n      <CurveTrackMesh curve={curve} />\n      <TrainWithPhysics curve={curve} />\n      <Ground position={[0, -5, 0]} />\n    </EditorScene>\n  );\n};\n",
    "functions": {},
    "types": {},
    "variables": {
      "BezierCurveDemoScene": "const BezierCurveDemoScene = () => {\n  const colors = useColors();\n\n  const [points, setPoints] = useState([\n    new Vector3(-11.3, 3.9, 0),\n    new Vector3(-6.6, 2.7, 0),\n    new Vector3(-5.8, -3.8, 0),\n    new Vector3(0, -2.4, 0),\n  ]);\n\n  const curve = useMemo(() => bezierSplineCurve(points), [points]);\n\n  return (\n    <EditorScene>\n      <Line\n        points={points}\n        color={colors.highlight}\n        segments={true}\n      />\n      <DragControlPoints\n        axisLock=\"z\"\n        points={points}\n        setPoints={setPoints}\n      />\n      <CurveTrackMesh curve={curve} />\n      <TrainWithPhysics curve={curve} />\n      <Ground position={[0, -5, 0]} />\n    </EditorScene>\n  );\n};"
    }
  },
  "src/content/posts/writing-a-roller-coaster-simulation/bezier-curve/BezierCurveExampleScene.tsx": {
    "source": "import React, { useState } from 'react';\nimport { Line } from '@react-three/drei';\nimport { Vector3 } from 'three';\n\nimport { useColors } from '../../../../hooks/useColors';\n\nimport { BezierCurve } from '../../../../components/curve/BezierCurve';\nimport { DragControlPoints } from '../../../../components/curve/DragControlPoints';\nimport { OrthographicScene } from '../../../../components/scenes/OrthographicScene';\n\nexport const BezierCurveExampleScene = () => {\n  const colors = useColors();\n\n  const [points, setPoints] = useState([\n    new Vector3(0, 0, 0),\n    new Vector3(6, 0, 0),\n    new Vector3(0, 6, 0),\n    new Vector3(6, 6, 0),\n  ]);\n\n  return (\n    <OrthographicScene>\n      <group position={[-3, -2, 0]}>\n        <Line\n          points={points}\n          color={colors.highlight}\n          segments={true}\n        />\n        <DragControlPoints\n          axisLock=\"z\"\n          points={points}\n          setPoints={setPoints}\n        />\n        <BezierCurve points={points} />\n      </group>\n    </OrthographicScene>\n  );\n};\n",
    "functions": {},
    "types": {},
    "variables": {
      "BezierCurveExampleScene": "const BezierCurveExampleScene = () => {\n  const colors = useColors();\n\n  const [points, setPoints] = useState([\n    new Vector3(0, 0, 0),\n    new Vector3(6, 0, 0),\n    new Vector3(0, 6, 0),\n    new Vector3(6, 6, 0),\n  ]);\n\n  return (\n    <OrthographicScene>\n      <group position={[-3, -2, 0]}>\n        <Line\n          points={points}\n          color={colors.highlight}\n          segments={true}\n        />\n        <DragControlPoints\n          axisLock=\"z\"\n          points={points}\n          setPoints={setPoints}\n        />\n        <BezierCurve points={points} />\n      </group>\n    </OrthographicScene>\n  );\n};"
    }
  },
  "src/content/posts/writing-a-roller-coaster-simulation/bezier-curve/DeCasteljauVisualizationScene.tsx": {
    "source": "import React, { useEffect, useMemo, useState } from 'react';\nimport { Line } from '@react-three/drei';\nimport { useFrame } from '@react-three/fiber';\nimport { Easing, Group, Tween } from '@tweenjs/tween.js';\nimport { useControls } from 'leva';\nimport { Vector3 } from 'three';\n\nimport { deCasteljau } from '../../../../maths/bezier';\nimport { uniformSampleMap } from '../../../../helper/uniform-sample';\nimport { useColors } from '../../../../hooks/useColors';\n\nimport { ControlPoint } from '../../../../components/curve/ControlPoint';\nimport { DragControlPoints } from '../../../../components/curve/DragControlPoints';\nimport { OrthographicScene } from '../../../../components/scenes/OrthographicScene';\n\nexport const DeCasteljauVisualization = () => {\n  const colors = useColors();\n\n  const [state, setState] = useControls(() => ({\n    t: {\n      min: 0,\n      max: 1,\n      step: 0.01,\n      value: 0,\n    },\n    iteration: {\n      min: 0,\n      max: 2,\n      value: 0,\n      step: 1,\n    },\n    stopAnimation: false,\n  }));\n\n  const [points, setPoints] = useState([\n    new Vector3(0, 0, 0),\n    new Vector3(0, 8.5, 0),\n    new Vector3(9, 8.5, 0),\n    new Vector3(9, 0, 0),\n  ]);\n\n  const iterations = useMemo(() => {\n    const a = points[0].clone().lerp(points[1], state.t);\n    const b = points[1].clone().lerp(points[2], state.t);\n    const c = points[2].clone().lerp(points[3], state.t);\n    const d = a.clone().lerp(b, state.t);\n    const e = b.clone().lerp(c, state.t);\n    const f = d.clone().lerp(e, state.t);\n    return [[a, b, c], [d, e], [f]];\n  }, [points, state.t]);\n\n  const animationGroup = useMemo(() => {\n    const group = new Group();\n\n    const animation = {\n      t: 0,\n      iteration: state.iteration,\n    };\n\n    const toFullEvaluationTween = new Tween(animation)\n      .to({ t: 1 }, 3000)\n      .easing(Easing.Linear.None)\n      .onUpdate((obj) => setState({ ...obj }));\n\n    const toNoEvaluationTween = new Tween(animation)\n      .to({ t: 0 }, 3000)\n      .easing(Easing.Linear.None)\n      .onUpdate((obj) => setState({ ...obj }))\n      .onComplete(() => {\n        setState({\n          iteration: (state.iteration + 1) % iterations.length,\n        });\n      });\n\n    group.add(toFullEvaluationTween);\n    group.add(toNoEvaluationTween);\n    toFullEvaluationTween.chain(toNoEvaluationTween);\n    if (!state.stopAnimation) toFullEvaluationTween.start();\n\n    return group;\n  }, [\n    iterations.length,\n    setState,\n    state.iteration,\n    state.stopAnimation,\n  ]);\n\n  useEffect(() => {\n    if (state.stopAnimation)\n      animationGroup.getAll().forEach((tween) => tween.stop());\n    else animationGroup.getAll()[0]?.start();\n  }, [state.stopAnimation, animationGroup]);\n\n  const curve = useMemo(\n    () =>\n      uniformSampleMap(0, state.t, 40, (t) => deCasteljau(points, t)),\n    [points, state.t],\n  );\n\n  useFrame(() => {\n    animationGroup.update();\n  });\n\n  return (\n    <group position={[-4.5, -6, 0]}>\n      {iterations\n        .slice(0, state.iteration + 1)\n        .map((iteration, index) => {\n          const color =\n            index === state.iteration\n              ? colors.highlight\n              : colors.secondary;\n\n          return (\n            <React.Fragment key={index}>\n              {state.iteration >= iterations.length - 1 && (\n                <Line points={curve} color={color} />\n              )}\n              {iteration.map((position, nodeIndex) => (\n                <ControlPoint\n                  key={nodeIndex}\n                  size=\"sm\"\n                  position={position}\n                  color={color}\n                />\n              ))}\n              <Line points={iteration} color={color} />\n            </React.Fragment>\n          );\n        })}\n\n      <Line points={points} color={colors.secondary} />\n\n      <DragControlPoints\n        axisLock=\"z\"\n        points={points}\n        setPoints={setPoints}\n      />\n    </group>\n  );\n};\n\nexport const DeCasteljauVisualizationScene = () => {\n  return (\n    <>\n      <OrthographicScene>\n        <DeCasteljauVisualization />\n      </OrthographicScene>\n    </>\n  );\n};\n",
    "functions": {},
    "types": {},
    "variables": {
      "DeCasteljauVisualization": "const DeCasteljauVisualization = () => {\n  const colors = useColors();\n\n  const [state, setState] = useControls(() => ({\n    t: {\n      min: 0,\n      max: 1,\n      step: 0.01,\n      value: 0,\n    },\n    iteration: {\n      min: 0,\n      max: 2,\n      value: 0,\n      step: 1,\n    },\n    stopAnimation: false,\n  }));\n\n  const [points, setPoints] = useState([\n    new Vector3(0, 0, 0),\n    new Vector3(0, 8.5, 0),\n    new Vector3(9, 8.5, 0),\n    new Vector3(9, 0, 0),\n  ]);\n\n  const iterations = useMemo(() => {\n    const a = points[0].clone().lerp(points[1], state.t);\n    const b = points[1].clone().lerp(points[2], state.t);\n    const c = points[2].clone().lerp(points[3], state.t);\n    const d = a.clone().lerp(b, state.t);\n    const e = b.clone().lerp(c, state.t);\n    const f = d.clone().lerp(e, state.t);\n    return [[a, b, c], [d, e], [f]];\n  }, [points, state.t]);\n\n  const animationGroup = useMemo(() => {\n    const group = new Group();\n\n    const animation = {\n      t: 0,\n      iteration: state.iteration,\n    };\n\n    const toFullEvaluationTween = new Tween(animation)\n      .to({ t: 1 }, 3000)\n      .easing(Easing.Linear.None)\n      .onUpdate((obj) => setState({ ...obj }));\n\n    const toNoEvaluationTween = new Tween(animation)\n      .to({ t: 0 }, 3000)\n      .easing(Easing.Linear.None)\n      .onUpdate((obj) => setState({ ...obj }))\n      .onComplete(() => {\n        setState({\n          iteration: (state.iteration + 1) % iterations.length,\n        });\n      });\n\n    group.add(toFullEvaluationTween);\n    group.add(toNoEvaluationTween);\n    toFullEvaluationTween.chain(toNoEvaluationTween);\n    if (!state.stopAnimation) toFullEvaluationTween.start();\n\n    return group;\n  }, [\n    iterations.length,\n    setState,\n    state.iteration,\n    state.stopAnimation,\n  ]);\n\n  useEffect(() => {\n    if (state.stopAnimation)\n      animationGroup.getAll().forEach((tween) => tween.stop());\n    else animationGroup.getAll()[0]?.start();\n  }, [state.stopAnimation, animationGroup]);\n\n  const curve = useMemo(\n    () =>\n      uniformSampleMap(0, state.t, 40, (t) => deCasteljau(points, t)),\n    [points, state.t],\n  );\n\n  useFrame(() => {\n    animationGroup.update();\n  });\n\n  return (\n    <group position={[-4.5, -6, 0]}>\n      {iterations\n        .slice(0, state.iteration + 1)\n        .map((iteration, index) => {\n          const color =\n            index === state.iteration\n              ? colors.highlight\n              : colors.secondary;\n\n          return (\n            <React.Fragment key={index}>\n              {state.iteration >= iterations.length - 1 && (\n                <Line points={curve} color={color} />\n              )}\n              {iteration.map((position, nodeIndex) => (\n                <ControlPoint\n                  key={nodeIndex}\n                  size=\"sm\"\n                  position={position}\n                  color={color}\n                />\n              ))}\n              <Line points={iteration} color={color} />\n            </React.Fragment>\n          );\n        })}\n\n      <Line points={points} color={colors.secondary} />\n\n      <DragControlPoints\n        axisLock=\"z\"\n        points={points}\n        setPoints={setPoints}\n      />\n    </group>\n  );\n};",
      "DeCasteljauVisualizationScene": "const DeCasteljauVisualizationScene = () => {\n  return (\n    <>\n      <OrthographicScene>\n        <DeCasteljauVisualization />\n      </OrthographicScene>\n    </>\n  );\n};"
    }
  },
  "src/content/posts/writing-a-roller-coaster-simulation/bezier-curve/EstimateLengthScene.tsx": {
    "source": "import React, { useMemo, useState } from 'react';\nimport { Line } from '@react-three/drei';\nimport { useControls } from 'leva';\nimport { Vector3 } from 'three';\n\nimport { deCasteljau } from '../../../../maths/bezier';\nimport { uniformSampleMap } from '../../../../helper/uniform-sample';\nimport { useColors } from '../../../../hooks/useColors';\n\nimport { BezierCurve } from '../../../../components/curve/BezierCurve';\nimport { DragControlPoints } from '../../../../components/curve/DragControlPoints';\nimport { OrthographicScene } from '../../../../components/scenes/OrthographicScene';\n\nexport const EstimateLengthScene = () => {\n  const colors = useColors();\n\n  const [state] = useControls(() => ({\n    numberOfNodes: {\n      min: 2,\n      max: 16,\n      step: 1,\n      value: 8,\n    },\n  }));\n\n  const [points, setPoints] = useState([\n    new Vector3(0, 0, 0),\n    new Vector3(0, 8.5, 0),\n    new Vector3(9, 8.5, 0),\n    new Vector3(9, 0, 0),\n  ]);\n\n  const positions = useMemo(\n    () =>\n      uniformSampleMap(0, state.numberOfNodes, 1, (at, t) =>\n        deCasteljau(points, t),\n      ),\n    [state.numberOfNodes, points],\n  );\n\n  return (\n    <OrthographicScene>\n      <group position={[-4.5, -4.8, 0]}>\n        <Line points={positions} />\n        <Line\n          points={points}\n          color={colors.highlight}\n          segments={true}\n        />\n        <DragControlPoints\n          axisLock=\"z\"\n          points={points}\n          setPoints={setPoints}\n        />\n        <BezierCurve points={points} color={colors.highlight} />\n      </group>\n    </OrthographicScene>\n  );\n};\n",
    "functions": {},
    "types": {},
    "variables": {
      "EstimateLengthScene": "const EstimateLengthScene = () => {\n  const colors = useColors();\n\n  const [state] = useControls(() => ({\n    numberOfNodes: {\n      min: 2,\n      max: 16,\n      step: 1,\n      value: 8,\n    },\n  }));\n\n  const [points, setPoints] = useState([\n    new Vector3(0, 0, 0),\n    new Vector3(0, 8.5, 0),\n    new Vector3(9, 8.5, 0),\n    new Vector3(9, 0, 0),\n  ]);\n\n  const positions = useMemo(\n    () =>\n      uniformSampleMap(0, state.numberOfNodes, 1, (at, t) =>\n        deCasteljau(points, t),\n      ),\n    [state.numberOfNodes, points],\n  );\n\n  return (\n    <OrthographicScene>\n      <group position={[-4.5, -4.8, 0]}>\n        <Line points={positions} />\n        <Line\n          points={points}\n          color={colors.highlight}\n          segments={true}\n        />\n        <DragControlPoints\n          axisLock=\"z\"\n          points={points}\n          setPoints={setPoints}\n        />\n        <BezierCurve points={points} color={colors.highlight} />\n      </group>\n    </OrthographicScene>\n  );\n};"
    }
  },
  "src/content/posts/writing-a-roller-coaster-simulation/curve-nodes/BinarySearchDemoScene.tsx": {
    "source": "import React, { useMemo, useState } from 'react';\nimport { Line } from '@react-three/drei';\nimport { useControls } from 'leva';\nimport { Vector3 } from 'three';\n\nimport {\n  fromPoints,\n  totalArcLength,\n  transformationAtArcLength,\n} from '../../../../maths/curve';\nimport { toPosition } from '../../../../maths/matrix4';\nimport { findBoundingIndices } from '../../../../helper/binary-search';\nimport { useColors } from '../../../../hooks/useColors';\n\nimport { ControlPoint } from '../../../../components/curve/ControlPoint';\nimport { DragControlPoints } from '../../../../components/curve/DragControlPoints';\nimport { OrthographicScene } from '../../../../components/scenes/OrthographicScene';\n\nconst BinarySearchDemo = () => {\n  const colors = useColors();\n\n  const [points, setPoints] = useState([\n    new Vector3(-11, -2, 0),\n    new Vector3(-3, 2, 0),\n    new Vector3(3, -2, 0),\n    new Vector3(9, -2, 0),\n  ]);\n\n  const curve = useMemo(() => fromPoints(points), [points]);\n  const curveLength = totalArcLength(curve);\n\n  const { atArcLength } = useControls(\n    {\n      atArcLength: {\n        min: 0 - 1,\n        max: curveLength + 1,\n        value: 5,\n        step: 0.01,\n      },\n    },\n    [curveLength],\n  );\n\n  const position = toPosition(\n    transformationAtArcLength(curve, atArcLength),\n  );\n\n  const nodes = findBoundingIndices(\n    curve.nodes,\n    atArcLength,\n    (node) => node.arcLength,\n  )?.map((index) => toPosition(curve.nodes[index].transformation));\n\n  return (\n    <>\n      <DragControlPoints\n        axisLock=\"z\"\n        points={points}\n        setPoints={setPoints}\n      />\n\n      {[position, ...(nodes || [])].map((position) => (\n        <ControlPoint color={colors.highlight} position={position} />\n      ))}\n\n      <Line points={points} color={colors.secondary} />\n    </>\n  );\n};\n\nexport const MotionEvaluationDemoScene = () => {\n  return (\n    <OrthographicScene>\n      <BinarySearchDemo />\n    </OrthographicScene>\n  );\n};\n",
    "functions": {},
    "types": {},
    "variables": {
      "BinarySearchDemo": "const BinarySearchDemo = () => {\n  const colors = useColors();\n\n  const [points, setPoints] = useState([\n    new Vector3(-11, -2, 0),\n    new Vector3(-3, 2, 0),\n    new Vector3(3, -2, 0),\n    new Vector3(9, -2, 0),\n  ]);\n\n  const curve = useMemo(() => fromPoints(points), [points]);\n  const curveLength = totalArcLength(curve);\n\n  const { atArcLength } = useControls(\n    {\n      atArcLength: {\n        min: 0 - 1,\n        max: curveLength + 1,\n        value: 5,\n        step: 0.01,\n      },\n    },\n    [curveLength],\n  );\n\n  const position = toPosition(\n    transformationAtArcLength(curve, atArcLength),\n  );\n\n  const nodes = findBoundingIndices(\n    curve.nodes,\n    atArcLength,\n    (node) => node.arcLength,\n  )?.map((index) => toPosition(curve.nodes[index].transformation));\n\n  return (\n    <>\n      <DragControlPoints\n        axisLock=\"z\"\n        points={points}\n        setPoints={setPoints}\n      />\n\n      {[position, ...(nodes || [])].map((position) => (\n        <ControlPoint color={colors.highlight} position={position} />\n      ))}\n\n      <Line points={points} color={colors.secondary} />\n    </>\n  );\n};",
      "MotionEvaluationDemoScene": "const MotionEvaluationDemoScene = () => {\n  return (\n    <OrthographicScene>\n      <BinarySearchDemo />\n    </OrthographicScene>\n  );\n};"
    }
  },
  "src/content/posts/writing-a-roller-coaster-simulation/curve-nodes/curve.ts": {
    "source": "import last from 'lodash/last';\nimport { Matrix4, Vector3 } from 'three';\n\nimport { emptyCurve } from '../../../../maths/curve';\n\nexport const fromPoints = (points: Vector3[]) => {\n  const curve = emptyCurve();\n  if (points.length < 2) return curve;\n\n  let arcLength = 0;\n\n  for (let i = 0; i < points.length - 1; i++) {\n    const left = points[i];\n    const right = points[i + 1];\n    const prevNode = curve.nodes[curve.nodes.length - 1];\n\n    if (prevNode)\n      curve.nodes.push({\n        transformation: prevNode.transformation\n          .clone()\n          .setPosition(left),\n        arcLength,\n        segmentIndex: 0,\n      });\n\n    curve.nodes.push({\n      transformation: new Matrix4()\n        .lookAt(right, left, new Vector3(0, 1, 0))\n        .setPosition(left),\n      arcLength,\n      segmentIndex: 0,\n    });\n\n    arcLength += left.distanceTo(right);\n  }\n\n  const lastNode = last(curve.nodes)!;\n  const lastPoint = last(points)!;\n\n  curve.nodes.push({\n    transformation: lastNode.transformation\n      .clone()\n      .setPosition(lastPoint),\n    arcLength,\n    segmentIndex: 0,\n  });\n\n  curve.segmentOffsets.push(arcLength);\n\n  return curve;\n};\n",
    "functions": {},
    "types": {},
    "variables": {
      "fromPoints": "const fromPoints = (points: Vector3[]) => {\n  const curve = emptyCurve();\n  if (points.length < 2) return curve;\n\n  let arcLength = 0;\n\n  for (let i = 0; i < points.length - 1; i++) {\n    const left = points[i];\n    const right = points[i + 1];\n    const prevNode = curve.nodes[curve.nodes.length - 1];\n\n    if (prevNode)\n      curve.nodes.push({\n        transformation: prevNode.transformation\n          .clone()\n          .setPosition(left),\n        arcLength,\n        segmentIndex: 0,\n      });\n\n    curve.nodes.push({\n      transformation: new Matrix4()\n        .lookAt(right, left, new Vector3(0, 1, 0))\n        .setPosition(left),\n      arcLength,\n      segmentIndex: 0,\n    });\n\n    arcLength += left.distanceTo(right);\n  }\n\n  const lastNode = last(curve.nodes)!;\n  const lastPoint = last(points)!;\n\n  curve.nodes.push({\n    transformation: lastNode.transformation\n      .clone()\n      .setPosition(lastPoint),\n    arcLength,\n    segmentIndex: 0,\n  });\n\n  curve.segmentOffsets.push(arcLength);\n\n  return curve;\n};"
    }
  },
  "src/content/posts/writing-a-roller-coaster-simulation/curve-nodes/MotionEvaluationDemoScene.tsx": {
    "source": "import React, { useMemo, useState } from 'react';\nimport { Line } from '@react-three/drei';\nimport { Vector3 } from 'three';\n\nimport { useColors } from '../../../../hooks/useColors';\n\nimport { CurveWireframe } from '../../../../components/curve/CurveWireframe';\nimport { DragControlPoints } from '../../../../components/curve/DragControlPoints';\nimport { Ground } from '../../../../components/Ground';\nimport { EditorScene } from '../../../../components/scenes/EditorScene';\nimport { TrainWithPhysics } from '../../../../components/TrainWithPhysics';\n\nimport { fromPoints } from './curve';\n\nconst wireFrameParts = [new Vector3(1, 0, 0), new Vector3(-1, 0, 0)];\n\nexport const MotionEvaluationDemoScene = () => {\n  const colors = useColors();\n\n  const [points, setPoints] = useState([\n    new Vector3(-11.5, 2.5, 0),\n    new Vector3(-10, -0.75, 0),\n    new Vector3(-7.5, -2, 0),\n    new Vector3(-5, -1, 0),\n    new Vector3(-3, -1, 0),\n    new Vector3(-0.5, -2.5, 0),\n  ]);\n\n  const curve = useMemo(() => fromPoints(points), [points]);\n\n  return (\n    <EditorScene>\n      <DragControlPoints\n        axisLock=\"z\"\n        points={points}\n        setPoints={setPoints}\n      />\n      <CurveWireframe\n        rails={wireFrameParts}\n        tie={wireFrameParts}\n        curve={curve}\n      />\n      <Line points={points} color={colors.highlight} />\n      <TrainWithPhysics curve={curve} />\n      <Ground position={[0, -3, 0]} />\n    </EditorScene>\n  );\n};\n",
    "functions": {},
    "types": {},
    "variables": {
      "wireFrameParts": "const wireFrameParts = [new Vector3(1, 0, 0), new Vector3(-1, 0, 0)];",
      "MotionEvaluationDemoScene": "const MotionEvaluationDemoScene = () => {\n  const colors = useColors();\n\n  const [points, setPoints] = useState([\n    new Vector3(-11.5, 2.5, 0),\n    new Vector3(-10, -0.75, 0),\n    new Vector3(-7.5, -2, 0),\n    new Vector3(-5, -1, 0),\n    new Vector3(-3, -1, 0),\n    new Vector3(-0.5, -2.5, 0),\n  ]);\n\n  const curve = useMemo(() => fromPoints(points), [points]);\n\n  return (\n    <EditorScene>\n      <DragControlPoints\n        axisLock=\"z\"\n        points={points}\n        setPoints={setPoints}\n      />\n      <CurveWireframe\n        rails={wireFrameParts}\n        tie={wireFrameParts}\n        curve={curve}\n      />\n      <Line points={points} color={colors.highlight} />\n      <TrainWithPhysics curve={curve} />\n      <Ground position={[0, -3, 0]} />\n    </EditorScene>\n  );\n};"
    }
  },
  "src/content/posts/writing-a-roller-coaster-simulation/curve-orientation/CurveOrientationDemoScene.tsx": {
    "source": "import React, { useMemo, useState } from 'react';\nimport { Line } from '@react-three/drei';\nimport { Vector3 } from 'three';\n\nimport { bezierSplineCurve } from '../../../../maths/bezier';\nimport { useColors } from '../../../../hooks/useColors';\n\nimport { CurveTrackMesh } from '../../../../components/curve/CurveTrackMesh';\nimport { DragControlPoints } from '../../../../components/curve/DragControlPoints';\nimport { Ground } from '../../../../components/Ground';\nimport { EditorScene } from '../../../../components/scenes/EditorScene';\nimport { TrainWithPhysics } from '../../../../components/TrainWithPhysics';\n\nexport const CurveOrientationDemoScene = () => {\n  const colors = useColors();\n\n  const [points, setPoints] = useState([\n    new Vector3(0, 0, 0),\n    new Vector3(12, -5, 0),\n    new Vector3(12, 15, 0),\n    new Vector3(0, 10, 0),\n  ]);\n\n  const curve = useMemo(() => bezierSplineCurve(points), [points]);\n\n  return (\n    <EditorScene>\n      <group position={[-11, -5, -10]}>\n        <Line\n          points={points}\n          color={colors.highlight}\n          segments={true}\n        />\n        <DragControlPoints points={points} setPoints={setPoints} />\n        <CurveTrackMesh curve={curve} />\n        <TrainWithPhysics curve={curve} init={{ velocity: 17 }} />\n      </group>\n      <group position={[0, -10, 0]}>\n        <Ground />\n      </group>\n    </EditorScene>\n  );\n};\n",
    "functions": {},
    "types": {},
    "variables": {
      "CurveOrientationDemoScene": "const CurveOrientationDemoScene = () => {\n  const colors = useColors();\n\n  const [points, setPoints] = useState([\n    new Vector3(0, 0, 0),\n    new Vector3(12, -5, 0),\n    new Vector3(12, 15, 0),\n    new Vector3(0, 10, 0),\n  ]);\n\n  const curve = useMemo(() => bezierSplineCurve(points), [points]);\n\n  return (\n    <EditorScene>\n      <group position={[-11, -5, -10]}>\n        <Line\n          points={points}\n          color={colors.highlight}\n          segments={true}\n        />\n        <DragControlPoints points={points} setPoints={setPoints} />\n        <CurveTrackMesh curve={curve} />\n        <TrainWithPhysics curve={curve} init={{ velocity: 17 }} />\n      </group>\n      <group position={[0, -10, 0]}>\n        <Ground />\n      </group>\n    </EditorScene>\n  );\n};"
    }
  },
  "src/content/posts/writing-a-roller-coaster-simulation/curve-orientation/LookAtExampleScene.tsx": {
    "source": "import React, { useMemo } from 'react';\nimport { useControls } from 'leva';\nimport { Matrix4, Vector3 } from 'three';\n\nimport {\n  applyRollCurve,\n  emptyCurve,\n  toLocalTransformed,\n} from '../../../../maths/curve';\nimport { toPosition } from '../../../../maths/matrix4';\nimport { fromURL } from '../../../../helper/nl2park/nl2park';\nimport {\n  curveFromCustomTrack,\n  rollPointsFromCustomTrack,\n} from '../../../../helper/nolimits';\n\nimport { CurveTrackMesh } from '../../../../components/curve/CurveTrackMesh';\nimport { Ground } from '../../../../components/Ground';\nimport { PerspectiveScene } from '../../../../components/scenes/PerspectiveScene';\nimport { TrainWithPhysics } from '../../../../components/TrainWithPhysics';\n\nimport { fromRollPoints } from '../../../../coaster/cubic-roll';\nimport LookAtExample from './LookAtExample.nl2park';\n\nconst exampleCoaster = (await fromURL(LookAtExample)).coaster[0];\nconst exampleTrack = exampleCoaster?.tracks[0];\n\nexport const LookAtExampleScene = () => {\n  const { method } = useControls({\n    method: {\n      options: ['fixedUpLookAt', 'incremental'],\n      value: 'fixedUpLookAt',\n    },\n  });\n\n  const curve = useMemo(() => {\n    const trackCurve = curveFromCustomTrack(exampleTrack, false);\n\n    if (method === 'fixedUpLookAt') {\n      return emptyCurve(\n        trackCurve.nodes.map((node, index, nodes) => {\n          const isLast = index === nodes.length - 1;\n          const left = toPosition(\n            isLast\n              ? nodes[index - 1].transformation\n              : node.transformation,\n          );\n          const right = toPosition(\n            isLast\n              ? node.transformation\n              : nodes[index + 1].transformation,\n          );\n          return {\n            ...node,\n            transformation: new Matrix4()\n              .lookAt(right, left, new Vector3(0, 1, 0))\n              .setPosition(left),\n          };\n        }),\n        trackCurve.segmentOffsets,\n      );\n    } else return trackCurve;\n  }, [method]);\n\n  const curveWithRoll = useMemo(() => {\n    return toLocalTransformed(\n      applyRollCurve(\n        curve,\n        fromRollPoints(\n          curve,\n          rollPointsFromCustomTrack(exampleTrack),\n        ),\n      ),\n      new Vector3(0, -1.1, 0),\n    );\n  }, [curve]);\n\n  return (\n    <>\n      <PerspectiveScene>\n        <CurveTrackMesh curve={curveWithRoll} />\n        <TrainWithPhysics\n          activateCamera={true}\n          curve={curveWithRoll}\n          init={{ velocity: 23 }}\n        />\n        <Ground />\n      </PerspectiveScene>\n    </>\n  );\n};\n",
    "functions": {},
    "types": {},
    "variables": {
      "exampleCoaster": "const exampleCoaster = (await fromURL(LookAtExample)).coaster[0];",
      "exampleTrack": "const exampleTrack = exampleCoaster?.tracks[0];",
      "LookAtExampleScene": "const LookAtExampleScene = () => {\n  const { method } = useControls({\n    method: {\n      options: ['fixedUpLookAt', 'incremental'],\n      value: 'fixedUpLookAt',\n    },\n  });\n\n  const curve = useMemo(() => {\n    const trackCurve = curveFromCustomTrack(exampleTrack, false);\n\n    if (method === 'fixedUpLookAt') {\n      return emptyCurve(\n        trackCurve.nodes.map((node, index, nodes) => {\n          const isLast = index === nodes.length - 1;\n          const left = toPosition(\n            isLast\n              ? nodes[index - 1].transformation\n              : node.transformation,\n          );\n          const right = toPosition(\n            isLast\n              ? node.transformation\n              : nodes[index + 1].transformation,\n          );\n          return {\n            ...node,\n            transformation: new Matrix4()\n              .lookAt(right, left, new Vector3(0, 1, 0))\n              .setPosition(left),\n          };\n        }),\n        trackCurve.segmentOffsets,\n      );\n    } else return trackCurve;\n  }, [method]);\n\n  const curveWithRoll = useMemo(() => {\n    return toLocalTransformed(\n      applyRollCurve(\n        curve,\n        fromRollPoints(\n          curve,\n          rollPointsFromCustomTrack(exampleTrack),\n        ),\n      ),\n      new Vector3(0, -1.1, 0),\n    );\n  }, [curve]);\n\n  return (\n    <>\n      <PerspectiveScene>\n        <CurveTrackMesh curve={curveWithRoll} />\n        <TrainWithPhysics\n          activateCamera={true}\n          curve={curveWithRoll}\n          init={{ velocity: 23 }}\n        />\n        <Ground />\n      </PerspectiveScene>\n    </>\n  );\n};"
    }
  },
  "src/content/posts/writing-a-roller-coaster-simulation/evaluating-motion/MotionEvaluationDemoScene.tsx": {
    "source": "import React, { useEffect } from 'react';\nimport { Line } from '@react-three/drei';\nimport { useFrame } from '@react-three/fiber';\nimport { useControls } from 'leva';\nimport { MathUtils, Vector3 } from 'three';\n\nimport { useColors } from '../../../../hooks/useColors';\n\nimport { Arrow } from '../../../../components/Arrow';\nimport { ControlPoint } from '../../../../components/curve/ControlPoint';\nimport { OrthographicScene } from '../../../../components/scenes/OrthographicScene';\n\nimport { evaluateMotion } from './physics';\n\nconst MotionEvaluationDemo = () => {\n  const colors = useColors();\n\n  const [\n    { slope, gravity, sinSlope, trackLength, ...simulationState },\n    setSimulationState,\n  ] = useControls(() => ({\n    slope: {\n      value: 45,\n      step: 5,\n      min: -180,\n      max: 180,\n    },\n    trackLength: {\n      value: 8,\n      step: 1,\n      min: 0,\n      max: 20,\n    },\n    gravity: {\n      value: 9.81665,\n      pad: 5,\n    },\n    sinSlope: {\n      disabled: true,\n      label: 'sin(slope)',\n      pad: 5,\n      value: 0,\n    },\n    velocity: 0,\n    distanceTraveled: 0,\n  }));\n\n  const [, setState] = useControls(() => ({\n    acceleration: {\n      value: 0,\n      pad: 5,\n      disabled: true,\n    },\n  }));\n\n  useFrame((_, deltaTime) => {\n    const sinSlope = Math.sin(MathUtils.degToRad(slope));\n    const acceleration = gravity * sinSlope;\n\n    setSimulationState(\n      evaluateMotion(simulationState, acceleration, deltaTime),\n    );\n\n    setState({ acceleration });\n  });\n\n  // reset simulation state if train overshoots track\n  useEffect(() => {\n    if (\n      simulationState.distanceTraveled < 0 ||\n      simulationState.distanceTraveled > trackLength\n    ) {\n      setSimulationState({\n        velocity: 0,\n        distanceTraveled: 0,\n      });\n    }\n  }, [\n    simulationState.distanceTraveled,\n    trackLength,\n    setSimulationState,\n  ]);\n\n  return (\n    <>\n      <group\n        position={[-5, 0, 0]}\n        rotation={[0, 0, MathUtils.degToRad(slope)]}\n      >\n        <Arrow\n          position={[-trackLength / 2, 0, 0]}\n          rotation={[0, 0, Math.PI / 2]}\n          color={colors.secondary}\n        />\n\n        <ControlPoint\n          color={colors.highlight}\n          position={\n            new Vector3(\n              trackLength / 2 - simulationState.distanceTraveled,\n              0,\n              0,\n            )\n          }\n        />\n\n        <Line\n          points={[\n            new Vector3(-trackLength / 2, 0, 0),\n            new Vector3(trackLength / 2, 0, 0),\n          ]}\n          color={colors.secondary}\n        />\n      </group>\n    </>\n  );\n};\n\nexport const MotionEvaluationDemoScene = () => {\n  return (\n    <OrthographicScene>\n      <MotionEvaluationDemo />\n    </OrthographicScene>\n  );\n};\n",
    "functions": {},
    "types": {},
    "variables": {
      "MotionEvaluationDemo": "const MotionEvaluationDemo = () => {\n  const colors = useColors();\n\n  const [\n    { slope, gravity, sinSlope, trackLength, ...simulationState },\n    setSimulationState,\n  ] = useControls(() => ({\n    slope: {\n      value: 45,\n      step: 5,\n      min: -180,\n      max: 180,\n    },\n    trackLength: {\n      value: 8,\n      step: 1,\n      min: 0,\n      max: 20,\n    },\n    gravity: {\n      value: 9.81665,\n      pad: 5,\n    },\n    sinSlope: {\n      disabled: true,\n      label: 'sin(slope)',\n      pad: 5,\n      value: 0,\n    },\n    velocity: 0,\n    distanceTraveled: 0,\n  }));\n\n  const [, setState] = useControls(() => ({\n    acceleration: {\n      value: 0,\n      pad: 5,\n      disabled: true,\n    },\n  }));\n\n  useFrame((_, deltaTime) => {\n    const sinSlope = Math.sin(MathUtils.degToRad(slope));\n    const acceleration = gravity * sinSlope;\n\n    setSimulationState(\n      evaluateMotion(simulationState, acceleration, deltaTime),\n    );\n\n    setState({ acceleration });\n  });\n\n  // reset simulation state if train overshoots track\n  useEffect(() => {\n    if (\n      simulationState.distanceTraveled < 0 ||\n      simulationState.distanceTraveled > trackLength\n    ) {\n      setSimulationState({\n        velocity: 0,\n        distanceTraveled: 0,\n      });\n    }\n  }, [\n    simulationState.distanceTraveled,\n    trackLength,\n    setSimulationState,\n  ]);\n\n  return (\n    <>\n      <group\n        position={[-5, 0, 0]}\n        rotation={[0, 0, MathUtils.degToRad(slope)]}\n      >\n        <Arrow\n          position={[-trackLength / 2, 0, 0]}\n          rotation={[0, 0, Math.PI / 2]}\n          color={colors.secondary}\n        />\n\n        <ControlPoint\n          color={colors.highlight}\n          position={\n            new Vector3(\n              trackLength / 2 - simulationState.distanceTraveled,\n              0,\n              0,\n            )\n          }\n        />\n\n        <Line\n          points={[\n            new Vector3(-trackLength / 2, 0, 0),\n            new Vector3(trackLength / 2, 0, 0),\n          ]}\n          color={colors.secondary}\n        />\n      </group>\n    </>\n  );\n};",
      "MotionEvaluationDemoScene": "const MotionEvaluationDemoScene = () => {\n  return (\n    <OrthographicScene>\n      <MotionEvaluationDemo />\n    </OrthographicScene>\n  );\n};"
    }
  },
  "src/content/posts/writing-a-roller-coaster-simulation/evaluating-motion/physics.ts": {
    "source": "export type SimulationState = {\n  velocity: number;\n  distanceTraveled: number;\n};\n\nexport const evaluateMotion = (\n  state: SimulationState,\n  acceleration: number,\n  deltaTime: number,\n): SimulationState => {\n  const velocity = state.velocity + acceleration * deltaTime;\n  const distanceTraveled =\n    state.distanceTraveled + velocity * deltaTime;\n\n  return { velocity, distanceTraveled };\n};\n",
    "functions": {},
    "types": {
      "SimulationState": "type SimulationState = {\n  velocity: number;\n  distanceTraveled: number;\n};"
    },
    "variables": {
      "evaluateMotion": "const evaluateMotion = (\n  state: SimulationState,\n  acceleration: number,\n  deltaTime: number,\n): SimulationState => {\n  const velocity = state.velocity + acceleration * deltaTime;\n  const distanceTraveled =\n    state.distanceTraveled + velocity * deltaTime;\n\n  return { velocity, distanceTraveled };\n};"
    }
  },
  "src/content/posts/writing-a-roller-coaster-simulation/friction-and-air-resistance/FrictionAndAirResistanceDemoScene.tsx": {
    "source": "import React, { useEffect, useState } from 'react';\nimport { Line } from '@react-three/drei';\nimport { useFrame } from '@react-three/fiber';\nimport { MathUtils, Vector3 } from 'three';\n\nimport {\n  forwardDirectionAtArcLength,\n  positionAtArcLength,\n  totalArcLength,\n} from '../../../../maths/linear';\nimport { useColors } from '../../../../hooks/useColors';\nimport { useSimulationStateControls } from '../../../../hooks/useSimulationStateControls';\n\nimport { ControlPoint } from '../../../../components/curve/ControlPoint';\nimport { DragControlPoints } from '../../../../components/curve/DragControlPoints';\nimport { Ground } from '../../../../components/Ground';\nimport { EditorScene } from '../../../../components/scenes/EditorScene';\n\nimport {\n  evaluateMotion,\n  evaluateMotionWithFriction,\n} from '../linear-track/physics';\n\nconst FrictionAndAirResistanceDemo = () => {\n  const colors = useColors();\n\n  const [points, setPoints] = useState([\n    new Vector3(-11.5, 3.2, 0),\n    new Vector3(0, -2.8, 0),\n  ]);\n\n  const [simulationState, setSimulationState] =\n    useSimulationStateControls();\n\n  const [\n    simulationStateWithoutFriction,\n    setSimulationStateWithoutFriction,\n  ] = useState(() => ({\n    velocity: 0,\n    distanceTraveled: 0,\n    acceleration: 0,\n  }));\n\n  useFrame((state, deltaTime) => {\n    // with friction and air resistance\n    setSimulationState(\n      evaluateMotionWithFriction(\n        simulationState,\n        forwardDirectionAtArcLength(\n          points[0],\n          points[1],\n          simulationState.distanceTraveled,\n        ),\n        simulationState.friction,\n        simulationState.airResistance,\n        simulationState.gravity,\n        deltaTime * simulationState.simulationSpeed,\n      ),\n    );\n\n    // without energy loss\n    setSimulationStateWithoutFriction(\n      evaluateMotion(\n        simulationStateWithoutFriction,\n        forwardDirectionAtArcLength(\n          points[0],\n          points[1],\n          simulationStateWithoutFriction.distanceTraveled,\n        ),\n        simulationState.gravity,\n        deltaTime * simulationState.simulationSpeed,\n      ),\n    );\n  });\n\n  // reset simulation state if train overshoots track\n  useEffect(() => {\n    if (\n      simulationState.distanceTraveled >\n        totalArcLength(points[0], points[1]) ||\n      simulationState.distanceTraveled < 0\n    ) {\n      setSimulationState({\n        velocity: 0,\n        distanceTraveled: 0,\n        acceleration: 0,\n      });\n\n      setSimulationStateWithoutFriction({\n        velocity: 0,\n        distanceTraveled: 0,\n        acceleration: 0,\n      });\n    }\n  }, [\n    simulationState.distanceTraveled,\n    points,\n    setSimulationState,\n    setSimulationStateWithoutFriction,\n  ]);\n\n  const trainPosition = positionAtArcLength(\n    points[0],\n    points[1],\n    MathUtils.clamp(\n      simulationState.distanceTraveled,\n      0,\n      totalArcLength(points[0], points[1]),\n    ),\n  );\n\n  const trainPositionWithoutFriction = positionAtArcLength(\n    points[0],\n    points[1],\n    MathUtils.clamp(\n      simulationStateWithoutFriction.distanceTraveled,\n      0,\n      totalArcLength(points[0], points[1]),\n    ),\n  );\n\n  return (\n    <>\n      <DragControlPoints\n        axisLock=\"z\"\n        points={points}\n        setPoints={setPoints}\n      />\n      <Line points={points} color={colors.secondary} />\n      <ControlPoint\n        position={trainPosition}\n        color={colors.highlight}\n      />\n      <Ground position={[0, -3, 0]} />\n      <ControlPoint position={trainPositionWithoutFriction} />\n    </>\n  );\n};\n\nexport const FrictionAndAirResistanceDemoScene = () => {\n  return (\n    <EditorScene>\n      <FrictionAndAirResistanceDemo />\n    </EditorScene>\n  );\n};\n",
    "functions": {},
    "types": {},
    "variables": {
      "FrictionAndAirResistanceDemo": "const FrictionAndAirResistanceDemo = () => {\n  const colors = useColors();\n\n  const [points, setPoints] = useState([\n    new Vector3(-11.5, 3.2, 0),\n    new Vector3(0, -2.8, 0),\n  ]);\n\n  const [simulationState, setSimulationState] =\n    useSimulationStateControls();\n\n  const [\n    simulationStateWithoutFriction,\n    setSimulationStateWithoutFriction,\n  ] = useState(() => ({\n    velocity: 0,\n    distanceTraveled: 0,\n    acceleration: 0,\n  }));\n\n  useFrame((state, deltaTime) => {\n    // with friction and air resistance\n    setSimulationState(\n      evaluateMotionWithFriction(\n        simulationState,\n        forwardDirectionAtArcLength(\n          points[0],\n          points[1],\n          simulationState.distanceTraveled,\n        ),\n        simulationState.friction,\n        simulationState.airResistance,\n        simulationState.gravity,\n        deltaTime * simulationState.simulationSpeed,\n      ),\n    );\n\n    // without energy loss\n    setSimulationStateWithoutFriction(\n      evaluateMotion(\n        simulationStateWithoutFriction,\n        forwardDirectionAtArcLength(\n          points[0],\n          points[1],\n          simulationStateWithoutFriction.distanceTraveled,\n        ),\n        simulationState.gravity,\n        deltaTime * simulationState.simulationSpeed,\n      ),\n    );\n  });\n\n  // reset simulation state if train overshoots track\n  useEffect(() => {\n    if (\n      simulationState.distanceTraveled >\n        totalArcLength(points[0], points[1]) ||\n      simulationState.distanceTraveled < 0\n    ) {\n      setSimulationState({\n        velocity: 0,\n        distanceTraveled: 0,\n        acceleration: 0,\n      });\n\n      setSimulationStateWithoutFriction({\n        velocity: 0,\n        distanceTraveled: 0,\n        acceleration: 0,\n      });\n    }\n  }, [\n    simulationState.distanceTraveled,\n    points,\n    setSimulationState,\n    setSimulationStateWithoutFriction,\n  ]);\n\n  const trainPosition = positionAtArcLength(\n    points[0],\n    points[1],\n    MathUtils.clamp(\n      simulationState.distanceTraveled,\n      0,\n      totalArcLength(points[0], points[1]),\n    ),\n  );\n\n  const trainPositionWithoutFriction = positionAtArcLength(\n    points[0],\n    points[1],\n    MathUtils.clamp(\n      simulationStateWithoutFriction.distanceTraveled,\n      0,\n      totalArcLength(points[0], points[1]),\n    ),\n  );\n\n  return (\n    <>\n      <DragControlPoints\n        axisLock=\"z\"\n        points={points}\n        setPoints={setPoints}\n      />\n      <Line points={points} color={colors.secondary} />\n      <ControlPoint\n        position={trainPosition}\n        color={colors.highlight}\n      />\n      <Ground position={[0, -3, 0]} />\n      <ControlPoint position={trainPositionWithoutFriction} />\n    </>\n  );\n};",
      "FrictionAndAirResistanceDemoScene": "const FrictionAndAirResistanceDemoScene = () => {\n  return (\n    <EditorScene>\n      <FrictionAndAirResistanceDemo />\n    </EditorScene>\n  );\n};"
    }
  },
  "src/content/posts/writing-a-roller-coaster-simulation/gravity/GravityDemoScene.tsx": {
    "source": "import React, { useEffect } from 'react';\nimport { Line } from '@react-three/drei';\nimport { useControls } from 'leva';\nimport { MathUtils, Vector3 } from 'three';\n\nimport { useColors } from '../../../../hooks/useColors';\n\nimport { Arrow } from '../../../../components/Arrow';\nimport { OrthographicScene } from '../../../../components/scenes/OrthographicScene';\n\nconst GravityDemo = () => {\n  const colors = useColors();\n  const lineLength = 8;\n\n  const [{ slope, gravity }, setState] = useControls(() => ({\n    slope: {\n      value: 45,\n      step: 5,\n      min: -180,\n      max: 180,\n    },\n    gravity: {\n      value: 9.81665,\n      pad: 5,\n    },\n    sinSlope: {\n      disabled: true,\n      label: 'sin(slope)',\n      pad: 5,\n      value: 0,\n    },\n    acceleration: {\n      disabled: true,\n      value: 0,\n      pad: 5,\n    },\n  }));\n\n  useEffect(() => {\n    const sinSlope = Math.sin(MathUtils.degToRad(slope));\n    const acceleration = gravity * sinSlope;\n\n    setState({ acceleration, sinSlope });\n  }, [slope, gravity, setState]);\n\n  return (\n    <>\n      <group\n        position={[-5, 0, 0]}\n        rotation={[0, 0, MathUtils.degToRad(slope)]}\n      >\n        <Arrow\n          position={[-lineLength / 2, 0, 0]}\n          rotation={[0, 0, Math.PI / 2]}\n          color={colors.secondary}\n        />\n\n        <Line\n          points={[\n            new Vector3(-lineLength / 2, 0, 0),\n            new Vector3(lineLength / 2, 0, 0),\n          ]}\n          color={colors.secondary}\n        />\n      </group>\n    </>\n  );\n};\n\nexport const GravityDemoScene = () => {\n  return (\n    <OrthographicScene>\n      <GravityDemo />\n    </OrthographicScene>\n  );\n};\n",
    "functions": {},
    "types": {},
    "variables": {
      "GravityDemo": "const GravityDemo = () => {\n  const colors = useColors();\n  const lineLength = 8;\n\n  const [{ slope, gravity }, setState] = useControls(() => ({\n    slope: {\n      value: 45,\n      step: 5,\n      min: -180,\n      max: 180,\n    },\n    gravity: {\n      value: 9.81665,\n      pad: 5,\n    },\n    sinSlope: {\n      disabled: true,\n      label: 'sin(slope)',\n      pad: 5,\n      value: 0,\n    },\n    acceleration: {\n      disabled: true,\n      value: 0,\n      pad: 5,\n    },\n  }));\n\n  useEffect(() => {\n    const sinSlope = Math.sin(MathUtils.degToRad(slope));\n    const acceleration = gravity * sinSlope;\n\n    setState({ acceleration, sinSlope });\n  }, [slope, gravity, setState]);\n\n  return (\n    <>\n      <group\n        position={[-5, 0, 0]}\n        rotation={[0, 0, MathUtils.degToRad(slope)]}\n      >\n        <Arrow\n          position={[-lineLength / 2, 0, 0]}\n          rotation={[0, 0, Math.PI / 2]}\n          color={colors.secondary}\n        />\n\n        <Line\n          points={[\n            new Vector3(-lineLength / 2, 0, 0),\n            new Vector3(lineLength / 2, 0, 0),\n          ]}\n          color={colors.secondary}\n        />\n      </group>\n    </>\n  );\n};",
      "GravityDemoScene": "const GravityDemoScene = () => {\n  return (\n    <OrthographicScene>\n      <GravityDemo />\n    </OrthographicScene>\n  );\n};"
    }
  },
  "src/content/posts/writing-a-roller-coaster-simulation/linear-track/LinearTrackDemoScene.tsx": {
    "source": "import React, { useEffect, useState } from 'react';\nimport { Line } from '@react-three/drei';\nimport { useFrame } from '@react-three/fiber';\nimport { useControls } from 'leva';\nimport { Vector3 } from 'three';\n\nimport {\n  forwardDirectionAtArcLength,\n  positionAtArcLength,\n  totalArcLength,\n} from '../../../../maths/linear';\nimport { useColors } from '../../../../hooks/useColors';\n\nimport { ControlPoint } from '../../../../components/curve/ControlPoint';\nimport { DragControlPoints } from '../../../../components/curve/DragControlPoints';\nimport { Ground } from '../../../../components/Ground';\nimport { EditorScene } from '../../../../components/scenes/EditorScene';\n\nimport { evaluateMotion } from './physics';\n\nconst LinearTrackDemo = () => {\n  const colors = useColors();\n\n  // control points\n  const [points, setPoints] = useState([\n    new Vector3(-11.5, 3.2, 0),\n    new Vector3(0, -2.8, 0),\n  ]);\n\n  const [simulationState, setSimulationState] = useControls(\n    'Simulation',\n    () => ({\n      velocity: 0,\n      distanceTraveled: 0,\n      acceleration: {\n        value: 0,\n        pad: 5,\n      },\n      gravity: {\n        value: 9.81665,\n        pad: 5,\n      },\n    }),\n  );\n\n  useFrame((state, deltaTime) => {\n    setSimulationState(\n      evaluateMotion(\n        simulationState,\n        forwardDirectionAtArcLength(\n          points[0],\n          points[1],\n          simulationState.distanceTraveled,\n        ),\n        simulationState.gravity,\n        deltaTime,\n      ),\n    );\n  });\n\n  // reset simulation state if train overshoots track\n  useEffect(() => {\n    if (\n      simulationState.distanceTraveled >\n        totalArcLength(points[0], points[1]) ||\n      simulationState.distanceTraveled < 0\n    ) {\n      setSimulationState({\n        velocity: 0,\n        distanceTraveled: 0,\n        acceleration: 0,\n      });\n    }\n  }, [simulationState.distanceTraveled, setSimulationState, points]);\n\n  const trainPosition = positionAtArcLength(\n    points[0],\n    points[1],\n    simulationState.distanceTraveled,\n  );\n\n  return (\n    <>\n      <DragControlPoints\n        axisLock=\"z\"\n        points={points}\n        setPoints={setPoints}\n      />\n      <Line points={points} color={colors.secondary} />\n      <Ground position={[0, -3, 0]} />\n      <ControlPoint\n        position={trainPosition}\n        color={colors.highlight}\n      />\n    </>\n  );\n};\n\nexport const LinearTrackDemoScene = () => {\n  return (\n    <EditorScene>\n      <LinearTrackDemo />\n    </EditorScene>\n  );\n};\n",
    "functions": {},
    "types": {},
    "variables": {
      "LinearTrackDemo": "const LinearTrackDemo = () => {\n  const colors = useColors();\n\n  // control points\n  const [points, setPoints] = useState([\n    new Vector3(-11.5, 3.2, 0),\n    new Vector3(0, -2.8, 0),\n  ]);\n\n  const [simulationState, setSimulationState] = useControls(\n    'Simulation',\n    () => ({\n      velocity: 0,\n      distanceTraveled: 0,\n      acceleration: {\n        value: 0,\n        pad: 5,\n      },\n      gravity: {\n        value: 9.81665,\n        pad: 5,\n      },\n    }),\n  );\n\n  useFrame((state, deltaTime) => {\n    setSimulationState(\n      evaluateMotion(\n        simulationState,\n        forwardDirectionAtArcLength(\n          points[0],\n          points[1],\n          simulationState.distanceTraveled,\n        ),\n        simulationState.gravity,\n        deltaTime,\n      ),\n    );\n  });\n\n  // reset simulation state if train overshoots track\n  useEffect(() => {\n    if (\n      simulationState.distanceTraveled >\n        totalArcLength(points[0], points[1]) ||\n      simulationState.distanceTraveled < 0\n    ) {\n      setSimulationState({\n        velocity: 0,\n        distanceTraveled: 0,\n        acceleration: 0,\n      });\n    }\n  }, [simulationState.distanceTraveled, setSimulationState, points]);\n\n  const trainPosition = positionAtArcLength(\n    points[0],\n    points[1],\n    simulationState.distanceTraveled,\n  );\n\n  return (\n    <>\n      <DragControlPoints\n        axisLock=\"z\"\n        points={points}\n        setPoints={setPoints}\n      />\n      <Line points={points} color={colors.secondary} />\n      <Ground position={[0, -3, 0]} />\n      <ControlPoint\n        position={trainPosition}\n        color={colors.highlight}\n      />\n    </>\n  );\n};",
      "LinearTrackDemoScene": "const LinearTrackDemoScene = () => {\n  return (\n    <EditorScene>\n      <LinearTrackDemo />\n    </EditorScene>\n  );\n};"
    }
  },
  "src/content/posts/writing-a-roller-coaster-simulation/linear-track/physics.ts": {
    "source": "import { Vector3 } from 'three';\n\nimport { SimulationState } from '../../../../helper/physics';\n\nexport const evaluateMotion = (\n  state: SimulationState,\n  forwardDirection: Vector3,\n  gravity: number,\n  deltaTime: number,\n): SimulationState => {\n  const acceleration = forwardDirection.dot(\n    new Vector3(0, -gravity, 0),\n  );\n  const velocity = state.velocity + acceleration * deltaTime;\n  const distanceTraveled =\n    state.distanceTraveled + velocity * deltaTime;\n\n  return { velocity, distanceTraveled, acceleration };\n};\n\nexport const evaluateMotionWithFriction = (\n  state: SimulationState,\n  forwardDirection: Vector3,\n  friction: number,\n  airResistance: number,\n  gravity: number,\n  deltaTime: number,\n): SimulationState => {\n  const velocityDirection = state.velocity < 0 ? -1 : 1;\n\n  let energyLoss = airResistance * state.velocity * state.velocity;\n  energyLoss += friction * gravity;\n  energyLoss *= velocityDirection;\n\n  let acceleration = forwardDirection.dot(\n    new Vector3(0, -gravity, 0),\n  );\n  acceleration -= energyLoss;\n\n  const velocity = state.velocity + acceleration * deltaTime;\n  const distanceTraveled =\n    state.distanceTraveled + velocity * deltaTime;\n\n  return { velocity, distanceTraveled, acceleration };\n};\n",
    "functions": {},
    "types": {},
    "variables": {
      "evaluateMotion": "const evaluateMotion = (\n  state: SimulationState,\n  forwardDirection: Vector3,\n  gravity: number,\n  deltaTime: number,\n): SimulationState => {\n  const acceleration = forwardDirection.dot(\n    new Vector3(0, -gravity, 0),\n  );\n  const velocity = state.velocity + acceleration * deltaTime;\n  const distanceTraveled =\n    state.distanceTraveled + velocity * deltaTime;\n\n  return { velocity, distanceTraveled, acceleration };\n};",
      "evaluateMotionWithFriction": "const evaluateMotionWithFriction = (\n  state: SimulationState,\n  forwardDirection: Vector3,\n  friction: number,\n  airResistance: number,\n  gravity: number,\n  deltaTime: number,\n): SimulationState => {\n  const velocityDirection = state.velocity < 0 ? -1 : 1;\n\n  let energyLoss = airResistance * state.velocity * state.velocity;\n  energyLoss += friction * gravity;\n  energyLoss *= velocityDirection;\n\n  let acceleration = forwardDirection.dot(\n    new Vector3(0, -gravity, 0),\n  );\n  acceleration -= energyLoss;\n\n  const velocity = state.velocity + acceleration * deltaTime;\n  const distanceTraveled =\n    state.distanceTraveled + velocity * deltaTime;\n\n  return { velocity, distanceTraveled, acceleration };\n};"
    }
  },
  "src/content/posts/writing-a-roller-coaster-simulation/transformation-matrix/TransformationMatrixDemoScene.tsx": {
    "source": "import React, { useEffect, useState } from 'react';\nimport { Line } from '@react-three/drei';\nimport { useFrame } from '@react-three/fiber';\nimport { MathUtils, Vector3 } from 'three';\n\nimport {\n  totalArcLength,\n  transformationAtArcLength,\n} from '../../../../maths/linear';\nimport { evaluateMotion } from '../../../../helper/physics';\nimport { useColors } from '../../../../hooks/useColors';\nimport { useSimulationStateControls } from '../../../../hooks/useSimulationStateControls';\n\nimport { DragControlPoints } from '../../../../components/curve/DragControlPoints';\nimport { Ground } from '../../../../components/Ground';\nimport { PointWithMatrixArrows } from '../../../../components/PointWithMatrixArrows';\nimport { EditorScene } from '../../../../components/scenes/EditorScene';\n\nconst TransformationMatrixDemo = () => {\n  const colors = useColors();\n\n  // control points\n  const [points, setPoints] = useState([\n    new Vector3(-11.5, 3.2, 0),\n    new Vector3(0, -2.8, 0),\n  ]);\n\n  const [simulationState, setSimulationState] =\n    useSimulationStateControls();\n\n  useFrame((state, deltaTime) => {\n    setSimulationState(\n      evaluateMotion(\n        simulationState,\n        transformationAtArcLength(\n          points[0],\n          points[1],\n          simulationState.distanceTraveled,\n        ),\n        0,\n        simulationState.friction,\n        simulationState.airResistance,\n        simulationState.gravity,\n        deltaTime * simulationState.simulationSpeed,\n      ),\n    );\n  });\n\n  // reset simulation state if train overshoots track\n  useEffect(() => {\n    if (\n      simulationState.distanceTraveled >\n        totalArcLength(points[0], points[1]) ||\n      simulationState.distanceTraveled < 0\n    ) {\n      setSimulationState({\n        velocity: 0,\n        distanceTraveled: 0,\n        acceleration: 0,\n      });\n    }\n  }, [simulationState.distanceTraveled, points, setSimulationState]);\n\n  const motionMatrix = transformationAtArcLength(\n    points[0],\n    points[1],\n    MathUtils.clamp(\n      simulationState.distanceTraveled,\n      0,\n      totalArcLength(points[0], points[1]),\n    ),\n  );\n\n  return (\n    <>\n      <DragControlPoints\n        axisLock=\"z\"\n        points={points}\n        setPoints={setPoints}\n      />\n      <Line points={points} color={colors.secondary} />\n      <Ground position={[0, -5, 0]} />\n      <PointWithMatrixArrows matrix={motionMatrix} />\n    </>\n  );\n};\n\nexport const TransformationMatrixDemoScene = () => {\n  return (\n    <EditorScene>\n      <TransformationMatrixDemo />\n    </EditorScene>\n  );\n};\n",
    "functions": {},
    "types": {},
    "variables": {
      "TransformationMatrixDemo": "const TransformationMatrixDemo = () => {\n  const colors = useColors();\n\n  // control points\n  const [points, setPoints] = useState([\n    new Vector3(-11.5, 3.2, 0),\n    new Vector3(0, -2.8, 0),\n  ]);\n\n  const [simulationState, setSimulationState] =\n    useSimulationStateControls();\n\n  useFrame((state, deltaTime) => {\n    setSimulationState(\n      evaluateMotion(\n        simulationState,\n        transformationAtArcLength(\n          points[0],\n          points[1],\n          simulationState.distanceTraveled,\n        ),\n        0,\n        simulationState.friction,\n        simulationState.airResistance,\n        simulationState.gravity,\n        deltaTime * simulationState.simulationSpeed,\n      ),\n    );\n  });\n\n  // reset simulation state if train overshoots track\n  useEffect(() => {\n    if (\n      simulationState.distanceTraveled >\n        totalArcLength(points[0], points[1]) ||\n      simulationState.distanceTraveled < 0\n    ) {\n      setSimulationState({\n        velocity: 0,\n        distanceTraveled: 0,\n        acceleration: 0,\n      });\n    }\n  }, [simulationState.distanceTraveled, points, setSimulationState]);\n\n  const motionMatrix = transformationAtArcLength(\n    points[0],\n    points[1],\n    MathUtils.clamp(\n      simulationState.distanceTraveled,\n      0,\n      totalArcLength(points[0], points[1]),\n    ),\n  );\n\n  return (\n    <>\n      <DragControlPoints\n        axisLock=\"z\"\n        points={points}\n        setPoints={setPoints}\n      />\n      <Line points={points} color={colors.secondary} />\n      <Ground position={[0, -5, 0]} />\n      <PointWithMatrixArrows matrix={motionMatrix} />\n    </>\n  );\n};",
      "TransformationMatrixDemoScene": "const TransformationMatrixDemoScene = () => {\n  return (\n    <EditorScene>\n      <TransformationMatrixDemo />\n    </EditorScene>\n  );\n};"
    }
  }
}