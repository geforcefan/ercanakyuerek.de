<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Ercan Akyürek</title><link>https://ercanakyuerek.de/</link><description>Recent content on Ercan Akyürek</description><generator>Hugo</generator><language>en</language><lastBuildDate>Sun, 04 Jan 2026 21:00:00 +0100</lastBuildDate><atom:link href="https://ercanakyuerek.de/index.xml" rel="self" type="application/rss+xml"/><item><title>NURBS, Roll, Physics in Action</title><link>https://ercanakyuerek.de/posts/roller-coaster-simulation/nurbs-roll-physics-in-action/</link><pubDate>Sun, 04 Jan 2026 21:00:00 +0100</pubDate><guid>https://ercanakyuerek.de/posts/roller-coaster-simulation/nurbs-roll-physics-in-action/</guid><description>&lt;p&gt;Parallel to writing this series about building a &lt;a href="https://ercanakyuerek.de/tags/writing-a-roller-coaster-simulation/"&gt;roller coaster simulator in the browser&lt;/a&gt;, I am also implementing and testing everything I write about in a real project.&lt;/p&gt;
&lt;p&gt;At this point, the simulator already supports &lt;strong&gt;NURBS tracks&lt;/strong&gt;, &lt;strong&gt;roll interpolation&lt;/strong&gt;, and the full &lt;strong&gt;physics simulation&lt;/strong&gt;. Most of the ideas in the articles are no longer just sketches. They are running code.&lt;/p&gt;
&lt;p&gt;A large part of the work recently was, understanding how &lt;strong&gt;NoLimits Roller Coaster 2&lt;/strong&gt; handles track interpolation and roll. I spent quite a few hours digging into this, because, well, I more or less reimplemented its curve generation logic.&lt;/p&gt;</description></item><item><title>Curve normals</title><link>https://ercanakyuerek.de/posts/writing-a-roller-coaster-simulation/curve-normals/</link><pubDate>Sun, 04 Jan 2026 14:30:00 +0100</pubDate><guid>https://ercanakyuerek.de/posts/writing-a-roller-coaster-simulation/curve-normals/</guid><description>&lt;hr&gt;
&lt;h1 id="the-lookat-problem"&gt;The lookAt problem&lt;/h1&gt;
&lt;p&gt;We already did some basic normal calculations in previous chapters, and that mostly worked fine. However, there is a problem when we rely too much on a simple &lt;code&gt;lookAt&lt;/code&gt; from &lt;strong&gt;THREE.js&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;The issue is &lt;strong&gt;roll&lt;/strong&gt;, also known as rotation around the Z axis.&lt;/p&gt;
&lt;p&gt;When we use &lt;code&gt;lookAt&lt;/code&gt;, we have to provide an up vector. So far, we have always used &lt;code&gt;(0, 1, 0)&lt;/code&gt;. This works well for gentle slopes, but it starts to break down when the track approaches angles close to 90 degrees.&lt;/p&gt;</description></item><item><title>Bézier curve</title><link>https://ercanakyuerek.de/posts/writing-a-roller-coaster-simulation/bezier-curve/</link><pubDate>Thu, 25 Dec 2025 14:30:00 +0100</pubDate><guid>https://ercanakyuerek.de/posts/writing-a-roller-coaster-simulation/bezier-curve/</guid><description>&lt;div class="embedded float-right"&gt;
 &lt;iframe id="react-root-8873436e814dd8ec92c6e283c073a7c8" width="225px" height="285px" style="border: 0" class="frame"&gt;&lt;/iframe&gt;

 
 &lt;div class="description" style="width: 225px"&gt;
 An interactive example of a Bézier curve, drag the controls around to see changes in shape
 &lt;/div&gt;
 

 &lt;script&gt;
 document.getElementById('react-root-8873436e814dd8ec92c6e283c073a7c8').srcdoc = `
 &lt;!DOCTYPE html&gt;
 &lt;html lang="en" data-theme="dark"&gt;
 &lt;head&gt;
 &lt;base href="${location.origin}/"&gt;
 &lt;/head&gt;
 &lt;body class="content-component"&gt;
 &lt;div id="root" class="full-screen"&gt;&lt;/div&gt;
 \x3Cscript type="module"&gt;
 import { renderContentComponentByPath } from '/scripts/render-content-component.js';
 renderContentComponentByPath('root', '.\/posts\/writing-a-roller-coaster-simulation\/bezier-curve\/BezierCurveExampleScene.tsx');
 &lt;\/script&gt;
 &lt;/body&gt;
 &lt;/html&gt;
 `;
 &lt;/script&gt;
&lt;/div&gt;
&lt;p&gt;So, now it is finally time to build an actual &lt;strong&gt;Bézier curve&lt;/strong&gt; instead of only linear segments.&lt;/p&gt;
&lt;p&gt;I do not think Bézier curves are particularly well suited for hand-building real roller coaster tracks. But they are simple to implement, easy to visualize, and most importantly, they finally give us &lt;em&gt;real curvature&lt;/em&gt; instead of straight lines everywhere. And honestly, we have been staring at straight lines long enough.&lt;/p&gt;</description></item><item><title>Curve Nodes</title><link>https://ercanakyuerek.de/posts/writing-a-roller-coaster-simulation/curve-nodes/</link><pubDate>Sun, 21 Dec 2025 14:30:00 +0100</pubDate><guid>https://ercanakyuerek.de/posts/writing-a-roller-coaster-simulation/curve-nodes/</guid><description>&lt;p&gt;In this chapter, we try to make our lives a bit easier by using a more flexible way to describe &lt;strong&gt;curves&lt;/strong&gt; in general.&lt;/p&gt;
&lt;p&gt;This article is a bit longer than usual. The topic is hard to split into smaller pieces without losing context, so we keep everything in one place. I will try to keep things as simple as possible, but yes, there is a bit going on here.&lt;/p&gt;
&lt;p&gt;Up to this point, everything was built around a very basic &lt;strong&gt;linear track&lt;/strong&gt; with two control points. Functions like &lt;code&gt;matrixAtArcLength&lt;/code&gt; only had to deal with a single segment. That worked fine for learning and experimenting, but it starts to feel limiting very quickly. A real roller coaster does not consist of exactly one straight line.&lt;/p&gt;</description></item><item><title>Matrices</title><link>https://ercanakyuerek.de/posts/writing-a-roller-coaster-simulation/matrices/</link><pubDate>Sun, 21 Dec 2025 13:30:00 +0100</pubDate><guid>https://ercanakyuerek.de/posts/writing-a-roller-coaster-simulation/matrices/</guid><description>&lt;p&gt;Right now, when we want to know the &lt;strong&gt;position&lt;/strong&gt; and &lt;strong&gt;forward direction&lt;/strong&gt; along a curve, we ask two separate functions. This works, but having two separate functions for the same &lt;strong&gt;node&lt;/strong&gt; on the track is odd and adds more complexity than we actually need.&lt;/p&gt;
&lt;p&gt;Earlier we mentioned that there is a better way to describe this kind of information. That better way is a &lt;strong&gt;4x4 matrix&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;A matrix can hold &lt;strong&gt;position&lt;/strong&gt; and &lt;strong&gt;directions&lt;/strong&gt; at the same time. This is exactly what we need to describe a &lt;strong&gt;node&lt;/strong&gt; along the track. Once we switch to &lt;strong&gt;matrices&lt;/strong&gt;, the two existing functions &lt;code&gt;forwardDirectionAtArcLength&lt;/code&gt; and &lt;code&gt;positionAtArcLength&lt;/code&gt; naturally collapse into one. Instead of asking the track for separate pieces of data, we ask for a &lt;strong&gt;matrix&lt;/strong&gt; at a distance along the curve and extract whatever information we need from it.&lt;/p&gt;</description></item><item><title>Friction and Air Resistance</title><link>https://ercanakyuerek.de/posts/writing-a-roller-coaster-simulation/friction-and-air-resistance/</link><pubDate>Sat, 06 Dec 2025 12:30:00 +0100</pubDate><guid>https://ercanakyuerek.de/posts/writing-a-roller-coaster-simulation/friction-and-air-resistance/</guid><description>&lt;p&gt;This chapter will be quite short and introduces two small but important parts of a more realistic roller coaster simulation:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;friction&lt;/li&gt;
&lt;li&gt;air resistance&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Until now, our coaster moved in a world without any energy loss. That works for understanding the basics but real coasters slow down over time. Wheels create friction, air pushes against the train, and both effects reduce the acceleration the train can achieve.&lt;/p&gt;
&lt;p&gt;We will not create a complex physics model. Instead we introduce two simple parameters, very similar to what you may know from &lt;strong&gt;NoLimits Roller Coaster&lt;/strong&gt;.&lt;br&gt;
Our physics simulation should behave almost identically, apart from a few edge cases.&lt;/p&gt;</description></item><item><title>Linear Track</title><link>https://ercanakyuerek.de/posts/writing-a-roller-coaster-simulation/linear-track/</link><pubDate>Sat, 06 Dec 2025 11:30:00 +0100</pubDate><guid>https://ercanakyuerek.de/posts/writing-a-roller-coaster-simulation/linear-track/</guid><description>&lt;p&gt;To visualize motion properly, we need something for our little object to move along. And that means we need a track.&lt;/p&gt;
&lt;p&gt;In this article, we focus on an extremely simplified roller coaster track. And when I say extremely simplified, I really mean it: it&amp;rsquo;s just a plane. A straight line. A first-order curve. Basically the easiest form of track you can possibly build without accidentally creating a real coaster.&lt;/p&gt;
&lt;p&gt;From the last chapter, we know how motion evaluation works. The evaluation function receives an acceleration value and returns a new simulation state containing the updated velocity and the total distance traveled:&lt;/p&gt;</description></item><item><title>Evaluating Motion</title><link>https://ercanakyuerek.de/posts/writing-a-roller-coaster-simulation/evaluating-motion/</link><pubDate>Sat, 06 Dec 2025 10:30:00 +0100</pubDate><guid>https://ercanakyuerek.de/posts/writing-a-roller-coaster-simulation/evaluating-motion/</guid><description>&lt;p&gt;Before we implement the function, there&amp;rsquo;s one small simplification we need to mention:
In this chapter we will always evaluate the motion every &lt;strong&gt;16 ms (0.016 seconds)&lt;/strong&gt;,
which corresponds to roughly &lt;strong&gt;60 frames per second&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Using a fixed time step makes the formulas easier to understand for this article.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: In real simulations or game engines, you usually don’t assume a constant time value. Instead, you take the actual delta time from the game loop, so that the motion stays consistent even if the frame rate changes. &lt;strong&gt;More on that later&lt;/strong&gt;.&lt;/p&gt;</description></item><item><title>Gravity</title><link>https://ercanakyuerek.de/posts/writing-a-roller-coaster-simulation/gravity/</link><pubDate>Sat, 06 Dec 2025 09:30:00 +0100</pubDate><guid>https://ercanakyuerek.de/posts/writing-a-roller-coaster-simulation/gravity/</guid><description>&lt;h2 id="how-do-we-determine-the-acceleration-of-the-coaster"&gt;How do we determine the acceleration of the coaster?&lt;/h2&gt;
&lt;p&gt;To simplify things, we ignore air resistance, rolling friction and any other additional forces. We also assume Earth’s gravity is &lt;strong&gt;9.81 m/s²&lt;/strong&gt;. This allows us to focus entirely on the fundamental idea:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Gravity is the primary source of acceleration.&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;On Earth, gravity provides a constant acceleration of roughly &lt;strong&gt;9.81 m/s²&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;What does this number actually mean?&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Every &lt;strong&gt;second&lt;/strong&gt;, an object&amp;rsquo;s speed increases by &lt;strong&gt;9.81 m/s&lt;/strong&gt;.&lt;/p&gt;</description></item><item><title>Introduction and Motion Dynamics</title><link>https://ercanakyuerek.de/posts/writing-a-roller-coaster-simulation/introduction-and-motion-dynamics/</link><pubDate>Sat, 06 Dec 2025 08:30:00 +0100</pubDate><guid>https://ercanakyuerek.de/posts/writing-a-roller-coaster-simulation/introduction-and-motion-dynamics/</guid><description>&lt;p&gt;You might have played around with JavaScript animations or small physics experiments before, but in this series we are going to take things a step further. We will build a simplified roller coaster simulation directly in the browser.&lt;/p&gt;
&lt;p&gt;My goal here isn’t to build some engineering-grade physics engine. I just want to recreate the kind of coaster &lt;strong&gt;physics&lt;/strong&gt; we all know from things like &lt;strong&gt;NoLimits Roller Coaster or other coasters in games&lt;/strong&gt;.
Nothing overly scientific, just the kind of system that behaves the way we intuitively expect.
In the end, the physics model will end up pretty close to what &lt;strong&gt;NoLimits Roller Coaster&lt;/strong&gt; does anyway, just without all the heavy engineering baggage.&lt;/p&gt;</description></item><item><title>JavaScript module</title><link>https://ercanakyuerek.de/posts/wasi/javascript-module/</link><pubDate>Mon, 27 Feb 2023 17:45:00 +0100</pubDate><guid>https://ercanakyuerek.de/posts/wasi/javascript-module/</guid><description>&lt;p&gt;This is the point where we start writing the &lt;strong&gt;JavaScript&lt;/strong&gt; side of the library that talks to our &lt;strong&gt;WebAssembly&lt;/strong&gt; module.&lt;/p&gt;
&lt;p&gt;At this stage, the WebAssembly part already exists and exposes a couple of useful functions. What we need now is a small JavaScript wrapper that loads the module, wires things together, and gives us a nicer API to work with.&lt;/p&gt;
&lt;p&gt;I have created a very basic template for this. You may notice that we define a number of imports for &lt;strong&gt;WASI&lt;/strong&gt;, but all of them are empty. This looks suspicious at first, so let us talk about that.&lt;/p&gt;</description></item><item><title>Implementing library functions</title><link>https://ercanakyuerek.de/posts/wasi/implementing-library-functions/</link><pubDate>Fri, 24 Feb 2023 00:19:00 +0100</pubDate><guid>https://ercanakyuerek.de/posts/wasi/implementing-library-functions/</guid><description>&lt;div class="embedded float-right"&gt;
 &lt;iframe id="react-root-0282a25a2afe1407b124e965a88668c7" width="225px" height="285px" style="border: 0" class="frame"&gt;&lt;/iframe&gt;

 
 &lt;div class="description" style="width: 225px"&gt;
 Transition from parameter-based non-uniform to uniform node spacing. The control points are draggable.
 &lt;/div&gt;
 

 &lt;script&gt;
 document.getElementById('react-root-0282a25a2afe1407b124e965a88668c7').srcdoc = `
 &lt;!DOCTYPE html&gt;
 &lt;html lang="en" data-theme="dark"&gt;
 &lt;head&gt;
 &lt;base href="${location.origin}/"&gt;
 &lt;/head&gt;
 &lt;body class="content-component"&gt;
 &lt;div id="root" class="full-screen"&gt;&lt;/div&gt;
 \x3Cscript type="module"&gt;
 import { renderContentComponentByPath } from '/scripts/render-content-component.js';
 renderContentComponentByPath('root', '.\/posts\/wasi\/implementing-library-functions\/BezierNodesExampleScene.tsx');
 &lt;\/script&gt;
 &lt;/body&gt;
 &lt;/html&gt;
 `;
 &lt;/script&gt;
&lt;/div&gt;
&lt;p&gt;In this article, we&amp;rsquo;ll be exploring a more interesting example where we&amp;rsquo;ll construct a Bézier curve, evaluate nodes on it, and write a function that gives any position on the curve by a length parameter. To explain briefly, a Bézier curve is represented by a parameter &lt;code&gt;t&lt;/code&gt;, which varies between 0 and 1 and determines the position of nodes on the curve. However, this &lt;code&gt;t&lt;/code&gt; value doesn&amp;rsquo;t produce uniform spacing, which is problematic when we want to evaluate a point on the curve based on its distance. To solve this, we can evaluate some nodes along the curve with known distances and then linearly interpolate new nodes between them to find the point we&amp;rsquo;re looking for.&lt;/p&gt;</description></item><item><title>CMake and build scripts</title><link>https://ercanakyuerek.de/posts/wasi/cmake-and-build-scripts/</link><pubDate>Thu, 23 Feb 2023 23:15:00 +0100</pubDate><guid>https://ercanakyuerek.de/posts/wasi/cmake-and-build-scripts/</guid><description>&lt;p&gt;To simplify the building process, we can create a build script. We have already defined some scripts in our &lt;code&gt;package.json&lt;/code&gt; file. At this point, the &lt;code&gt;build-wasm.js&lt;/code&gt; file is still empty, so we can create a basic script that first deletes an existing &lt;code&gt;build&lt;/code&gt; folder, creates a new one, and runs &lt;code&gt;cmake ..&lt;/code&gt; inside it. We will be using a WASI-SDK docker image from &lt;code&gt;ghcr.io/webassembly/wasi-sdk&lt;/code&gt; to run cmake and eventually compile the project via &lt;code&gt;make&lt;/code&gt;.&lt;/p&gt;</description></item><item><title>Folder structure</title><link>https://ercanakyuerek.de/posts/wasi/folder-structure/</link><pubDate>Thu, 23 Feb 2023 22:00:00 +0100</pubDate><guid>https://ercanakyuerek.de/posts/wasi/folder-structure/</guid><description>&lt;p&gt;You may have already heard that it&amp;rsquo;s possible to write certain parts of your web application using languages like C++ or Rust and compile them into WebAssembly. WebAssembly is a binary format that allows code to be executed on the web and is designed to be efficient, secure, and portable. There are use cases where WebAssembly can be particularly beneficial, such as performing complex and resource-intensive computations for real-time applications or mathematical operations.&lt;/p&gt;</description></item><item><title>About me</title><link>https://ercanakyuerek.de/about/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ercanakyuerek.de/about/</guid><description>&lt;p&gt;
&lt;div class="avatar"&gt;
 &lt;img src="https://ercanakyuerek.de/avatar.jpeg"/&gt;
&lt;/div&gt;
I’m Ercan Akyürek, 34 years old, born and raised in Germany with roots in Turkey. From an early age, I was endlessly curious about how things worked, taking apart toys, motors, and gadgets just to see if I could rebuild them again. That curiosity for understanding and creating has been with me ever since.&lt;/p&gt;
&lt;p&gt;My first real dive into computers came with a VTech learning computer that had a BASIC interpreter. I didn’t know much back then, but I was fascinated by the idea that I could make the machine do something just by typing commands. That curiosity quickly turned into a passion for coding.&lt;/p&gt;</description></item></channel></rss>