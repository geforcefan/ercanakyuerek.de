<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Ercan Akyürek</title><link>https://ercanakyuerek.de/</link><description>Recent content on Ercan Akyürek</description><generator>Hugo</generator><language>en</language><lastBuildDate>Fri, 28 Nov 2025 12:35:00 +0100</lastBuildDate><atom:link href="https://ercanakyuerek.de/index.xml" rel="self" type="application/rss+xml"/><item><title>Writing a Roller Coaster Simulation – Building the Smallest Possible Track</title><link>https://ercanakyuerek.de/posts/writing-a-roller-coaster-simulation/writing-a-roller-coaster-simulation-4/</link><pubDate>Fri, 28 Nov 2025 12:35:00 +0100</pubDate><guid>https://ercanakyuerek.de/posts/writing-a-roller-coaster-simulation/writing-a-roller-coaster-simulation-4/</guid><description>&lt;p>In the last chapter I said we were going to visualize the evaluated motion with a small demo. Technically true, but it was a lie. To visualize motion properly we need something for our object to move on. And that means we need a track. So in this article we’re focusing on a very simplified roller coaster track.&lt;/p>
&lt;p>We’re not building real coaster geometry yet. &lt;strong>No curves, no banking, no roll.&lt;/strong> Just the simplest possible version: a &lt;strong>straight line&lt;/strong> defined by two control points. Start and end. That’s enough to get the idea across.&lt;/p></description></item><item><title>Writing a Roller Coaster Simulation – Evaluating Motion</title><link>https://ercanakyuerek.de/posts/writing-a-roller-coaster-simulation/writing-a-roller-coaster-simulation-3/</link><pubDate>Thu, 27 Nov 2025 12:35:00 +0100</pubDate><guid>https://ercanakyuerek.de/posts/writing-a-roller-coaster-simulation/writing-a-roller-coaster-simulation-3/</guid><description>&lt;h2 id="evaluating-motion">Evaluating Motion&lt;/h2>
&lt;p>Before we implement the function, there&amp;rsquo;s one small simplification we need to mention:
In this chapter we will always evaluate the motion every &lt;strong>16 ms (0.016 seconds)&lt;/strong>,
which corresponds to roughly &lt;strong>60 frames per second&lt;/strong>.&lt;/p>
&lt;p>Using a fixed time step makes the formulas easier to understand for this article.&lt;/p>
&lt;p>In real simulations or game engines, you usually don’t assume a constant value. Instead, you take the actual delta time from the game loop, so that the motion stays consistent even if the frame rate changes.&lt;/p></description></item><item><title>Writing a Roller Coaster Simulation – Determining Acceleration</title><link>https://ercanakyuerek.de/posts/writing-a-roller-coaster-simulation/writing-a-roller-coaster-simulation-2/</link><pubDate>Wed, 26 Nov 2025 12:35:00 +0100</pubDate><guid>https://ercanakyuerek.de/posts/writing-a-roller-coaster-simulation/writing-a-roller-coaster-simulation-2/</guid><description>&lt;h2 id="how-do-we-determine-the-acceleration-of-the-coaster">How do we determine the acceleration of the coaster?&lt;/h2>
&lt;p>To simplify things, we ignore air resistance, rolling friction and any other additional forces. We also assume Earth’s gravity is &lt;strong>9.81 m/s²&lt;/strong>. This allows us to focus entirely on the fundamental idea:&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>Gravity is the primary source of acceleration.&lt;/strong>&lt;/p>
&lt;/blockquote>
&lt;p>On Earth, gravity provides a constant acceleration of &lt;strong>9.81 m/s²&lt;/strong>.&lt;/p>
&lt;p>What does this number actually mean?&lt;/p>
&lt;blockquote>
&lt;p>Every &lt;strong>second&lt;/strong>, an object&amp;rsquo;s speed increases by &lt;strong>9.81 m/s&lt;/strong>.&lt;/p></description></item><item><title>Writing a Roller Coaster Simulation – Introduction and Motion Dynamics</title><link>https://ercanakyuerek.de/posts/writing-a-roller-coaster-simulation/writing-a-roller-coaster-simulation-1/</link><pubDate>Wed, 26 Nov 2025 12:30:00 +0100</pubDate><guid>https://ercanakyuerek.de/posts/writing-a-roller-coaster-simulation/writing-a-roller-coaster-simulation-1/</guid><description>&lt;p>You might have played around with JavaScript animations or small physics experiments before, but in this series we are going to take things a step further. We will build a simplified roller coaster simulation directly in the browser. The goal is not to create a full physics engine or a hyper-realistic coaster model, but to understand the core ideas behind motion, acceleration, track geometry and visual rendering.&lt;/p>
&lt;p>We will use technologies that are easy to access and quick to experiment with. Throughout the series, we will rely on &lt;strong>TypeScript&lt;/strong>, &lt;strong>React&lt;/strong> and &lt;strong>Three.js&lt;/strong>. This combination gives us a clean developer experience and allows us to turn mathematical concepts into visual, interactive 3D scenes with very little overhead.&lt;/p></description></item><item><title>Roller Coaster Simulation - Improved spline interpolation</title><link>https://ercanakyuerek.de/posts/rollercoaster-simulation/improved-spline-interpolation/</link><pubDate>Tue, 07 Mar 2023 00:30:20 +0100</pubDate><guid>https://ercanakyuerek.de/posts/rollercoaster-simulation/improved-spline-interpolation/</guid><description>&lt;p>In the latest update, a number of bugs were discovered, particularly in the precision of floating point calculations when working with a web assembly module in a browser environment. It was found that the jitters mentioned earlier were actually caused by a bug in the roll interpolation process.&lt;/p>
&lt;p>To give a brief overview, track interpolation involves estimating the length of a NURBS track by interpolating with a large step size and evaluating nodes based on the estimated length, resulting in a dense enough interpolation. After this, the normals are calculated and normal angles are applied on the y and x directions but not on the z direction yet, which is essentially the roll. These normals are then applied to the previous matrix and the process continues. A C2 continuous cubic spline is then constructed, and the z angle, which is the result of applying normals in the x and y directions, is applied on each roll point on top of its roll value. The next step is to iterate through all nodes again and apply rotation on the z direction. Finally, to obtain the matrix at any point, we perform a binary search for the minimum and maximum node whose distance lies between the two and interpolate linearly.&lt;/p></description></item><item><title>Writing a Library in C++ and Using it in the Browser with the WASI SDK - JavaScript module</title><link>https://ercanakyuerek.de/posts/wasi/wasi-sdk-writing-library-in-cpp-4/</link><pubDate>Mon, 27 Feb 2023 17:45:00 +0100</pubDate><guid>https://ercanakyuerek.de/posts/wasi/wasi-sdk-writing-library-in-cpp-4/</guid><description>&lt;p>&lt;a href="https://ercanakyuerek.de/posts/wasi/wasi-sdk-writing-library-in-cpp-3/">If you haven&amp;rsquo;t read the third article of this series, I highly recommend that you do so.&lt;/a>&lt;/p>
&lt;p>This is the point where we will develop our &lt;code>JavaScript&lt;/code> library that utilizes the functions exposed in the &lt;code>WebAssembly&lt;/code> module. I have created a simple template for this purpose. You may notice that we are defining some imports for &lt;code>WASI&lt;/code>, but they are all empty. Allow me to explain what &lt;code>WASI&lt;/code> is and what it aims to achieve. &lt;code>WASI&lt;/code> is an attempt to create specifications similar to the &lt;code>POSIX&lt;/code> standard, which can be implemented across different runtimes, such as browsers or regular machines, and provides access to system-specific functions, such as file systems. However, for our library, which only needs to perform calculations, we do not require a complex runtime environment. This is why our functions are empty. Some may argue that we should use the Emscripten SDK instead of the &lt;code>WASI SDK&lt;/code>, but I believe that the &lt;code>WASI SDK&lt;/code> is the future. It produces smaller binaries and has fewer complications compared to &lt;code>Emscripten&lt;/code>. There are official efforts to import standard &lt;code>WASI&lt;/code> functions for the &lt;code>browser&lt;/code>, but unfortunately, they do not seem to work unless a &lt;code>WebAssembly module&lt;/code> is instantiated within a &lt;code>worker&lt;/code>. If there are any changes in the future regarding this matter, I will update my articles accordingly. &lt;a href="https://github.com/wasmerio/wasmer-js">Here&lt;/a> is the mentioned attempt to bring a &lt;code>WASI runtime&lt;/code> to &lt;code>browsers&lt;/code>. If you can load a &lt;code>WASM file&lt;/code> outside the &lt;code>worker&lt;/code>, just email me your solution and I will include it here! &amp;#x1f604;&lt;/p></description></item><item><title>Writing a Library in C++ and Using it in the Browser with the WASI SDK - Implementing library functions</title><link>https://ercanakyuerek.de/posts/wasi/wasi-sdk-writing-library-in-cpp-3/</link><pubDate>Fri, 24 Feb 2023 00:19:00 +0100</pubDate><guid>https://ercanakyuerek.de/posts/wasi/wasi-sdk-writing-library-in-cpp-3/</guid><description>&lt;p>&lt;a href="https://ercanakyuerek.de/posts/wasi/wasi-sdk-writing-library-in-cpp-2/">If you haven&amp;rsquo;t read the second article of this series, I highly recommend that you do so.&lt;/a>&lt;/p>

&lt;iframe src="https://ercanakyuerek.de//wasi-sdk-writing-library-in-cpp/spline.html" class="embedded-iframe">&lt;/iframe>
&lt;p>In this article, we&amp;rsquo;ll be exploring a more interesting example where we&amp;rsquo;ll construct a bezier curve, evaluate nodes on it, and write a function that gives any position on the curve by a length parameter. To explain briefly, a bezier curve is represented by a parameter &lt;code>t&lt;/code>, which varies between 0 and 1 and determines the position of nodes on the curve. However, this &lt;code>t&lt;/code> value doesn&amp;rsquo;t produce uniform spacing, which is problematic when we want to evaluate a point on the curve based on its distance. To solve this, we can evaluate some nodes along the curve with known distances and then linearly interpolate new nodes between them to find the point we&amp;rsquo;re looking for.&lt;/p></description></item><item><title>Writing a Library in C++ and Using it in the Browser with the WASI SDK - CMake and build scripts</title><link>https://ercanakyuerek.de/posts/wasi/wasi-sdk-writing-library-in-cpp-2/</link><pubDate>Thu, 23 Feb 2023 23:15:00 +0100</pubDate><guid>https://ercanakyuerek.de/posts/wasi/wasi-sdk-writing-library-in-cpp-2/</guid><description>&lt;p>&lt;a href="https://ercanakyuerek.de/posts/wasi/wasi-sdk-writing-library-in-cpp-1/">If you haven&amp;rsquo;t read the first article of this series, I highly recommend that you do so.&lt;/a>&lt;/p>
&lt;p>To simplify the building process, we can create a build script. We have already defined some scripts in our &lt;code>package.json&lt;/code> file. At this point, the &lt;code>build-wasm.js&lt;/code> file is still empty, so we can create a basic script that first deletes an existing &lt;code>build&lt;/code> folder, creates a new one, and runs &lt;code>cmake ..&lt;/code> inside it. We will be using a WASI-SDK docker image from &lt;code>ghcr.io/webassembly/wasi-sdk&lt;/code> to run cmake and eventually compile the project via &lt;code>make&lt;/code>.&lt;/p></description></item><item><title>Writing a Library in C++ and Using it in the Browser with the WASI SDK - Folder structure</title><link>https://ercanakyuerek.de/posts/wasi/wasi-sdk-writing-library-in-cpp-1/</link><pubDate>Thu, 23 Feb 2023 22:00:00 +0100</pubDate><guid>https://ercanakyuerek.de/posts/wasi/wasi-sdk-writing-library-in-cpp-1/</guid><description>&lt;p>You may have already heard that it&amp;rsquo;s possible to write certain parts of your web application using languages like C++ or Rust and compile them into WebAssembly. WebAssembly is a binary format that allows code to be executed on the web and is designed to be efficient, secure, and portable. There are use cases where WebAssembly can be particularly beneficial, such as performing complex and resource-intensive computations for real-time applications or mathematical operations.&lt;/p></description></item><item><title>Roller Coaster Simulation - First results</title><link>https://ercanakyuerek.de/posts/rollercoaster-simulation/first-results/</link><pubDate>Thu, 23 Feb 2023 16:28:20 +0100</pubDate><guid>https://ercanakyuerek.de/posts/rollercoaster-simulation/first-results/</guid><description>&lt;p>I am in the process of developing an open source roller coaster simulator that is designed to achieve a high degree of compatibility with NoLimits 2. To this end, I have adopted the same track generation and roll interpolation techniques employed by NoLimits 2. Although there are some bugs associated with loading NoLimits2 Parks at present, I anticipate that these issues will be resolved in due course, as I continue to refine the nl2park loader.&lt;/p></description></item><item><title>About me</title><link>https://ercanakyuerek.de/about/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ercanakyuerek.de/about/</guid><description>&lt;p>
&lt;div class="avatar">
 &lt;img src="https://ercanakyuerek.de/avatar.jpeg"/>
&lt;/div>
I’m Ercan Akyürek, 34 years old, born and raised in Germany with roots in Turkey. From an early age, I was endlessly curious about how things worked, taking apart toys, motors, and gadgets just to see if I could rebuild them again. That curiosity for understanding and creating has been with me ever since.&lt;/p>
&lt;p>My first real dive into computers came with a VTech learning computer that had a BASIC interpreter. I didn’t know much back then, but I was fascinated by the idea that I could make the machine do something just by typing commands. That simple curiosity quickly turned into a passion for coding.&lt;/p></description></item></channel></rss>