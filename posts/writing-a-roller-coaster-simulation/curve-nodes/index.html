<!doctype html><html lang=en><head><meta charset=UTF-8><meta http-equiv=X-UA-Compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=author content><meta name=description content="In this chapter, we try to make our lives a bit easier by using a more flexible way to describe curves in general.
This article is a bit longer than usual. The topic is hard to split into smaller pieces without losing context, so we keep everything in one place. I will try to keep things as simple as possible, but yes, there is a bit going on here.
Up to this point, everything was built around a very basic linear track with two control points. Functions like transformationAtArcLength only had to deal with a single segment. That worked fine for learning and experimenting, but it starts to feel limiting very quickly. A real roller coaster does not consist of exactly one straight line.
"><meta name=keywords content="homepage,blog,writing a roller coaster simulation"><meta name=robots content="noodp"><meta name=theme-color content><link rel=canonical href=https://ercanakyuerek.de/posts/writing-a-roller-coaster-simulation/curve-nodes/><title>Curve Nodes :: Ercan Akyürek</title><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/flag-icon-css/3.5.0/css/flag-icon.min.css integrity="sha512-Cv93isQdFwaKBV+Z4X8kaVBYWHST58Xb/jVOcV9aRsGSArZsgAnFIhMpDoMDcFNoUtday1hdjn0nGp3+KZyyFw==" crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=/main.14b819624c3fc7cddd32f4d8dedcfbbc021742fa0527e486d77d85772220b4ec.css integrity="sha256-FLgZYkw/x83dMvTY3tz7vAIXQvoFJ+SG132FdyIgtOw="><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color><link rel="shortcut icon" href=/favicon.ico><meta name=msapplication-TileColor content><meta itemprop=name content="Curve Nodes"><meta itemprop=description content="In this chapter, we try to make our lives a bit easier by using a more flexible way to describe curves in general.
This article is a bit longer than usual. The topic is hard to split into smaller pieces without losing context, so we keep everything in one place. I will try to keep things as simple as possible, but yes, there is a bit going on here.
Up to this point, everything was built around a very basic linear track with two control points. Functions like transformationAtArcLength only had to deal with a single segment. That worked fine for learning and experimenting, but it starts to feel limiting very quickly. A real roller coaster does not consist of exactly one straight line."><meta itemprop=datePublished content="2025-12-21T14:30:00+01:00"><meta itemprop=dateModified content="2025-12-21T14:30:00+01:00"><meta itemprop=wordCount content="2257"><meta itemprop=keywords content="Writing a Roller Coaster Simulation"><meta name=twitter:card content="summary"><meta name=twitter:title content="Curve Nodes"><meta name=twitter:description content="In this chapter, we try to make our lives a bit easier by using a more flexible way to describe curves in general.
This article is a bit longer than usual. The topic is hard to split into smaller pieces without losing context, so we keep everything in one place. I will try to keep things as simple as possible, but yes, there is a bit going on here.
Up to this point, everything was built around a very basic linear track with two control points. Functions like transformationAtArcLength only had to deal with a single segment. That worked fine for learning and experimenting, but it starts to feel limiting very quickly. A real roller coaster does not consist of exactly one straight line."><meta property="og:url" content="https://ercanakyuerek.de/posts/writing-a-roller-coaster-simulation/curve-nodes/"><meta property="og:site_name" content="Ercan Akyürek"><meta property="og:title" content="Curve Nodes"><meta property="og:description" content="In this chapter, we try to make our lives a bit easier by using a more flexible way to describe curves in general.
This article is a bit longer than usual. The topic is hard to split into smaller pieces without losing context, so we keep everything in one place. I will try to keep things as simple as possible, but yes, there is a bit going on here.
Up to this point, everything was built around a very basic linear track with two control points. Functions like transformationAtArcLength only had to deal with a single segment. That worked fine for learning and experimenting, but it starts to feel limiting very quickly. A real roller coaster does not consist of exactly one straight line."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-12-21T14:30:00+01:00"><meta property="article:modified_time" content="2025-12-21T14:30:00+01:00"><meta property="article:tag" content="Writing a Roller Coaster Simulation"><meta property="article:published_time" content="2025-12-21 14:30:00 +0100 +0100"><script async src="https://www.googletagmanager.com/gtag/js?id=G-WCX2MRFT7Z"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-WCX2MRFT7Z")}</script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@4/tex-mml-chtml.js></script><script>MathJax={tex:{displayMath:[["\\[","\\]"],["$$","$$"]],inlineMath:[["\\(","\\)"]]},loader:{load:["ui/safe"]}}</script></head><body><div class=container><header class=header><span class=header__inner><a href=/ style=text-decoration:none><div class=logo><span class=logo__mark>></span>
<span class=logo__text>ercanakyuerek.de</span>
<span class=logo__cursor></span></div></a><span class=header__right><nav class=menu><ul class=menu__inner><li><a href=/about>About me</a></li><li><a href=/posts>Posts</a></li></ul></nav><span class=menu-trigger><svg viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg></span></span></span></header><div class=content><main class=post><div class=post-info><p><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-clock"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>
11 minutes</p></div><article><h1 class=post-title><a href=https://ercanakyuerek.de/posts/writing-a-roller-coaster-simulation/curve-nodes/>Curve Nodes</a></h1><div class=post-content><p>In this chapter, we try to make our lives a bit easier by using a more
flexible way to describe <strong>curves</strong> in general.</p><p>This article is a bit longer than usual. The topic is hard to split
into smaller pieces without losing context, so we keep everything in
one place. I will try to keep things as simple as possible, but yes,
there is a bit going on here.</p><p>Up to this point, everything was built around a very basic <strong>linear
track</strong> with two control points. Functions like
<code>transformationAtArcLength</code> only had to deal with a single segment.
That worked fine for learning and experimenting, but it starts to feel
limiting very quickly. A real roller coaster does not consist of
exactly one straight line.</p><p>For now, we do not jump straight to <strong>NURBS</strong> or anything fancy. That
will come later. We just want more segments. To do that, we need a way
to describe curves that is not tied to a specific curve type, whether
that is linear tracks, splines, geometric sections.</p><p>The solution is a very basic concept called <strong>curve nodes</strong>. A curve
node stores where it is in <strong>space</strong>, its <strong>orientation</strong> as a <strong>4x4
transformation matrix</strong>, and the <strong>arc length</strong> at which it appears
along the curve. Nothing more than that.</p><h1 id=curve-node>Curve Node</h1><p>Before we write any code, we need to understand the idea first.</p><p>Imagine a linear track defined by four points. In that case, we also
have four nodes. Nothing surprising so far. If we want to know the
<strong>position</strong> at a certain distance along the track, we search for the
two nodes between which that distance lies. One node on the left, one
on the right. Everything in between is just interpolation.</p><p>This can be hard to visualize just by reading, so the example below
shows four points and a slider. You can also move the control points
to see what happens when the requested distance overshoots a segment.</p><div class=embedded><iframe id=react-root-26871a7a859fffa7685e4d5d2a33d876 width=100% height=260px class=frame></iframe><div class=description style=width:100%>As you move the slider, you request a distance along the track. You can immediately see between which two nodes that distance is sandwiched.</div><script>document.getElementById("react-root-26871a7a859fffa7685e4d5d2a33d876").srcdoc=`
    <!DOCTYPE html>
    <html lang="en" data-theme="dark">
      <head>
          <base href="${location.origin}/">
      </head>
        <body class="content-component">
        <div id="root" class="full-screen"></div>
        <script type="module">
          import { renderContentComponentByPath } from '/scripts/render-content-component.js';
          renderContentComponentByPath('root', './posts/writing-a-roller-coaster-simulation/curve-nodes/BinarySearchDemoScene.tsx');
        <\/script>
      </body>
    </html>
  `</script></div><h1 id=find-nodes-sandwiching-the-requested-distance>Find nodes sandwiching the requested distance</h1><p>In the example above, we look for the two nodes that sandwich the
requested distance and then linearly interpolate the <strong>position</strong>
between them.</p><p>You may notice that, in principle, we can build almost any curve
geometry this way. <strong>NURBS</strong>, for example, are basically just straight
lines following a curve with many, many nodes. Compared to the simple
example above, they are much denser, but the idea is exactly the same.
More nodes, same logic.</p><p><strong>Curve nodes</strong> form a clean and agnostic <strong>interface</strong> between the
physics simulation and the actual curve geometry. The simulation does
not really care how the curve was created. It just asks for matrices
and keeps going.</p><p>With that in mind, we can start by defining what a <strong>curve node</strong>
looks like:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>CurveNode</span> <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>transformation</span>: <span style=color:#66d9ef>Matrix4</span>;
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>arcLength</span>: <span style=color:#66d9ef>number</span>;
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>segmentIndex</span>: <span style=color:#66d9ef>number</span>;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>That is it. A <strong>transformation matrix</strong>, its <strong>distance</strong>, and the
<strong>segment number</strong> along the curve. The segment number will not matter
much for now, but it will become important later.</p><p>Of course, nodes do not exist on their own. They have to belong to
something, and that something is the <strong>curve</strong> itself. To make this
explicit, we also introduce a <strong>Curve</strong> type that groups the nodes
together.</p><p>The <strong>Curve</strong> type looks like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Curve</span> <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>nodes</span>: <span style=color:#66d9ef>CurveNode</span>[];
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>segmentOffsets</span>: <span style=color:#66d9ef>number</span>[];
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><blockquote><p><strong>Note:</strong> The curve also stores <strong>segment offsets</strong>, which are
accumulated <strong>arc lengths</strong> of the segments. They are not important
right now. For the moment, we only deal with a single segment, so
this will just be <code>[0, totalArcLength]</code>. We will come back to this
later.</p></blockquote><p>To go along with this, we add a small helper that simply creates an
empty curve:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>emptyCurve</span> <span style=color:#f92672>=</span> (
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>nodes</span>: <span style=color:#66d9ef>CurveNode</span>[] <span style=color:#f92672>=</span> [],
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>segmentOffsets</span>: <span style=color:#66d9ef>number</span>[] <span style=color:#f92672>=</span> [<span style=color:#ae81ff>0</span>],
</span></span><span style=display:flex><span>)<span style=color:#f92672>:</span> <span style=color:#a6e22e>Curve</span> <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>nodes</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>segmentOffsets</span>,
</span></span><span style=display:flex><span>  };
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>Next, we need a way to find the two nodes that sandwich any requested
distance along the curve. There are many algorithms for this, but a
simple binary search works very well here. It is fast, easy to
implement, and more than good enough for what we need right now.</p><p>The only real requirement is that the nodes are sorted by <code>arcLength</code>,
which we will make sure of.</p><p>If you want, you can read more about
<a href=https://en.wikipedia.org/wiki/Binary_search>binary search</a>. To be
honest, you do not need to understand every detail here.</p><p>We use a lower-bound variant of binary search, which looks like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>lowerBound</span> <span style=color:#f92672>=</span> &lt;<span style=color:#f92672>T</span>&gt;(
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>array</span>: <span style=color:#66d9ef>T</span>[],
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>value</span>: <span style=color:#66d9ef>number</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>accessor</span><span style=color:#f92672>:</span> (<span style=color:#a6e22e>item</span>: <span style=color:#66d9ef>T</span>, <span style=color:#a6e22e>index</span>: <span style=color:#66d9ef>number</span>) <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>number</span>,
</span></span><span style=display:flex><span>)<span style=color:#f92672>:</span> <span style=color:#66d9ef>number</span> <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>first</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>len</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>array</span>.<span style=color:#a6e22e>length</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>while</span> (<span style=color:#a6e22e>len</span> <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>half</span> <span style=color:#f92672>=</span> Math.<span style=color:#a6e22e>floor</span>(<span style=color:#a6e22e>len</span> <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>middle</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>first</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>half</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>accessor</span>(<span style=color:#a6e22e>array</span>[<span style=color:#a6e22e>middle</span>], <span style=color:#a6e22e>middle</span>) <span style=color:#f92672>&lt;</span> <span style=color:#a6e22e>value</span>) {
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>first</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>middle</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>len</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>len</span> <span style=color:#f92672>-</span> <span style=color:#a6e22e>half</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>len</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>half</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>first</span>;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>Now we use this binary search to find the node indices between which a
requested distance along the curve lies. For that, we write a small
helper:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>findBoundingIndices</span> <span style=color:#f92672>=</span> &lt;<span style=color:#f92672>T</span>&gt;(
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>array</span>: <span style=color:#66d9ef>T</span>[],
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>value</span>: <span style=color:#66d9ef>number</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>accessor</span><span style=color:#f92672>:</span> (<span style=color:#a6e22e>item</span>: <span style=color:#66d9ef>T</span>, <span style=color:#a6e22e>index</span>: <span style=color:#66d9ef>number</span>) <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>number</span>,
</span></span><span style=display:flex><span>) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>array</span>.<span style=color:#a6e22e>length</span> <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>2</span>) <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>lowerNodeIndex</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>lowerBound</span>(<span style=color:#a6e22e>array</span>, <span style=color:#a6e22e>value</span>, <span style=color:#a6e22e>accessor</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>rightNodeIndex</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>MathUtils</span>.<span style=color:#a6e22e>clamp</span>(
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>lowerNodeIndex</span>,
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>1</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>array</span>.<span style=color:#a6e22e>length</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>,
</span></span><span style=display:flex><span>  );
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>leftNodeIndex</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>rightNodeIndex</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> [<span style=color:#a6e22e>leftNodeIndex</span>, <span style=color:#a6e22e>rightNodeIndex</span>];
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>This function needs a bit of explanation.</p><p>First, a small sanity check. Searching for a distance <strong>between</strong>
nodes only makes sense if we actually have at least two nodes.
Anything else would be suspicious:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>array</span>.<span style=color:#a6e22e>length</span> <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>2</span>) <span style=color:#66d9ef>return</span>;
</span></span></code></pre></div><p>After that, we do the binary search. The lower-bound search gives us
the index of the first node whose distance is <strong>greater than or
equal</strong> to the value we ask for.</p><p>A small concrete example helps here. Assume we have these node
distances:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>[0, 10, 20, 30, 40]
</span></span></code></pre></div><p>If we request a distance:</p><ul><li><strong>10</strong> → we get index <code>1</code>, because <code>10</code> exists exactly at index <code>1</code></li><li><strong>0</strong> → we get index <code>0</code>, because the first node already matches</li><li><strong>15</strong> → we get index <code>2</code>, because <code>20</code> is the first value greater
than <code>15</code></li><li><strong>45</strong> → we get index <code>5</code>, which is past the last node. That is why
clamping exists.</li></ul><p>In all cases, the returned index represents the <strong>right</strong> node of the
sandwich:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>lowerNodeIndex</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>lowerBound</span>(<span style=color:#a6e22e>array</span>, <span style=color:#a6e22e>value</span>, <span style=color:#a6e22e>accessor</span>);
</span></span></code></pre></div><p>Since the <strong>left node index</strong> is always the <strong>right node index minus
one</strong>, we need to be careful with bounds.</p><p>We clamp the <strong>right node index</strong> to the range <code>1</code> to
<code>array.length - 1</code>, because a <strong>right</strong> node cannot be the <strong>first</strong>
node of the curve.</p><p>This guarantees that the <strong>left node index</strong> is always valid, and that
the <strong>right node index</strong> never goes past the end of the array:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>rightNodeIndex</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>MathUtils</span>.<span style=color:#a6e22e>clamp</span>(
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>lowerNodeIndex</span>,
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>1</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>array</span>.<span style=color:#a6e22e>length</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>,
</span></span><span style=display:flex><span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>leftNodeIndex</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>rightNodeIndex</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>;
</span></span></code></pre></div><p>Finally, we return the two indices that sandwich the requested
distance:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>return</span> [<span style=color:#a6e22e>leftNodeIndex</span>, <span style=color:#a6e22e>rightNodeIndex</span>];
</span></span></code></pre></div><p>This is exactly what you were already seeing in the interactive
example at the beginning of the chapter, just written down in code
form.</p><h1 id=interpolate-between-curve-nodes>Interpolate between curve nodes</h1><p>Now we move on to the more interesting part: <strong>interpolation between
the left and right curve nodes</strong>.</p><p>To find the <strong>left and right nodes</strong>, we use the <strong>binary search
helper</strong> we just built:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>nodes</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>findBoundingIndices</span>(
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>curve</span>.<span style=color:#a6e22e>nodes</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>at</span>,
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>node</span>) <span style=color:#f92672>=&gt;</span> <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>arcLength</span>,
</span></span><span style=display:flex><span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span><span style=color:#a6e22e>nodes</span>) <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Matrix4</span>();
</span></span></code></pre></div><blockquote><p><strong>Note:</strong> Returning an empty matrix here is just a lazy safety
check. Architecture wise this may or may not be great, but that is
not the point right now. We will clean this up later. Or not.
Depends on future us.</p></blockquote><p>Once we have the indices, we fetch the actual nodes:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>left</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>curve</span>.<span style=color:#a6e22e>nodes</span>[<span style=color:#a6e22e>nodes</span>[<span style=color:#ae81ff>0</span>]];
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>right</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>curve</span>.<span style=color:#a6e22e>nodes</span>[<span style=color:#a6e22e>nodes</span>[<span style=color:#ae81ff>1</span>]];
</span></span></code></pre></div><p>Lets now prepare for interpolation between the found nodes. Assume we
have the following node distances: <code>[0, 10, 30, 50, 60]</code></p><p>If we request <code>20</code>, it is clearly sandwiched between <code>10</code> and <code>30</code>. No
surprises there. For linear interpolation, we need to know <em>how far</em>
<code>20</code> lies between those two values.</p><p>We do this step by step. Nothing fancy:</p><ul><li>Distance between <strong>left</strong> and <strong>right</strong> node: <code>30 - 10 = 20</code></li><li>Distance from <strong>left</strong> node to requested distance: <code>20 - 10 = 10</code></li><li><code>10 / 20 = 0.5</code>, so we are <strong>50%</strong> between the two nodes</li></ul><p>For safety, we clamp this value between <code>0</code> and <code>1</code>, because values
outside that range are rarely what we want.</p><blockquote><p><strong>Note:</strong> If the distance between left and right node is <code>0</code>, we
would divide by zero. That usually ends badly. In that case, there
is nothing to interpolate anyway, so we just return one of the
matrices and move on with our lives.</p></blockquote><p>In code, this looks like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>length</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>right</span>.<span style=color:#a6e22e>arcLength</span> <span style=color:#f92672>-</span> <span style=color:#a6e22e>left</span>.<span style=color:#a6e22e>arcLength</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>length</span> <span style=color:#f92672>&gt;</span> Number.<span style=color:#a6e22e>EPSILON</span>) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>t</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>MathUtils</span>.<span style=color:#a6e22e>clamp</span>((<span style=color:#a6e22e>at</span> <span style=color:#f92672>-</span> <span style=color:#a6e22e>left</span>.<span style=color:#a6e22e>arcLength</span>) <span style=color:#f92672>/</span> <span style=color:#a6e22e>length</span>, <span style=color:#ae81ff>0.0</span>, <span style=color:#ae81ff>1.0</span>);
</span></span><span style=display:flex><span>  <span style=color:#75715e>// ...interpolation between left and right node goes here
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>We need a small utility function that interpolates between two
matrices.</p><p>Unfortunately, there is no built-in helper for this in <strong>THREE.js</strong>.
<strong>THREE.js</strong> does have helpers to interpolate <strong>vectors</strong> and
<strong>quaternions</strong> though, which is exactly what we need here.</p><p>A transformation matrix contains position and rotation. We extract
those parts, interpolate them separately, and then build a new
transformation matrix again. <strong>Position</strong> is interpolated
<strong>linearly</strong>. <strong>Rotation</strong> is interpolated using <strong>spherical linear
interpolation</strong> on <strong>quaternions</strong>.</p><p>If you already know what <strong>quaternions</strong> are, great. If not, also
fine. This is not important at this point. I will write dedicated
articles about <strong>vectors, matrices, euler and quaternions</strong> later.</p><p>The helper looks like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>lerp</span> <span style=color:#f92672>=</span> (
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>matrixA</span>: <span style=color:#66d9ef>Matrix4</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>matrixB</span>: <span style=color:#66d9ef>Matrix4</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>t</span>: <span style=color:#66d9ef>number</span>,
</span></span><span style=display:flex><span>) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>fromQuaternion</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Quaternion</span>();
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>toQuaternion</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Quaternion</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>fromPosition</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Vector3</span>();
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>toPosition</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Vector3</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>scale</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Vector3</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>matrixA</span>.<span style=color:#a6e22e>decompose</span>(<span style=color:#a6e22e>fromPosition</span>, <span style=color:#a6e22e>fromQuaternion</span>, <span style=color:#a6e22e>scale</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>matrixB</span>.<span style=color:#a6e22e>decompose</span>(<span style=color:#a6e22e>toPosition</span>, <span style=color:#a6e22e>toQuaternion</span>, <span style=color:#a6e22e>scale</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Matrix4</span>().<span style=color:#a6e22e>compose</span>(
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fromPosition</span>.<span style=color:#a6e22e>clone</span>().<span style=color:#a6e22e>lerp</span>(<span style=color:#a6e22e>toPosition</span>, <span style=color:#a6e22e>t</span>),
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fromQuaternion</span>.<span style=color:#a6e22e>slerp</span>(<span style=color:#a6e22e>toQuaternion</span>, <span style=color:#a6e22e>t</span>),
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>scale</span>,
</span></span><span style=display:flex><span>  );
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>Now we can use this to interpolate between the <strong>left</strong> and <strong>right</strong>
matrix:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>return</span> <span style=color:#a6e22e>lerp</span>(<span style=color:#a6e22e>left</span>.<span style=color:#a6e22e>matrix</span>, <span style=color:#a6e22e>right</span>.<span style=color:#a6e22e>matrix</span>, <span style=color:#a6e22e>t</span>);
</span></span></code></pre></div><p>If the distance between the nodes is <code>0</code>, things are easy. We just
return a copy of the left node’s matrix:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>return</span> <span style=color:#a6e22e>left</span>.<span style=color:#a6e22e>matrix</span>.<span style=color:#a6e22e>clone</span>();
</span></span></code></pre></div><p>Putting everything together, the full function looks like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>transformationAtArcLength</span> <span style=color:#f92672>=</span> (
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>curve</span>: <span style=color:#66d9ef>Curve</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>at</span>: <span style=color:#66d9ef>number</span>,
</span></span><span style=display:flex><span>) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>nodes</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>findBoundingIndices</span>(
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>curve</span>.<span style=color:#a6e22e>nodes</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>at</span>,
</span></span><span style=display:flex><span>    (<span style=color:#a6e22e>node</span>) <span style=color:#f92672>=&gt;</span> <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>arcLength</span>,
</span></span><span style=display:flex><span>  );
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span><span style=color:#a6e22e>nodes</span>) <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Matrix4</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>left</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>curve</span>.<span style=color:#a6e22e>nodes</span>[<span style=color:#a6e22e>nodes</span>[<span style=color:#ae81ff>0</span>]];
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>right</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>curve</span>.<span style=color:#a6e22e>nodes</span>[<span style=color:#a6e22e>nodes</span>[<span style=color:#ae81ff>1</span>]];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>length</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>right</span>.<span style=color:#a6e22e>arcLength</span> <span style=color:#f92672>-</span> <span style=color:#a6e22e>left</span>.<span style=color:#a6e22e>arcLength</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>length</span> <span style=color:#f92672>&gt;</span> Number.<span style=color:#a6e22e>EPSILON</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>t</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>MathUtils</span>.<span style=color:#a6e22e>clamp</span>(
</span></span><span style=display:flex><span>      (<span style=color:#a6e22e>at</span> <span style=color:#f92672>-</span> <span style=color:#a6e22e>left</span>.<span style=color:#a6e22e>arcLength</span>) <span style=color:#f92672>/</span> <span style=color:#a6e22e>length</span>,
</span></span><span style=display:flex><span>      <span style=color:#ae81ff>0.0</span>,
</span></span><span style=display:flex><span>      <span style=color:#ae81ff>1.0</span>,
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>lerp</span>(<span style=color:#a6e22e>left</span>.<span style=color:#a6e22e>transformation</span>, <span style=color:#a6e22e>right</span>.<span style=color:#a6e22e>transformation</span>, <span style=color:#a6e22e>t</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>left</span>.<span style=color:#a6e22e>transformation</span>.<span style=color:#a6e22e>clone</span>();
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h1 id=linear-track-with-more-segments>Linear track with more segments</h1><p>To actually see this in motion, we need a small helper that constructs
curve nodes from a list of points. This is only here to make the demo
work and will be improved later.</p><blockquote><p><strong>Note</strong>: Points are duplicated to create hard transitions between
segments. For linear track segments, smooth rotation transitions do
not really make sense physically. Duplicating points is an easy way
to fake the behavior we want.</p><p><strong>Important</strong>: This is temporary junk. It exists only to make the
demo work quickly and will be replaced by a proper implementation
with correct normals and roll handling.</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>fromPoints</span> <span style=color:#f92672>=</span> (<span style=color:#a6e22e>points</span>: <span style=color:#66d9ef>Vector3</span>[]) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>curve</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>emptyCurve</span>();
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>points</span>.<span style=color:#a6e22e>length</span> <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>2</span>) <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>curve</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>arcLength</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> <span style=color:#f92672>&lt;</span> <span style=color:#a6e22e>points</span>.<span style=color:#a6e22e>length</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>left</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>points</span>[<span style=color:#a6e22e>i</span>];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>right</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>points</span>[<span style=color:#a6e22e>i</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>prevNode</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>curve</span>.<span style=color:#a6e22e>nodes</span>[<span style=color:#a6e22e>curve</span>.<span style=color:#a6e22e>nodes</span>.<span style=color:#a6e22e>length</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>prevNode</span>)
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>curve</span>.<span style=color:#a6e22e>nodes</span>.<span style=color:#a6e22e>push</span>({
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>transformation</span>: <span style=color:#66d9ef>prevNode.transformation</span>
</span></span><span style=display:flex><span>          .<span style=color:#a6e22e>clone</span>()
</span></span><span style=display:flex><span>          .<span style=color:#a6e22e>setPosition</span>(<span style=color:#a6e22e>left</span>),
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>arcLength</span>,
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>segmentIndex</span>: <span style=color:#66d9ef>0</span>,
</span></span><span style=display:flex><span>      });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>curve</span>.<span style=color:#a6e22e>nodes</span>.<span style=color:#a6e22e>push</span>({
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>transformation</span>: <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Matrix4</span>()
</span></span><span style=display:flex><span>        .<span style=color:#a6e22e>lookAt</span>(<span style=color:#a6e22e>right</span>, <span style=color:#a6e22e>left</span>, <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Vector3</span>(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>))
</span></span><span style=display:flex><span>        .<span style=color:#a6e22e>setPosition</span>(<span style=color:#a6e22e>left</span>),
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>arcLength</span>,
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>segmentIndex</span>: <span style=color:#66d9ef>0</span>,
</span></span><span style=display:flex><span>    });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>arcLength</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>left</span>.<span style=color:#a6e22e>distanceTo</span>(<span style=color:#a6e22e>right</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>lastNode</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>last</span>(<span style=color:#a6e22e>curve</span>.<span style=color:#a6e22e>nodes</span>)<span style=color:#f92672>!</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>lastPoint</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>last</span>(<span style=color:#a6e22e>points</span>)<span style=color:#f92672>!</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>curve</span>.<span style=color:#a6e22e>nodes</span>.<span style=color:#a6e22e>push</span>({
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>transformation</span>: <span style=color:#66d9ef>lastNode.transformation</span>
</span></span><span style=display:flex><span>      .<span style=color:#a6e22e>clone</span>()
</span></span><span style=display:flex><span>      .<span style=color:#a6e22e>setPosition</span>(<span style=color:#a6e22e>lastPoint</span>),
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>arcLength</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>segmentIndex</span>: <span style=color:#66d9ef>0</span>,
</span></span><span style=display:flex><span>  });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>curve</span>.<span style=color:#a6e22e>segmentOffsets</span>.<span style=color:#a6e22e>push</span>(<span style=color:#a6e22e>arcLength</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>curve</span>;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>This helper just turns points into curve nodes and keeps track of the
distance along the curve. It is very naive, but good enough to
demonstrate the idea.</p><h2 id=what-comes-next>What comes next?</h2><p>In the next chapter, we will build curve nodes from <strong>Bezier
splines</strong>. The nice part is that we will not have to touch the
simulation logic at all. Only the curve generation changes, which is
exactly what we were aiming for from the beginning.</p><h2 id=demo-with-linear-track-segments>Demo with linear track segments</h2><div class=embedded><iframe id=react-root-52bcb5bdc7d7fe01062fa8d1f2b89c9a width=100% height=380px class=frame></iframe><div class=description style=width:100%>Move the control points around to get a feeling for building a roller coaster track with physics motion.</div><script>document.getElementById("react-root-52bcb5bdc7d7fe01062fa8d1f2b89c9a").srcdoc=`
    <!DOCTYPE html>
    <html lang="en" data-theme="dark">
      <head>
          <base href="${location.origin}/">
      </head>
        <body class="content-component">
        <div id="root" class="full-screen"></div>
        <script type="module">
          import { renderContentComponentByPath } from '/scripts/render-content-component.js';
          renderContentComponentByPath('root', './posts/writing-a-roller-coaster-simulation/curve-nodes/MotionEvaluationDemoScene.tsx');
        <\/script>
      </body>
    </html>
  `</script></div><h1 id=demo-code>Demo code</h1><p>If you want to run the code locally, clone this
<a href=https://github.com/geforcefan/ercanakyuerek.de target=_blank>repository</a>,
run <code>npm install</code> and <code>npm run dev-scripts</code>,
then open this
<a href=http://localhost:3000/src/content/posts/writing-a-roller-coaster-simulation/curve-nodes/MotionEvaluationDemoScene.tsx target=_blank>link</a>
in your browser.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-tsx data-lang=tsx><span style=display:flex><span><span style=color:#66d9ef>import</span> <span style=color:#a6e22e>React</span>, { <span style=color:#a6e22e>useMemo</span>, <span style=color:#a6e22e>useState</span> } <span style=color:#66d9ef>from</span> <span style=color:#e6db74>&#39;react&#39;</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>import</span> { <span style=color:#a6e22e>Line</span> } <span style=color:#66d9ef>from</span> <span style=color:#e6db74>&#39;@react-three/drei&#39;</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>import</span> { <span style=color:#a6e22e>Vector3</span> } <span style=color:#66d9ef>from</span> <span style=color:#e6db74>&#39;three&#39;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>import</span> { <span style=color:#a6e22e>useColors</span> } <span style=color:#66d9ef>from</span> <span style=color:#e6db74>&#39;../../../../hooks/useColors&#39;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>import</span> { <span style=color:#a6e22e>CurveWireframe</span> } <span style=color:#66d9ef>from</span> <span style=color:#e6db74>&#39;../../../../components/curve/CurveWireframe&#39;</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>import</span> { <span style=color:#a6e22e>DragControlPoints</span> } <span style=color:#66d9ef>from</span> <span style=color:#e6db74>&#39;../../../../components/curve/DragControlPoints&#39;</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>import</span> { <span style=color:#a6e22e>Ground</span> } <span style=color:#66d9ef>from</span> <span style=color:#e6db74>&#39;../../../../components/Ground&#39;</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>import</span> { <span style=color:#a6e22e>EditorScene</span> } <span style=color:#66d9ef>from</span> <span style=color:#e6db74>&#39;../../../../components/scenes/EditorScene&#39;</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>import</span> { <span style=color:#a6e22e>TrainWithPhysics</span> } <span style=color:#66d9ef>from</span> <span style=color:#e6db74>&#39;../../../../components/TrainWithPhysics&#39;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>import</span> { <span style=color:#a6e22e>fromPoints</span> } <span style=color:#66d9ef>from</span> <span style=color:#e6db74>&#39;./curve&#39;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>wireFrameParts</span> <span style=color:#f92672>=</span> [<span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Vector3</span>(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>), <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Vector3</span>(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>)];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>MotionEvaluationDemoScene</span> <span style=color:#f92672>=</span> () <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>colors</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>useColors</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> [<span style=color:#a6e22e>points</span>, <span style=color:#a6e22e>setPoints</span>] <span style=color:#f92672>=</span> <span style=color:#a6e22e>useState</span>([
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Vector3</span>(<span style=color:#f92672>-</span><span style=color:#ae81ff>11.5</span>, <span style=color:#ae81ff>2.5</span>, <span style=color:#ae81ff>0</span>),
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Vector3</span>(<span style=color:#f92672>-</span><span style=color:#ae81ff>10</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>0.75</span>, <span style=color:#ae81ff>0</span>),
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Vector3</span>(<span style=color:#f92672>-</span><span style=color:#ae81ff>7.5</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>0</span>),
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Vector3</span>(<span style=color:#f92672>-</span><span style=color:#ae81ff>5</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>),
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Vector3</span>(<span style=color:#f92672>-</span><span style=color:#ae81ff>3</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>),
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Vector3</span>(<span style=color:#f92672>-</span><span style=color:#ae81ff>0.5</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>2.5</span>, <span style=color:#ae81ff>0</span>),
</span></span><span style=display:flex><span>  ]);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>curve</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>useMemo</span>(() <span style=color:#f92672>=&gt;</span> <span style=color:#a6e22e>fromPoints</span>(<span style=color:#a6e22e>points</span>), [<span style=color:#a6e22e>points</span>]);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> (
</span></span><span style=display:flex><span>    &lt;<span style=color:#f92672>EditorScene</span>&gt;
</span></span><span style=display:flex><span>      &lt;<span style=color:#f92672>DragControlPoints</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>axisLock</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;z&#34;</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>points</span><span style=color:#f92672>=</span>{<span style=color:#a6e22e>points</span>}
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>setPoints</span><span style=color:#f92672>=</span>{<span style=color:#a6e22e>setPoints</span>}
</span></span><span style=display:flex><span>      /&gt;
</span></span><span style=display:flex><span>      &lt;<span style=color:#f92672>CurveWireframe</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>rails</span><span style=color:#f92672>=</span>{<span style=color:#a6e22e>wireFrameParts</span>}
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>tie</span><span style=color:#f92672>=</span>{<span style=color:#a6e22e>wireFrameParts</span>}
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>curve</span><span style=color:#f92672>=</span>{<span style=color:#a6e22e>curve</span>}
</span></span><span style=display:flex><span>      /&gt;
</span></span><span style=display:flex><span>      &lt;<span style=color:#f92672>Line</span> <span style=color:#a6e22e>points</span><span style=color:#f92672>=</span>{<span style=color:#a6e22e>points</span>} <span style=color:#a6e22e>color</span><span style=color:#f92672>=</span>{<span style=color:#a6e22e>colors</span>.<span style=color:#a6e22e>highlight</span>} /&gt;
</span></span><span style=display:flex><span>      &lt;<span style=color:#f92672>TrainWithPhysics</span> <span style=color:#a6e22e>curve</span><span style=color:#f92672>=</span>{<span style=color:#a6e22e>curve</span>} /&gt;
</span></span><span style=display:flex><span>      &lt;<span style=color:#f92672>Ground</span> <span style=color:#a6e22e>position</span><span style=color:#f92672>=</span>{[<span style=color:#ae81ff>0</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>0</span>]} /&gt;
</span></span><span style=display:flex><span>    &lt;/<span style=color:#f92672>EditorScene</span>&gt;
</span></span><span style=display:flex><span>  );
</span></span><span style=display:flex><span>};
</span></span></code></pre></div></div></article><hr><div class=post-info><p><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z"/><line x1="7" y1="7" x2="7" y2="7"/></svg>
<span class=tag><a href=https://ercanakyuerek.de/tags/writing-a-roller-coaster-simulation/>writing a roller coaster simulation</a></span></p><p><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text"><path d="M14 2H6A2 2 0 004 4v16a2 2 0 002 2h12a2 2 0 002-2V8z"/><polyline points="14 2 14 8 20 8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/><polyline points="10 9 9 9 8 9"/></svg>
2257 Words</p><p><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>
2025-12-21 13:30</p></div><hr><div class=sharing-buttons><a class=resp-sharing-button__link href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fercanakyuerek.de%2fposts%2fwriting-a-roller-coaster-simulation%2fcurve-nodes%2f" target=_blank rel=noopener aria-label title="Share on facebook"><div class="resp-sharing-button resp-sharing-button--facebook resp-sharing-button--small"><div aria-hidden=true class="resp-sharing-button__icon resp-sharing-button__icon--solid"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 2h-3a5 5 0 00-5 5v3H7v4h3v8h4v-8h3l1-4h-4V7a1 1 0 011-1h3z"/></svg></div></div></a><a class=resp-sharing-button__link href="https://twitter.com/intent/tweet/?url=https%3a%2f%2fercanakyuerek.de%2fposts%2fwriting-a-roller-coaster-simulation%2fcurve-nodes%2f" target=_blank rel=noopener aria-label title="Share on twitter"><div class="resp-sharing-button resp-sharing-button--twitter resp-sharing-button--small"><div aria-hidden=true class="resp-sharing-button__icon resp-sharing-button__icon--solid"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M23 3a10.9 10.9.0 01-3.14 1.53 4.48 4.48.0 00-7.86 3v1A10.66 10.66.0 013 4s-4 9 5 13a11.64 11.64.0 01-7 2c9 5 20 0 20-11.5a4.5 4.5.0 00-.08-.83A7.72 7.72.0 0023 3z"/></svg></div></div></a><a class=resp-sharing-button__link href="https://www.tumblr.com/widgets/share/tool?posttype=link&amp;title=Curve%20Nodes&amp;caption=Curve%20Nodes&amp;canonicalUrl=https%3a%2f%2fercanakyuerek.de%2fposts%2fwriting-a-roller-coaster-simulation%2fcurve-nodes%2f" target=_blank rel=noopener aria-label title="Share on tumblr"><div class="resp-sharing-button resp-sharing-button--tumblr resp-sharing-button--small"><div aria-hidden=true class="resp-sharing-button__icon resp-sharing-button__icon--solid"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" stroke="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14.563 24c-5.093.0-7.031-3.756-7.031-6.411V9.747H5.116V6.648c3.63-1.313 4.512-4.596 4.71-6.469C9.84.051 9.941.0 9.999.0h3.517v6.114h4.801v3.633h-4.82v7.47c.016 1.001.375 2.371 2.207 2.371h.09c.631-.02 1.486-.205 1.936-.419l1.156 3.425c-.436.636-2.4 1.374-4.156 1.404h-.178l.011.002z"/></svg></div></div></a><a class=resp-sharing-button__link href="mailto:?subject=Curve%20Nodes&amp;body=https%3a%2f%2fercanakyuerek.de%2fposts%2fwriting-a-roller-coaster-simulation%2fcurve-nodes%2f" target=_self rel=noopener aria-label title="Share via email"><div class="resp-sharing-button resp-sharing-button--email resp-sharing-button--small"><div aria-hidden=true class="resp-sharing-button__icon resp-sharing-button__icon--solid"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 4h16c1.1.0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1.0-2-.9-2-2V6c0-1.1.9-2 2-2z"/><polyline points="22,6 12,13 2,6"/></svg></div></div></a><a class=resp-sharing-button__link href="https://pinterest.com/pin/create/button/?url=https%3a%2f%2fercanakyuerek.de%2fposts%2fwriting-a-roller-coaster-simulation%2fcurve-nodes%2f&amp;media=https%3a%2f%2fercanakyuerek.de%2fposts%2fwriting-a-roller-coaster-simulation%2fcurve-nodes%2f;description=Curve%20Nodes" target=_blank rel=noopener aria-label title="Share on pinterest"><div class="resp-sharing-button resp-sharing-button--pinterest resp-sharing-button--small"><div aria-hidden=true class="resp-sharing-button__icon resp-sharing-button__icon--solid"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" stroke="none"><path d="M12.017.0C5.396.0.029 5.367.029 11.987c0 5.079 3.158 9.417 7.618 11.162-.105-.949-.199-2.403.041-3.439.219-.937 1.406-5.957 1.406-5.957s-.359-.72-.359-1.781c0-1.663.967-2.911 2.168-2.911 1.024.0 1.518.769 1.518 1.688.0 1.029-.653 2.567-.992 3.992-.285 1.193.6 2.165 1.775 2.165 2.128.0 3.768-2.245 3.768-5.487.0-2.861-2.063-4.869-5.008-4.869-3.41.0-5.409 2.562-5.409 5.199.0 1.033.394 2.143.889 2.741.099.12.112.225.085.345-.09.375-.293 1.199-.334 1.363-.053.225-.172.271-.401.165-1.495-.69-2.433-2.878-2.433-4.646.0-3.776 2.748-7.252 7.92-7.252 4.158.0 7.392 2.967 7.392 6.923.0 4.135-2.607 7.462-6.233 7.462-1.214.0-2.354-.629-2.758-1.379l-.749 2.848c-.269 1.045-1.004 2.352-1.498 3.146 1.123.345 2.306.535 3.55.535 6.607.0 11.985-5.365 11.985-11.987C23.97 5.39 18.592.026 11.985.026L12.017.0z"/></svg></div></div></a><a class=resp-sharing-button__link href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fercanakyuerek.de%2fposts%2fwriting-a-roller-coaster-simulation%2fcurve-nodes%2f&amp;title=Curve%20Nodes&amp;summary=Curve%20Nodes&amp;source=https%3a%2f%2fercanakyuerek.de%2fposts%2fwriting-a-roller-coaster-simulation%2fcurve-nodes%2f" target=_blank rel=noopener aria-label title="Share on linkedin"><div class="resp-sharing-button resp-sharing-button--linkedin resp-sharing-button--small"><div aria-hidden=true class="resp-sharing-button__icon resp-sharing-button__icon--solid"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 8a6 6 0 016 6v7h-4v-7a2 2 0 00-2-2 2 2 0 00-2 2v7h-4v-7a6 6 0 016-6z"/><rect x="2" y="9" width="4" height="12"/><circle cx="4" cy="4" r="2"/></svg></div></div></a><a class=resp-sharing-button__link href="https://reddit.com/submit/?url=https%3a%2f%2fercanakyuerek.de%2fposts%2fwriting-a-roller-coaster-simulation%2fcurve-nodes%2f&amp;resubmit=true&amp;title=Curve%20Nodes" target=_blank rel=noopener aria-label title="Share on reddit"><div class="resp-sharing-button resp-sharing-button--reddit resp-sharing-button--small"><div aria-hidden=true class="resp-sharing-button__icon resp-sharing-button__icon--solid"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" stroke="none"><path d="M12 0A12 12 0 000 12a12 12 0 0012 12 12 12 0 0012-12A12 12 0 0012 0zm5.01 4.744c.688.0 1.25.561 1.25 1.249a1.25 1.25.0 01-2.498.056l-2.597-.547-.8 3.747c1.824.07 3.48.632 4.674 1.488.308-.309.73-.491 1.207-.491.968.0 1.754.786 1.754 1.754.0.716-.435 1.333-1.01 1.614a3.111 3.111.0 01.042.52c0 2.694-3.13 4.87-7.004 4.87s-7.004-2.176-7.004-4.87c0-.183.015-.366.043-.534A1.748 1.748.0 014.028 12c0-.968.786-1.754 1.754-1.754.463.0.898.196 1.207.49 1.207-.883 2.878-1.43 4.744-1.487l.885-4.182a.342.342.0 01.14-.197.35.35.0 01.238-.042l2.906.617a1.214 1.214.0 011.108-.701zM9.25 12C8.561 12 8 12.562 8 13.25c0 .687.561 1.248 1.25 1.248.687.0 1.248-.561 1.248-1.249S9.937 12 9.249 12zm5.5.0c-.687.0-1.248.561-1.248 1.25.0.687.561 1.248 1.249 1.248S16 13.937 16 13.249c0-.687-.562-1.249-1.25-1.249zm-5.466 3.99a.327.327.0 00-.231.094.33.33.0 000 .463c.842.842 2.484.913 2.961.913s2.105-.056 2.961-.913a.361.361.0 00.029-.463.33.33.0 00-.464.0c-.547.533-1.684.73-2.512.73-.828.0-1.979-.196-2.512-.73a.326.326.0 00-.232-.095z"/></svg></div></div></a><a class=resp-sharing-button__link href="https://www.xing.com/app/user?op=share;url=https%3a%2f%2fercanakyuerek.de%2fposts%2fwriting-a-roller-coaster-simulation%2fcurve-nodes%2f;title=Curve%20Nodes" target=_blank rel=noopener aria-label title="Share on xing"><div class="resp-sharing-button resp-sharing-button--xing resp-sharing-button--small"><div aria-hidden=true class="resp-sharing-button__icon resp-sharing-button__icon--solid"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" stroke="none"><path d="M18.188.0c-.517.0-.741.325-.927.66.0.0-7.455 13.224-7.702 13.657.015.024 4.919 9.023 4.919 9.023.17.308.436.66.967.66h3.454c.211.0.375-.078.463-.22.089-.151.089-.346-.009-.536l-4.879-8.916c-.004-.006-.004-.016.0-.022L22.139.756c.095-.191.097-.387.006-.535C22.056.078 21.894.0 21.686.0h-3.498zM3.648 4.74c-.211.0-.385.074-.473.216-.09.149-.078.339.02.531l2.34 4.05c.004.01.004.016.0.021L1.86 16.051c-.099.188-.093.381.0.529.085.142.239.234.45.234h3.461c.518.0.766-.348.945-.667l3.734-6.609-2.378-4.155c-.172-.315-.434-.659-.962-.659H3.648v.016z"/></svg></div></div></a><a class=resp-sharing-button__link href="whatsapp://send?text=Curve%20Nodes%20https%3a%2f%2fercanakyuerek.de%2fposts%2fwriting-a-roller-coaster-simulation%2fcurve-nodes%2f" target=_blank rel=noopener aria-label title="Share on whatsapp"><div class="resp-sharing-button resp-sharing-button--whatsapp resp-sharing-button--small"><div aria-hidden=true class="resp-sharing-button__icon resp-sharing-button__icon--solid"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" stroke="none" stroke-width="1" stroke-linecap="round" stroke-linejoin="round"><path d="M17.472 14.382c-.297-.149-1.758-.867-2.03-.967-.273-.099-.471-.148-.67.15-.197.297-.767.966-.94 1.164-.173.199-.347.223-.644.075-.297-.15-1.255-.463-2.39-1.475-.883-.788-1.48-1.761-1.653-2.059-.173-.297-.018-.458.13-.606.134-.133.298-.347.446-.52.149-.174.198-.298.298-.497.099-.198.05-.371-.025-.52-.075-.149-.669-1.612-.916-2.207-.242-.579-.487-.5-.669-.51-.173-.008-.371-.01-.57-.01-.198.0-.52.074-.792.372-.272.297-1.04 1.016-1.04 2.479.0 1.462 1.065 2.875 1.213 3.074.149.198 2.096 3.2 5.077 4.487.709.306 1.262.489 1.694.625.712.227 1.36.195 1.871.118.571-.085 1.758-.719 2.006-1.413.248-.694.248-1.289.173-1.413-.074-.124-.272-.198-.57-.347m-5.421 7.403h-.004a9.87 9.87.0 01-5.031-1.378l-.361-.214-3.741.982.998-3.648-.235-.374a9.86 9.86.0 01-1.51-5.26c.001-5.45 4.436-9.884 9.888-9.884 2.64.0 5.122 1.03 6.988 2.898a9.825 9.825.0 012.893 6.994c-.003 5.45-4.437 9.884-9.885 9.884m8.413-18.297A11.815 11.815.0 0012.05.0C5.495.0.16 5.335.157 11.892c0 2.096.547 4.142 1.588 5.945L.057 24l6.305-1.654a11.882 11.882.0 005.683 1.448h.005c6.554.0 11.89-5.335 11.893-11.893a11.821 11.821.0 00-3.48-8.413z"/></svg></div></div></a><a class=resp-sharing-button__link href="https://news.ycombinator.com/submitlink?u=https%3a%2f%2fercanakyuerek.de%2fposts%2fwriting-a-roller-coaster-simulation%2fcurve-nodes%2f&amp;t=Curve%20Nodes" target=_blank rel=noopener aria-label title="Share on hacker news"><div class="resp-sharing-button resp-sharing-button--hackernews resp-sharing-button--small"><div aria-hidden=true class="resp-sharing-button__icon resp-sharing-button__icon--solid"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" stroke="none"><path d="M0 24V0h24v24H0zM6.951 5.896l4.112 7.708v5.064h1.583v-4.972l4.148-7.799h-1.749l-2.457 4.875c-.372.745-.688 1.434-.688 1.434s-.297-.708-.651-1.434L8.831 5.896h-1.88z"/></svg></div></div></a><a class=resp-sharing-button__link href="https://telegram.me/share/url?text=Curve%20Nodes&amp;url=https%3a%2f%2fercanakyuerek.de%2fposts%2fwriting-a-roller-coaster-simulation%2fcurve-nodes%2f" target=_blank rel=noopener aria-label title="Share on telegram"><div class="resp-sharing-button resp-sharing-button--telegram resp-sharing-button--small"><div aria-hidden=true class="resp-sharing-button__icon resp-sharing-button__icon--solid"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="22" y1="2" x2="11" y2="13"/><polygon points="22 2 15 22 11 13 2 9 22 2"/></svg></div></div></a></div><div class=pagination><div class=pagination__buttons><span class="button previous"><a href=https://ercanakyuerek.de/posts/writing-a-roller-coaster-simulation/transformation-matrix/><span class=button__icon>←</span>
<span class=button__text>Transformation Matrix</span>
</a></span><span class="button next"><a href=https://ercanakyuerek.de/posts/writing-a-roller-coaster-simulation/bezier-curve/><span class=button__text>Bézier curve</span>
<span class=button__icon>→</span></a></span></div></div></main></div><footer class=footer></footer></div><script type=text/javascript src=/bundle.min.257531934bfbdf8527f52eab4b38eb8211337125b54dae74132499837c006508dae0d544e859d909af1be266d147861c1c1e688de0f7d2cc2f258de78a9b8a6a.js integrity="sha512-JXUxk0v734Un9S6rSzjrghEzcSW1Ta50EySZg3wAZQja4NVE6FnZCa8b4mbRR4YcHB5ojeD30swvJY3nipuKag=="></script></body></html>